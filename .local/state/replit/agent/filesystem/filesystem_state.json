{"file_contents":{"app.css":{"content":"/* Domo Brand Colors - Official Palette */\n:root {\n    /* Primary Domo Blue */\n    --domo-blue: #007DBA;\n    --domo-blue-dark: #005a8c;\n    --domo-blue-light: #e6f4fb;\n\n    /* Domo Orange Accent */\n    --domo-orange: #FF8C42;\n    --domo-orange-light: #FFE5D6;\n\n    /* Status Colors */\n    --critical-red: #dc3545;\n    --warning-orange: #fd7e14;\n    --healthy-green: #28a745;\n    --growth-blue: var(--domo-blue);\n\n    /* Domo Neutrals */\n    --neutral-white: #FFFFFF;\n    --neutral-gray-50: #F1F4FA;\n    --neutral-gray-100: #DCE4EA;\n    --neutral-gray-200: #B7C1CB;\n    --neutral-gray-300: #68737F;\n    --neutral-gray-400: #3F4540;\n    --neutral-gray-500: #adb5bd;\n    --neutral-gray-600: #6c757d;\n    --neutral-gray-700: #495057;\n    --neutral-gray-800: #343a40;\n    --neutral-gray-900: #212529;\n\n    /* Domo Accent Colors */\n    --accent-purple: #776CB0;\n    --accent-pink: #C1798D;\n    --accent-light-pink: #ECA4C0;\n    --accent-mint: #A0A4C1;\n\n    /* Variables for Modal and Form */\n    --background-primary: #FFFFFF;\n    --background-secondary: #F8F9FA;\n    --background-hover: #E9ECEF;\n    --border-color: #DEE2E6;\n    --primary-color: #007DBA;\n    --text-primary: #212529;\n    --text-secondary: #6C757D;\n}\n\n/* Global Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n/* Web App Optimizations */\nhtml {\n    -webkit-text-size-adjust: 100%;\n    -ms-text-size-adjust: 100%;\n    -webkit-tap-highlight-color: transparent;\n    touch-action: manipulation;\n}\n\n/* Prevent zoom on input focus */\ninput,\nselect,\ntextarea {\n    font-size: 16px;\n}\n\n/* Smooth scrolling for all elements */\n* {\n    -webkit-overflow-scrolling: touch;\n}\n\n/* Hide scrollbars in webkit browsers while maintaining functionality */\n::-webkit-scrollbar {\n    width: 6px;\n    height: 6px;\n}\n\n::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n::-webkit-scrollbar-thumb {\n    background: rgba(0, 125, 186, 0.3);\n    border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: rgba(0, 125, 186, 0.5);\n}\n\n@import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;1,400&display=swap');\n\nbody {\n    font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n    background-color: var(--neutral-gray-50);\n    color: var(--neutral-gray-800);\n    line-height: 1.5;\n}\n\n#app {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n/* Header Styles */\n.app-header {\n    background: linear-gradient(135deg, var(--domo-blue), var(--domo-blue-dark));\n    color: var(--neutral-white);\n    padding: 1rem 2rem;\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.15);\n}\n\n.header-content {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    max-width: 1400px;\n    margin: 0 auto;\n}\n\n.logo-section {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.logo-section i {\n    font-size: 1.5rem;\n}\n\n.logo-section h1 {\n    font-size: 1.5rem;\n    font-weight: 600;\n}\n\n/* Navigation Tabs */\n.nav-tabs {\n    background: white;\n    border-bottom: 1px solid var(--neutral-gray-300);\n    padding: 0 2rem;\n    display: flex;\n    gap: 0;\n    max-width: 1400px;\n    margin: 0 auto;\n    width: 100%;\n}\n\n.nav-tab {\n    background: none;\n    border: none;\n    padding: 1rem 1.5rem;\n    font-size: 0.9rem;\n    font-weight: 500;\n    color: var(--neutral-gray-600);\n    cursor: pointer;\n    border-bottom: 3px solid transparent;\n    transition: all 0.3s ease;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.nav-tab:hover {\n    color: var(--domo-blue);\n    background-color: var(--domo-blue-light);\n}\n\n.nav-tab.active {\n    color: var(--domo-blue);\n    border-bottom-color: var(--domo-orange);\n    background-color: var(--domo-blue-light);\n    font-weight: 600;\n}\n\n/* Main Content */\n.main-content {\n    flex: 1;\n    padding: 2rem;\n    max-width: 1400px;\n    margin: 0 auto;\n    width: 100%;\n}\n\n.tab-content {\n    display: none;\n}\n\n.tab-content.active {\n    display: block;\n}\n\n/* Summary Bar */\n.summary-bar {\n    background: var(--neutral-white);\n    border-radius: 12px;\n    padding: 2rem;\n    margin-bottom: 1.5rem;\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.08);\n    display: flex;\n    gap: 3rem;\n    border-top: 3px solid var(--domo-blue);\n}\n\n.summary-item {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    text-align: center;\n}\n\n.summary-number {\n    font-size: 2rem;\n    font-weight: 700;\n    color: var(--domo-blue);\n}\n\n/* Apply red color to high priority numbers */\n.summary-number.high-priority {\n    color: var(--critical-red);\n}\n\n.summary-text {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-600);\n    margin-top: 0.25rem;\n}\n\n/* Filter Bar */\n.filter-bar {\n    display: flex;\n    gap: 1rem;\n    margin-bottom: 1.5rem;\n}\n\n.filter-select {\n    padding: 0.5rem 1rem;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 6px;\n    font-size: 0.9rem;\n    background: white;\n    cursor: pointer;\n}\n\n.filter-select:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 3px rgba(0, 125, 186, 0.1);\n}\n\n/* Button Styles */\n.btn {\n    padding: 0.5rem 1rem;\n    border: none;\n    border-radius: 6px;\n    font-size: 0.9rem;\n    font-weight: 500;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.btn-primary {\n    background: var(--domo-blue);\n    color: white;\n}\n\n.btn-primary:hover {\n    background: var(--domo-blue-dark);\n}\n\n.btn-secondary {\n    background: var(--neutral-gray-200);\n    color: var(--neutral-gray-700);\n}\n\n.btn-secondary:hover {\n    background: var(--neutral-gray-300);\n}\n\n.filter-btn {\n    padding: 0.5rem 1rem;\n    border: 1px solid var(--neutral-gray-300);\n    background: white;\n    color: var(--neutral-gray-600);\n    border-radius: 6px;\n    font-size: 0.9rem;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.filter-btn:hover {\n    border-color: var(--domo-blue);\n    color: var(--domo-blue);\n}\n\n.filter-btn.active {\n    background: var(--domo-blue);\n    color: white;\n    border-color: var(--domo-blue);\n}\n\n/* Header Actions */\n.header-actions {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n}\n\n/* Add New Signal button styles removed */\n\n/* Signal Cards */\n.signals-list {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n}\n\n.signal-card {\n    background: var(--neutral-white);\n    border-radius: 12px;\n    padding: 1.5rem;\n    box-shadow: 0 1px 3px rgba(0, 125, 186, 0.08);\n    border-left: 4px solid var(--neutral-gray-200);\n    transition: all 0.3s ease;\n    cursor: pointer;\n    border: 1px solid var(--neutral-gray-100);\n    position: relative;\n}\n\n.signal-card:hover {\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n    transform: translateY(-1px);\n}\n\n.signal-card.high-priority {\n    border-left-color: var(--critical-red);\n}\n\n.signal-card.medium-priority {\n    border-left-color: var(--warning-orange);\n}\n\n.signal-card.low-priority {\n    border-left-color: var(--healthy-green);\n}\n\n/* New Signal Styles - Vibrant */\n.signal-card.signal-new {\n    background: white;\n    border: 2px solid var(--domo-blue-light);\n    box-shadow: 0 4px 16px rgba(0, 125, 186, 0.15);\n    animation: subtle-pulse 2s ease-in-out infinite;\n}\n\n.signal-card.signal-new:hover {\n    box-shadow: 0 8px 24px rgba(0, 125, 186, 0.2);\n    transform: translateY(-2px);\n}\n\n.signal-card.signal-new.high-priority {\n    border-left-width: 6px;\n    border-left-color: var(--critical-red);\n    box-shadow: 0 4px 16px rgba(220, 53, 69, 0.2);\n}\n\n.signal-card.signal-new.medium-priority {\n    border-left-width: 6px;\n    border-left-color: var(--warning-orange);\n    box-shadow: 0 4px 16px rgba(253, 126, 20, 0.2);\n}\n\n.signal-card.signal-new.low-priority {\n    border-left-width: 6px;\n    border-left-color: var(--healthy-green);\n    box-shadow: 0 4px 16px rgba(40, 167, 69, 0.2);\n}\n\n/* Auto-viewed notification */\n.auto-viewed-notification {\n    position: fixed;\n    top: 100px;\n    right: 20px;\n    background: var(--domo-blue);\n    color: white;\n    padding: 0.75rem 1rem;\n    border-radius: 6px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    opacity: 0;\n    transform: translateX(100%);\n    transition: all 0.3s ease;\n    z-index: 1000;\n    font-size: 0.9rem;\n}\n\n.auto-viewed-notification.show {\n    opacity: 1;\n    transform: translateX(0);\n}\n\n.auto-viewed-notification .notification-content {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n/* Signal section headers */\n.signals-section-header {\n    padding: 1rem 0;\n    margin-bottom: 1rem;\n}\n\n.signals-section-header.new-signals {\n    border-bottom: 2px solid var(--domo-blue);\n    background: white;\n    padding: 1.5rem 1.5rem 1rem 1.5rem;\n    margin: 0 -1rem 1.5rem -1rem;\n    border-radius: 8px;\n}\n\n.section-header-content {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.section-header-content i {\n    color: var(--domo-blue);\n    font-size: 1.2rem;\n}\n\n.section-header-content h3 {\n    margin: 0;\n    color: var(--neutral-gray-800);\n    font-size: 1.1rem;\n    font-weight: 600;\n}\n\n.section-subtitle {\n    color: var(--neutral-gray-600);\n    font-size: 0.9rem;\n    font-style: italic;\n    margin-left: auto;\n}\n\n/* Updated separator styling */\n.signal-separator .separator-text {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    color: var(--neutral-gray-600);\n    font-weight: 600;\n}\n\n.signal-separator .separator-text i {\n    font-size: 0.9rem;\n}\n\n/* Viewed Signal Styles - Muted */\n.signal-card.signal-viewed {\n    background: var(--neutral-gray-50);\n    border: 1px solid var(--neutral-gray-200);\n    opacity: 0.7;\n    color: var(--neutral-gray-600);\n}\n\n.signal-card.signal-viewed .signal-title {\n    color: var(--neutral-gray-600);\n}\n\n.signal-card.signal-viewed .signal-meta {\n    color: var(--neutral-gray-500);\n}\n\n.signal-card.signal-viewed .summary-text {\n    color: var(--neutral-gray-600);\n}\n\n.signal-card.signal-viewed .rationale-text {\n    background: var(--neutral-gray-100);\n    border-left-color: var(--neutral-gray-300);\n    color: var(--neutral-gray-600);\n}\n\n.signal-card.signal-viewed .rationale-text strong {\n    color: var(--neutral-gray-700);\n}\n\n.signal-card.signal-viewed:hover {\n    opacity: 0.85;\n    transform: translateY(-1px);\n}\n\n.signal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    margin-bottom: 1.5rem;\n}\n\n.signal-close-btn {\n    background: none;\n    border: none;\n    color: var(--neutral-gray-400);\n    font-size: 1rem;\n    cursor: pointer;\n    padding: 0.25rem;\n    border-radius: 50%;\n    width: 28px;\n    height: 28px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: all 0.2s ease;\n    flex-shrink: 0;\n}\n\n.signal-close-btn:hover {\n    background: var(--neutral-gray-100);\n    color: var(--neutral-gray-600);\n}\n\n.signal-close-btn:active {\n    background: var(--neutral-gray-200);\n}\n\n.signal-info {\n    flex: 1;\n    padding-right: 1rem;\n}\n\n.signal-title {\n    font-size: 1.25rem;\n    font-weight: 700;\n    color: var(--neutral-gray-800);\n    margin-bottom: 0.75rem;\n    line-height: 1.3;\n    letter-spacing: -0.01em;\n}\n\n.signal-meta {\n    display: flex;\n    align-items: center;\n    gap: 1.5rem;\n    font-size: 0.9rem;\n    color: var(--neutral-gray-600);\n    font-weight: 500;\n}\n\n.signal-actions {\n    display: flex;\n    gap: 0.5rem;\n}\n\n.signal-summary {\n    font-size: 1rem;\n    color: var(--neutral-gray-700);\n    margin-bottom: 1.5rem;\n    line-height: 1.7;\n    font-weight: 400;\n}\n\n.summary-text {\n    margin-bottom: 1rem;\n}\n\n.rationale-text {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n    background: var(--domo-blue-light);\n    padding: 0.75rem;\n    border-radius: 6px;\n    border-left: 3px solid var(--domo-blue);\n    font-style: italic;\n}\n\n.rationale-text strong {\n    color: var(--domo-blue);\n    font-style: normal;\n}\n\n.signal-footer {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n/* Priority Badge */\n.priority-badge {\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.priority-high {\n    background: rgba(220, 53, 69, 0.1);\n    color: var(--critical-red);\n}\n\n.priority-medium {\n    background: rgba(253, 126, 20, 0.1);\n    color: var(--warning-orange);\n}\n\n.priority-low {\n    background: rgba(40, 167, 69, 0.1);\n    color: var(--healthy-green);\n}\n\n/* Signal Polarity Pill */\n.polarity-badge {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 600;\n    text-transform: none;\n    white-space: nowrap;\n    width: auto;\n    max-width: none;\n    text-overflow: clip;\n    overflow: visible;\n    margin: 0;\n}\n\n.polarity-risk {\n    background: #c82333;\n    /* Darker Red for better contrast */\n    color: #FFFFFF;\n}\n\n.polarity-opportunities {\n    background: #218838;\n    /* Darker Green for better contrast */\n    color: #FFFFFF;\n}\n\n.polarity-enrichment {\n    background: #4169E1;\n    /* Royal Blue */\n    color: #FFFFFF;\n}\n\n/* Polarity column wrapper for centering */\n.polarity-col {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n/* Category Badge */\n.category-badge {\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 500;\n    background: rgba(0, 125, 186, 0.1);\n    color: var(--domo-blue);\n}\n\n/* New Badge */\n.new-badge {\n    padding: 0.25rem 0.5rem;\n    border-radius: 8px;\n    font-size: 0.65rem;\n    font-weight: 700;\n    text-transform: uppercase;\n    background: linear-gradient(45deg, var(--domo-orange), #ff6b3d);\n    color: white;\n    box-shadow: 0 2px 4px rgba(255, 140, 66, 0.3);\n    animation: new-badge-glow 2s ease-in-out infinite;\n}\n\n/* Signal Separator */\n.signal-separator {\n    display: flex;\n    align-items: center;\n    margin: 2rem 0;\n    padding: 0 1rem;\n}\n\n.separator-line {\n    flex: 1;\n    height: 1px;\n    background: linear-gradient(to right, transparent, var(--neutral-gray-300), transparent);\n}\n\n.separator-text {\n    padding: 0 1.5rem;\n    font-size: 0.9rem;\n    font-weight: 600;\n    color: var(--neutral-gray-500);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 20px;\n    padding: 0.5rem 1rem;\n}\n\n/* Animations */\n@keyframes subtle-pulse {\n\n    0%,\n    100% {\n        box-shadow: 0 4px 16px rgba(0, 125, 186, 0.15);\n    }\n\n    50% {\n        box-shadow: 0 4px 20px rgba(0, 125, 186, 0.25);\n    }\n}\n\n@keyframes new-badge-glow {\n\n    0%,\n    100% {\n        box-shadow: 0 2px 4px rgba(255, 140, 66, 0.3);\n    }\n\n    50% {\n        box-shadow: 0 2px 8px rgba(255, 140, 66, 0.5);\n    }\n}\n\n/* Portfolio Dashboard Cards */\n.portfolio-dashboard-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n    gap: 1.5rem;\n    margin-bottom: 2rem;\n}\n\n.dashboard-card {\n    background: white;\n    border-radius: 12px;\n    padding: 1.5rem;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);\n    border: 1px solid var(--neutral-gray-200);\n    display: flex;\n    align-items: flex-start;\n    gap: 1rem;\n    transition: box-shadow 0.2s ease, transform 0.2s ease;\n}\n\n.dashboard-card:hover {\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);\n    transform: translateY(-1px);\n}\n\n.dashboard-card .card-icon {\n    width: 40px;\n    height: 40px;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.2rem;\n    flex-shrink: 0;\n}\n\n.attention-card .card-icon {\n    background: rgba(220, 53, 69, 0.1);\n    color: var(--critical-red);\n}\n\n.priority-card .card-icon {\n    background: rgba(54, 162, 235, 0.1);\n    color: var(--domo-blue);\n}\n\n.accounts-card .card-icon {\n    background: rgba(75, 192, 192, 0.1);\n    color: var(--healthy-green);\n}\n\n.dashboard-card .card-content {\n    flex: 1;\n}\n\n.dashboard-card .card-title {\n    font-size: 0.9rem;\n    font-weight: 600;\n    color: var(--neutral-gray-600);\n    margin-bottom: 0.25rem;\n}\n\n.dashboard-card .card-value {\n    font-size: 2rem;\n    font-weight: 700;\n    color: var(--neutral-gray-800);\n    margin-bottom: 0.25rem;\n    line-height: 1;\n}\n\n.dashboard-card .card-description {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-500);\n}\n\n/* Portfolio Sections */\n.portfolio-section {\n    margin-bottom: 32px;\n}\n\n.portfolio-section-header {\n    color: var(--neutral-gray-800);\n    font-size: 18px;\n    font-weight: 600;\n    margin-bottom: 16px;\n    padding-bottom: 8px;\n    border-bottom: 2px solid var(--domo-blue);\n    display: flex;\n    align-items: center;\n}\n\n.portfolio-section-content {\n    margin-left: 0;\n}\n\n/* Portfolio Account Cards */\n.accounts-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.portfolio-account-card {\n    background: --accent-mint;\n    border-radius: 12px;\n    border: 1px solid var(--neutral-gray-200);\n    overflow: hidden;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\n    transition: box-shadow 0.2s ease;\n}\n\n.portfolio-account-card:hover {\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.account-header-row {\n    padding: 1.25rem 1.5rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    cursor: pointer;\n    transition: background-color 0.2s ease;\n    background: white;\n}\n\n.account-header-row:hover {\n    background-color: var(--neutral-gray-50);\n}\n\n.account-title-section {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.account-chevron {\n    color: var(--neutral-gray-400);\n    font-size: 0.75rem;\n    transition: transform 0.2s ease;\n}\n\n.account-chevron.rotated {\n    transform: rotate(90deg);\n}\n\n.account-warning-icon {\n    display: flex;\n    align-items: center;\n}\n\n.account-warning-icon i {\n    font-size: 1rem;\n}\n\n.critical-warning {\n    color: var(--critical-red);\n}\n\n.warning-warning {\n    color: var(--warning-orange);\n}\n\n.healthy-warning {\n    color: var(--healthy-green);\n}\n\n.acknowledged-btn {\n    background-color: var(--domo-blue) !important;\n    border-color: var(--domo-blue) !important;\n    color: white !important;\n}\n\n/* Faded priority badge for signals with feedback */\n.signal-card.signal-like .priority-badge,\n.signal-card.signal-not-accurate .priority-badge,\n.signal-card.signal-acknowledge .priority-badge {\n    opacity: 0.3;\n    filter: grayscale(50%);\n}\n\n.account-name-info {\n    display: flex;\n    flex-direction: column;\n}\n\n.account-name {\n    font-size: 1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.account-stats {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n    margin-top: 0.125rem;\n}\n\n.account-actions-section {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.critical-badge {\n    background: var(--critical-red);\n    color: white;\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.view-details-btn {\n    font-size: 0.85rem;\n    padding: 0.5rem 1rem;\n}\n\n.account-details {\n    display: none;\n    border-top: 1px solid var(--neutral-gray-100);\n    background: white;\n}\n\n.account-details.expanded {\n    display: block;\n}\n\n/* Account Metrics Styling */\n.account-metrics {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n    margin-bottom: 1.5rem;\n}\n\n.financial-metrics-box {\n    background: #f8f9fa;\n    border: 1px solid var(--domo-blue);\n    border-radius: 12px;\n    padding: 1rem;\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.1);\n}\n\n.financial-header {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 0.75rem;\n    font-weight: 600;\n    color: var(--domo-blue);\n    font-size: 0.9rem;\n}\n\n.financial-header i {\n    font-size: 0.8rem;\n}\n\n.financial-content {\n    display: flex;\n    gap: 1.5rem;\n    flex-wrap: wrap;\n}\n\n.financial-metric {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    min-width: 100px;\n    flex: 1;\n}\n\n.financial-label {\n    font-size: 0.75rem;\n    color: var(--neutral-gray-600);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    margin-bottom: 0.25rem;\n}\n\n.financial-value {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n}\n\n.other-metrics {\n    display: flex;\n    gap: 1rem;\n    flex-wrap: wrap;\n}\n\n.metric {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 0.75rem;\n    background: white;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 8px;\n    min-width: 80px;\n    flex: 1;\n}\n\n.metric-label {\n    font-size: 0.75rem;\n    color: var(--neutral-gray-600);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    margin-bottom: 0.25rem;\n}\n\n.metric-value {\n    font-size: 1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n}\n\n/* Special styling for different metric types */\n.metric[data-type=\"arr\"] .metric-value {\n    color: var(--healthy-green);\n}\n\n.metric[data-type=\"gpa\"] .metric-value {\n    color: var(--domo-blue);\n}\n\n.metric[data-type=\"mau\"] .metric-value {\n    color: var(--accent-purple);\n}\n\n.metric[data-type=\"tenure\"] .metric-value {\n    color: var(--neutral-gray-700);\n}\n\n.metric[data-type=\"renewal\"] .metric-value {\n    color: var(--domo-orange);\n}\n\n.metric[data-type=\"forecast\"] .metric-value {\n    color: var(--accent-purple);\n}\n\n.metric[data-type=\"renewal-date\"] .metric-value {\n    color: var(--neutral-gray-600);\n    font-size: 1rem;\n}\n\n/* Delta styling for forecast */\n.delta {\n    font-size: 0.9rem;\n    font-weight: 600;\n    margin-left: 0.25rem;\n}\n\n.delta.positive {\n    color: var(--healthy-green);\n}\n\n.delta.negative {\n    color: var(--critical-red);\n}\n\n/* Account Comments Section */\n.account-comments-section {\n    padding: 1.5rem 1.5rem 1rem 1.5rem;\n    border-bottom: 1px solid var(--neutral-gray-100);\n    background: white;\n}\n\n.comments-header {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n}\n\n.comments-icon {\n    color: var(--domo-blue);\n    font-size: 0.9rem;\n}\n\n.comments-count {\n    font-size: 1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n/* Signals Section */\n.signals-section {\n    display: none;\n    /* Hide Recent Signals section */\n    padding: 1.5rem 1.5rem 1rem 1.5rem;\n    border-bottom: 1px solid var(--neutral-gray-100);\n    background: white;\n}\n\n.signals-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: 8px;\n    padding: 0 4px;\n}\n\n.signals-header-left {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.signals-icon {\n    color: var(--domo-blue);\n    font-size: 0.9rem;\n}\n\n.signals-title {\n    font-size: 0.95rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.more-signals-link {\n    font-size: 12px;\n    color: var(--domo-blue);\n    text-decoration: none;\n    font-weight: 500;\n}\n\n.more-signals-link:hover {\n    text-decoration: underline;\n}\n\n.signals-list-portfolio {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n}\n\n/* Updated Portfolio Signal Rows - Clean Design */\n.portfolio-signal-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 12px 16px;\n    border-bottom: 1px solid var(--neutral-gray-100);\n    transition: background-color 0.2s ease;\n    min-height: 48px;\n}\n\n.portfolio-signal-row:last-child {\n    border-bottom: none;\n}\n\n.portfolio-signal-row:hover {\n    background-color: var(--neutral-gray-50);\n}\n\n.signal-priority-badge {\n    flex-shrink: 0;\n    margin-right: 12px;\n}\n\n.priority-tag {\n    padding: 4px 8px;\n    border-radius: 4px;\n    font-size: 11px;\n    font-weight: 600;\n    text-transform: lowercase;\n    display: inline-block;\n    min-width: 60px;\n    text-align: center;\n}\n\n.priority-tag.priority-high {\n    background-color: #dc3545;\n    color: white;\n}\n\n.priority-tag.priority-medium {\n    background-color: #fd7e14;\n    color: white;\n}\n\n.priority-tag.priority-low {\n    background-color: #6c757d;\n    color: white;\n}\n\n.signal-name-content {\n    flex: 1;\n    margin-right: 12px;\n}\n\n.signal-name-text {\n    font-size: 14px;\n    color: var(--neutral-gray-800);\n    font-weight: 400;\n    line-height: 1.3;\n}\n\n.signal-meta-actions {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    flex-shrink: 0;\n}\n\n.signal-date-text {\n    font-size: 12px;\n    color: var(--neutral-gray-600);\n    font-weight: 400;\n}\n\n.view-link {\n    font-size: 12px;\n    color: var(--domo-blue);\n    text-decoration: none;\n    font-weight: 500;\n    padding: 4px 8px;\n    border-radius: 3px;\n    transition: all 0.2s ease;\n}\n\n.view-link:hover {\n    background-color: var(--domo-blue-light);\n    text-decoration: none;\n}\n\n.portfolio-signal-item {\n    display: none;\n    /* Hide old style */\n}\n\n.portfolio-signal-item:hover {\n    display: none;\n    /* Hide old style */\n}\n\n.signal-priority-section {\n    min-width: 60px;\n}\n\n.priority-badge-small {\n    padding: 0.2rem 0.5rem;\n    border-radius: 8px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    text-transform: lowercase;\n}\n\n.priority-badge-small.priority-high {\n    background: var(--critical-red);\n    color: white;\n}\n\n.priority-badge-small.priority-medium {\n    background: var(--warning-orange);\n    color: white;\n}\n\n.priority-badge-small.priority-low {\n    background: var(--healthy-green);\n    color: white;\n}\n\n.signal-name-section {\n    flex: 1;\n    margin-left: 1rem;\n}\n\n.signal-name {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-800);\n}\n\n.signal-date-section {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.signal-date-small {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-600);\n}\n\n.view-signal-btn {\n    background: none;\n    border: none;\n    color: var(--domo-blue);\n    font-size: 0.8rem;\n    cursor: pointer;\n    padding: 0.25rem 0.5rem;\n    border-radius: 4px;\n}\n\n.view-signal-btn:hover {\n    background: var(--domo-blue-light);\n}\n\n/* AI Recommendations Section */\n.ai-recommendations-section {\n    /* Removed outer container styling - now just a transparent container */\n    padding: 0;\n    border-bottom: none;\n    background: transparent;\n}\n\n.recommendations-header {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n}\n\n.recommendation-warning-icon {\n    color: var(--warning-orange);\n    font-size: 0.9rem;\n}\n\n.recommendations-title {\n    font-size: 0.95rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.recommendations-list-container {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.recommendations-list-container {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.recommendation-list-item {\n    display: grid;\n    grid-template-columns: 1fr 70px 110px;\n    gap: 15px;\n    align-items: center;\n    padding: 0.75rem;\n    border-bottom: 1px solid var(--neutral-gray-100);\n    background: var(--neutral-white);\n    border-left: 3px solid var(--domo-blue);\n    border-radius: 8px;\n    margin: 0 -1rem;\n    padding-left: 1.75rem;\n    padding-right: 1.75rem;\n}\n\n.recommendation-list-item:last-child {\n    border-bottom: none;\n}\n\n.recommendation-priority-badge {\n    padding: 0.25rem 0.5rem;\n    border-radius: 4px;\n    font-size: 0.65rem;\n    font-weight: 700;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    white-space: nowrap;\n    text-align: center;\n    margin-top: 2px;\n}\n\n.recommendation-priority-badge.priority-high {\n    background: rgba(220, 53, 69, 0.1);\n    color: var(--critical-red);\n}\n\n.recommendation-priority-badge.priority-medium {\n    background: rgba(253, 126, 20, 0.1);\n    color: var(--warning-orange);\n}\n\n.recommendation-priority-badge.priority-low {\n    background: rgba(40, 167, 69, 0.1);\n    color: var(--healthy-green);\n}\n\n/* Related Calls Section */\n.related-calls-section {\n    margin-top: 0.5rem;\n    padding-top: 0.5rem;\n    border-top: 1px solid rgba(0, 125, 186, 0.15);\n}\n\n.related-calls-label {\n    font-size: 0.75rem;\n    font-weight: 600;\n    color: var(--neutral-gray-600);\n    margin-right: 0.5rem;\n}\n\n.related-calls-list {\n    display: inline;\n}\n\n.call-link {\n    color: var(--domo-blue);\n    cursor: pointer;\n    text-decoration: underline;\n    font-size: 0.75rem;\n    position: relative;\n    transition: color 0.2s ease;\n}\n\n.call-link:hover {\n    color: var(--domo-blue-dark);\n    text-decoration: none;\n}\n\n/* Call Details Modal */\n.call-modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.5);\n    z-index: 1000;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    opacity: 0;\n    transition: opacity 0.2s ease;\n}\n\n.call-modal-overlay.show {\n    opacity: 1;\n}\n\n.call-modal {\n    background: white;\n    border-radius: 12px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);\n    max-width: 500px;\n    width: 90%;\n    max-height: 80vh;\n    overflow-y: auto;\n    transform: scale(0.9);\n    transition: transform 0.2s ease;\n}\n\n.call-modal-overlay.show .call-modal {\n    transform: scale(1);\n}\n\n.call-modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    padding: 1.5rem;\n    border-bottom: 1px solid var(--neutral-gray-200);\n}\n\n.call-modal-title-section {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n}\n\n.call-modal-title {\n    font-weight: 600;\n    font-size: 1.1rem;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.call-modal-link {\n    color: var(--domo-blue);\n    text-decoration: none;\n    font-size: 0.9rem;\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n    transition: color 0.2s ease;\n}\n\n.call-modal-link:hover {\n    color: var(--domo-blue-dark);\n    text-decoration: underline;\n}\n\n.call-modal-close {\n    background: none;\n    border: none;\n    font-size: 1.5rem;\n    color: var(--neutral-gray-500);\n    cursor: pointer;\n    padding: 0;\n    width: 30px;\n    height: 30px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 50%;\n    transition: background-color 0.2s ease;\n}\n\n.call-modal-close:hover {\n    background: var(--neutral-gray-100);\n    color: var(--neutral-gray-700);\n}\n\n.call-modal-content {\n    padding: 1.5rem;\n}\n\n.call-modal-date,\n.call-modal-attendees {\n    margin-bottom: 1rem;\n    color: var(--neutral-gray-700);\n    line-height: 1.4;\n}\n\n.call-modal-recap {\n    margin-bottom: 1.5rem;\n    color: var(--neutral-gray-700);\n}\n\n.call-modal-recap-content {\n    margin-top: 0.5rem;\n    padding: 1rem;\n    background: var(--neutral-gray-50);\n    border-radius: 6px;\n    border-left: 3px solid var(--domo-blue);\n    line-height: 1.5;\n    font-style: italic;\n}\n\n.call-modal-signals {\n    margin-top: 1.5rem;\n    padding-top: 1rem;\n    border-top: 1px solid var(--neutral-gray-100);\n}\n\n.call-modal-signals-title {\n    font-weight: 600;\n    color: var(--neutral-gray-700);\n    margin-bottom: 1rem;\n}\n\n.call-modal-signals-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.call-modal-signal {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    padding: 1rem;\n    background: var(--neutral-gray-50);\n    border-radius: 6px;\n}\n\n.call-modal-signal-header {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.call-modal-signal-summary {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n    line-height: 1.4;\n    padding-left: 0.5rem;\n    border-left: 2px solid var(--neutral-gray-200);\n    margin-left: 0.5rem;\n}\n\n.call-modal-signal-priority {\n    padding: 0.25rem 0.5rem;\n    border-radius: 4px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    text-transform: none;\n    white-space: nowrap;\n}\n\n.call-modal-signal-priority.polarity-risk {\n    background-color: #e53e3e;\n    color: white;\n}\n\n.call-modal-signal-priority.polarity-opportunities {\n    background-color: #38a169;\n    color: white;\n}\n\n.call-modal-signal-priority.polarity-enrichment {\n    background-color: #718096;\n    color: white;\n}\n\n.call-modal-signal-name {\n    flex: 1;\n    font-size: 0.9rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n}\n\n.recommendation-text {\n    flex: 1;\n    font-size: 0.9rem;\n    color: var(--neutral-gray-800);\n    line-height: 1.4;\n    font-weight: bold;\n}\n\n.recommendation-date {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-500);\n    white-space: nowrap;\n    text-align: center;\n    margin-top: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.recommendation-action-button {\n    display: flex;\n    justify-content: flex-end;\n    align-items: center;\n}\n\n.btn-add-to-plan {\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    padding: 0.35rem 0.7rem;\n    border-radius: 4px;\n    font-size: 0.75rem;\n    font-weight: 500;\n    cursor: pointer;\n    transition: background 0.2s ease;\n    white-space: nowrap;\n}\n\n.btn-add-to-plan:hover {\n    background: var(--domo-blue-dark);\n}\n\n.btn-added-status {\n    color: var(--healthy-green);\n    font-size: 0.75rem;\n    font-weight: 600;\n    white-space: nowrap;\n    text-align: right;\n}\n\n.no-recommendations-message {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-500);\n    font-style: italic;\n    padding: 1rem 0;\n    text-align: center;\n}\n\n/* Legacy styles for compatibility */\n.ai-header {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n}\n\n.ai-icon {\n    color: var(--domo-orange);\n    font-size: 0.9rem;\n}\n\n.ai-title {\n    font-size: 0.95rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.recommendation-priority {\n    margin-bottom: 1.25rem;\n}\n\n.recommendations-merged {\n    margin-top: 1rem;\n}\n\n.merged-recommendation-item {\n    margin-bottom: 1.25rem;\n}\n\n.merged-recommendation-item:last-child {\n    margin-bottom: 0;\n}\n\n.recommendation-action {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-800);\n    font-weight: 500;\n    margin-bottom: 0.5rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    gap: 0.5rem;\n}\n\n.recommendation-actions-list .recommendation-action {\n    margin-bottom: 0.25rem;\n}\n\n.recommendation-rationale {\n    background: var(--domo-blue-light);\n    border: 1px solid rgba(0, 125, 186, 0.2);\n    border-radius: 8px;\n    padding: 1rem;\n    font-size: 0.85rem;\n    color: var(--neutral-gray-800);\n    line-height: 1.5;\n    font-weight: 400;\n    margin-left: 1rem;\n}\n\n.recommendation-rationale br {\n    margin-bottom: 0.5rem;\n}\n\n/* Action Button Layout */\n.recommendation-action {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 8px;\n}\n\n.action-content {\n    flex: 1;\n    display: flex;\n    align-items: center;\n}\n\n.action-buttons {\n    margin-left: 15px;\n}\n\n/* Add to Plan Buttons */\n\n\n.btn-secondary {\n    background: var(--neutral-gray-600);\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 500;\n    transition: background-color 0.2s;\n}\n\n.btn-secondary:hover {\n    background: var(--neutral-gray-700);\n}\n\n.btn-primary {\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 500;\n    transition: background-color 0.2s;\n}\n\n.btn-primary:hover {\n    background: var(--domo-blue-dark);\n}\n\n\n\n/* Legacy styles for backwards compatibility */\n.recommendations-two-column {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 1.5rem;\n    margin-top: 1rem;\n}\n\n.recommendations-actions-column,\n.recommendations-rationale-column {\n    padding: 0;\n}\n\n.column-title {\n    font-size: 0.8rem;\n    font-weight: 600;\n    color: var(--neutral-gray-600);\n    margin: 0 0 0.75rem 0;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.rationale-summary {\n    background: var(--domo-blue-light);\n    border: 1px solid rgba(0, 125, 186, 0.2);\n    border-radius: 8px;\n    padding: 1rem;\n    font-size: 0.85rem;\n    color: var(--neutral-gray-800);\n    line-height: 1.5;\n    font-weight: 400;\n}\n\n.rationale-summary br {\n    margin-bottom: 0.5rem;\n}\n\n.immediate-badge {\n    background: var(--domo-orange);\n    color: white;\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    text-transform: uppercase;\n    box-shadow: 0 1px 3px rgba(255, 140, 66, 0.3);\n}\n\n.near-term-badge {\n    background: #e3f2fd;\n    color: #1976d2;\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    text-transform: uppercase;\n    box-shadow: 0 1px 3px rgba(25, 118, 210, 0.3);\n}\n\n.recommendation-summary {\n    background: #fff3cd;\n    border: 1px solid #ffeaa7;\n    border-radius: 6px;\n    padding: 1rem;\n    margin-bottom: 1rem;\n    font-size: 0.9rem;\n    color: var(--neutral-gray-800);\n    font-weight: 500;\n}\n\n.recommendation-bullets {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n}\n\n.recommendation-bullet {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-700);\n    line-height: 1.4;\n}\n\n/* Action Plan Section */\n.action-plan-section {\n    padding: 1.5rem;\n    background: var(--neutral-gray-50);\n    border-top: 1px solid var(--neutral-gray-100);\n}\n\n.action-plan-buttons {\n    display: flex;\n    gap: 0.75rem;\n    margin-top: 1rem;\n}\n\n.action-plan-buttons .btn {\n    flex: 1;\n    min-width: 120px;\n}\n\n.btn.btn-success {\n    background-color: var(--healthy-green);\n    border-color: var(--healthy-green);\n    color: white;\n}\n\n.btn.btn-success:hover {\n    background-color: #218838;\n    border-color: #1e7e34;\n}\n\n.action-plan-header {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n}\n\n.action-plan-icon {\n    color: var(--domo-blue);\n    font-size: 0.9rem;\n}\n\n.action-plan-title {\n    font-size: 0.95rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.action-plan-content {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 4px;\n}\n\n.action-plan-description {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-600);\n    margin: 0;\n}\n\n.create-plan-btn {\n    font-size: 0.85rem;\n    padding: 0.5rem 1rem;\n}\n\n/* Portfolio Grid */\n.portfolio-overview {\n    margin-bottom: 2rem;\n}\n\n.overview-cards {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 1.5rem;\n    margin-bottom: 2rem;\n}\n\n.overview-card {\n    background: white;\n    padding: 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n    text-align: center;\n}\n\n.card-value {\n    font-size: 2rem;\n    font-weight: 700;\n    color: var(--domo-blue);\n    margin-bottom: 0.5rem;\n}\n\n.card-label {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-600);\n}\n\n.portfolio-filters {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 1.5rem;\n}\n\n.filter-buttons {\n    display: flex;\n    gap: 0.5rem;\n}\n\n.portfolio-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));\n    gap: 1.5rem;\n}\n\n.portfolio-card {\n    background: white;\n    border-radius: 8px;\n    padding: 1.5rem;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n    border-left: 4px solid var(--neutral-gray-300);\n}\n\n.portfolio-card.healthy {\n    border-left-color: var(--healthy-green);\n}\n\n.portfolio-card.warning {\n    border-left-color: var(--warning-orange);\n}\n\n.portfolio-card.critical {\n    border-left-color: var(--critical-red);\n}\n\n.portfolio-card.growth {\n    border-left-color: var(--domo-blue);\n}\n\n/* Actions List */\n.actions-overview {\n    margin-bottom: 2rem;\n}\n\n.actions-filters {\n    display: flex;\n    gap: 0.5rem;\n    margin-bottom: 1.5rem;\n}\n\n.actions-list {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n}\n\n/* Account-focused Action Plan Cards */\n.action-plan-card {\n    background: white;\n    border-radius: 12px;\n    padding: 1.5rem;\n    margin-bottom: 1.5rem;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    cursor: pointer;\n    transition: all 0.3s ease;\n    border-left: 4px solid #007dba;\n}\n\n.action-plan-card:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.action-plan-card.critical-urgency {\n    border-left-color: #dc3545;\n    background: linear-gradient(135deg, #fff 0%, #fff5f5 100%);\n}\n\n.action-plan-card.high-urgency {\n    border-left-color: #fd7e14;\n    background: linear-gradient(135deg, #fff 0%, #fff8f0 100%);\n}\n\n.action-plan-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    margin-bottom: 1.5rem;\n}\n\n.plan-account-name {\n    font-size: 1.3rem;\n    font-weight: 700;\n    color: #2c3e50;\n    margin-bottom: 0.5rem;\n}\n\n.plan-meta {\n    display: flex;\n    gap: 1rem;\n    font-size: 0.85rem;\n    color: #666;\n    flex-wrap: wrap;\n}\n\n.plan-meta span {\n    padding: 0.2rem 0.6rem;\n    background: #f8f9fa;\n    border-radius: 12px;\n    font-weight: 500;\n}\n\n.account-health.health-critical {\n    background: #fee;\n    color: #dc3545;\n}\n\n.account-health.health-warning {\n    background: #fff8e1;\n    color: #f57c00;\n}\n\n.account-health.health-healthy {\n    background: #e8f5e8;\n    color: #28a745;\n}\n\n.plan-status-section {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-end;\n    gap: 0.5rem;\n}\n\n.plan-status {\n    padding: 0.4rem 0.8rem;\n    border-radius: 6px;\n    font-size: 0.85rem;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.plan-status.status-new {\n    background: #e3f2fd;\n    color: #1976d2;\n}\n\n.plan-status.status-in-progress {\n    background: #fff3e0;\n    color: #f57c00;\n}\n\n.plan-status.status-review-needed {\n    background: #fce4ec;\n    color: #c2185b;\n}\n\n.urgency-badge {\n    padding: 0.3rem 0.6rem;\n    border-radius: 4px;\n    font-size: 0.75rem;\n    font-weight: 700;\n    text-transform: uppercase;\n}\n\n.urgency-badge.critical {\n    background: #dc3545;\n    color: white;\n}\n\n.urgency-badge.high {\n    background: #fd7e14;\n    color: white;\n}\n\n.action-plan-progress {\n    margin-bottom: 1.5rem;\n    padding: 1rem;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.progress-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 0.5rem;\n}\n\n.progress-label {\n    font-weight: 600;\n    color: #495057;\n}\n\n.progress-percentage {\n    font-weight: 700;\n    color: #007dba;\n}\n\n.progress-bar {\n    height: 8px;\n    background: #e9ecef;\n    border-radius: 4px;\n    overflow: hidden;\n    margin-bottom: 0.5rem;\n}\n\n.progress-fill {\n    height: 100%;\n    background: linear-gradient(90deg, #007dba 0%, #0056b3 100%);\n    transition: width 0.3s ease;\n}\n\n.progress-details {\n    display: flex;\n    justify-content: space-between;\n    font-size: 0.85rem;\n    color: #6c757d;\n}\n\n.action-plan-impact {\n    margin-bottom: 1.5rem;\n}\n\n.impact-metrics {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 1rem;\n    text-align: center;\n}\n\n.impact-item {\n    padding: 0.8rem;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #e9ecef;\n}\n\n.impact-value {\n    font-size: 1.1rem;\n    font-weight: 700;\n    color: #28a745;\n    margin-bottom: 0.3rem;\n}\n\n.impact-label {\n    font-size: 0.8rem;\n    color: #6c757d;\n    font-weight: 500;\n}\n\n.action-plan-footer {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 1rem;\n    border-top: 1px solid #e9ecef;\n}\n\n.plan-timestamp {\n    font-size: 0.85rem;\n    color: #6c757d;\n}\n\n.plan-actions {\n    display: flex;\n    gap: 0.5rem;\n}\n\n.plan-actions .btn {\n    padding: 0.4rem 0.8rem;\n    font-size: 0.85rem;\n}\n\n/* Empty State */\n.empty-state {\n    text-align: center;\n    padding: 4rem 2rem;\n    color: #6c757d;\n}\n\n.empty-state-icon {\n    font-size: 4rem;\n    color: #dee2e6;\n    margin-bottom: 1.5rem;\n}\n\n.empty-state-title {\n    font-size: 1.5rem;\n    font-weight: 600;\n    color: #495057;\n    margin-bottom: 1rem;\n}\n\n.empty-state-description {\n    max-width: 500px;\n    margin: 0 auto 2rem;\n    line-height: 1.6;\n}\n\n.empty-state-actions {\n    display: flex;\n    gap: 1rem;\n    justify-content: center;\n}\n\n/* Legacy action card styles for compatibility */\n.action-card {\n    background: white;\n    border-radius: 8px;\n    padding: 1.5rem;\n    margin-bottom: 1rem;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    cursor: pointer;\n    transition: transform 0.2s, box-shadow 0.2s;\n}\n\n.action-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);\n}\n\n.action-card.urgent {\n    border-left: 4px solid #dc3545;\n}\n\n.action-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    margin-bottom: 1rem;\n}\n\n.action-title {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #333;\n    margin-bottom: 0.5rem;\n}\n\n.action-meta {\n    display: flex;\n    gap: 1rem;\n    font-size: 0.9rem;\n    color: #666;\n}\n\n.action-badges {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n}\n\n.status-badge {\n    padding: 0.25rem 0.5rem;\n    border-radius: 4px;\n    font-size: 0.8rem;\n    font-weight: 500;\n}\n\n.status-pending {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-in-progress {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-completed {\n    background: #d4edda;\n    color: #155724;\n}\n\n.action-description {\n    color: #666;\n    margin-bottom: 1rem;\n    line-height: 1.5;\n}\n\n.action-metrics {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 1rem;\n    padding-top: 1rem;\n    border-top: 1px solid #eee;\n}\n\n.metric-item {\n    text-align: center;\n}\n\n.metric-value {\n    font-weight: 600;\n    color: #28a745;\n    margin-bottom: 0.25rem;\n}\n\n.metric-label {\n    font-size: 0.8rem;\n    color: #666;\n}\n\n/* Drawer Styles */\n.drawer-backdrop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.5);\n    z-index: 9998;\n    opacity: 0;\n    visibility: hidden;\n    transition: opacity 0.3s ease, visibility 0.3s ease;\n}\n\n.drawer-backdrop.open {\n    opacity: 1;\n    visibility: visible;\n}\n\n.drawer {\n    position: fixed;\n    top: 0;\n    right: -600px;\n    width: 600px;\n    height: 100%;\n    background: white;\n    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);\n    z-index: 9999;\n    transition: right 0.3s ease;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.drawer.open {\n    right: 0;\n}\n\n.drawer-content {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.drawer-header {\n    padding: 2rem;\n    border-bottom: 2px solid var(--neutral-gray-200);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: linear-gradient(135deg, var(--neutral-white), var(--neutral-gray-50));\n}\n\n.drawer-header h2 {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: var(--neutral-gray-800);\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    letter-spacing: -0.02em;\n}\n\n.drawer-close {\n    background: none;\n    border: none;\n    font-size: 1.25rem;\n    color: var(--neutral-gray-600);\n    cursor: pointer;\n    padding: 0.5rem;\n    border-radius: 4px;\n}\n\n.drawer-close:hover {\n    background: var(--neutral-gray-200);\n}\n\n.drawer-body {\n    flex: 1;\n    padding: 2rem;\n    overflow-y: auto;\n}\n\n.drawer-footer {\n    padding: 2rem;\n    border-top: 2px solid var(--neutral-gray-200);\n    display: flex;\n    gap: 1rem;\n    justify-content: flex-end;\n    background: var(--neutral-gray-50);\n}\n\n/* Plan Sections */\n.plan-section {\n    margin-bottom: 2rem;\n}\n\n/* Current Signal Card */\n.current-signal-card {\n    background: var(--domo-blue-light);\n    border: 1px solid var(--domo-blue);\n    border-radius: 8px;\n    padding: 1rem;\n    margin-bottom: 1rem;\n}\n\n.current-signal-card .signal-title {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin-bottom: 0.5rem;\n}\n\n.current-signal-card .signal-meta {\n    display: flex;\n    gap: 0.5rem;\n    margin-bottom: 0.75rem;\n}\n\n.current-signal-card .signal-summary {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-700);\n    line-height: 1.4;\n}\n\n/* Other Signals List */\n.other-signals-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n}\n\n.other-signal-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.75rem;\n    background: var(--neutral-gray-50);\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.other-signal-item:hover {\n    background: var(--neutral-gray-100);\n    border-color: var(--domo-blue);\n}\n\n.other-signal-item .signal-name {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-800);\n    flex: 1;\n}\n\n.more-signals-indicator {\n    padding: 0.5rem;\n    text-align: center;\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n    font-style: italic;\n    background: var(--neutral-gray-50);\n    border-radius: 4px;\n}\n\n.plan-section h3 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin-top: 2rem;\n    margin-bottom: 1rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.plan-section:first-child h3 {\n    margin-top: 0;\n}\n\n.recommendations-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.recommendation-item {\n    padding: 1rem;\n    background: var(--domo-blue-light);\n    border-radius: 6px;\n    border-left: 3px solid var(--domo-blue);\n    font-size: 0.9rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.add-action-btn,\n.add-recommendation-btn {\n    padding: 0.25rem 0.75rem;\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    border-radius: 4px;\n    font-size: 0.8rem;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.add-action-btn:disabled,\n.add-recommendation-btn:disabled {\n    background: var(--healthy-green);\n    cursor: not-allowed;\n    opacity: 0.9;\n}\n\n/* New Recommendations with Plays Structure */\n.recommendations-description {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-600);\n    margin-bottom: 1.5rem;\n    padding: 0.75rem;\n    background: var(--neutral-gray-50);\n    border-radius: 6px;\n    border-left: 3px solid var(--domo-blue);\n}\n\n.recommendations-with-plays {\n    display: flex;\n    flex-direction: column;\n    gap: 1.5rem;\n}\n\n.recommendation-with-plays {\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 8px;\n    background: white;\n    overflow: hidden;\n}\n\n.recommendation-header {\n    padding: 1rem;\n    background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%);\n    border-bottom: 1px solid var(--domo-blue-light);\n    border-left: 3px solid var(--domo-blue);\n}\n\n.recommendation-content {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    flex: 1;\n}\n\n.recommendation-checkbox {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n    flex-shrink: 0;\n}\n\n.add-recommendations-section {\n    margin-top: 2rem;\n    padding: 1.5rem;\n    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);\n    border-radius: 8px;\n    border: 2px dashed var(--domo-blue);\n    text-align: center;\n}\n\n.add-all-recommendations-btn {\n    padding: 0.75rem 2rem;\n    font-size: 1rem;\n    font-weight: 600;\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    border-radius: 6px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 4px rgba(0, 125, 186, 0.2);\n}\n\n.add-all-recommendations-btn:hover {\n    background: var(--domo-blue-dark);\n    transform: translateY(-1px);\n    box-shadow: 0 4px 8px rgba(0, 125, 186, 0.3);\n}\n\n.add-all-recommendations-btn:active {\n    transform: translateY(0);\n}\n\n.recommendation-content {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    min-width: 0;\n    align-items: flex-start;\n}\n\n.recommendation-text {\n    font-size: 0.95rem;\n    font-weight: bold;\n    color: var(--neutral-gray-800);\n    line-height: 1.4;\n    word-wrap: break-word;\n}\n\n.recommendation-rationale {\n    font-size: 0.85rem;\n    font-style: italic;\n    color: var(--neutral-gray-600);\n    line-height: 1.3;\n    word-wrap: break-word;\n    position: relative;\n}\n\n/* Polarity Bubbles for AI Recommendations */\n.polarity-bubbles {\n    position: absolute;\n    top: 8px;\n    right: 8px;\n    display: flex;\n    gap: 4px;\n}\n\n.polarity-bubble {\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 11px;\n    font-weight: 700;\n    color: white;\n}\n\n.polarity-bubble-risk {\n    background-color: #e53e3e;\n}\n\n.polarity-bubble-opportunities {\n    background-color: #38a169;\n}\n\n.polarity-bubble-enrichment {\n    background-color: #718096;\n}\n\n.plays-section {\n    padding: 1rem;\n}\n\n.recommendation-footer {\n    padding: 1rem;\n    padding-top: 0;\n    display: flex;\n    justify-content: flex-end;\n}\n\n.play-option {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.75rem;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    background: white;\n    transition: all 0.3s ease;\n    cursor: pointer;\n}\n\n.play-option:hover {\n    border-color: var(--domo-blue);\n    background: var(--neutral-gray-50);\n}\n\n.play-option.play-selected {\n    background: rgba(0, 125, 186, 0.1);\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 2px rgba(0, 125, 186, 0.2);\n}\n\n.play-checkbox {\n    width: 16px;\n    height: 16px;\n    cursor: pointer;\n}\n\n.play-label {\n    display: block;\n    flex: 1;\n    cursor: pointer;\n}\n\n.plays-header {\n    margin-bottom: 1rem;\n}\n\n.plays-label {\n    font-size: 0.85rem;\n    font-weight: 600;\n    color: var(--neutral-gray-700);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.plays-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n    gap: 1rem;\n}\n\n.play-option {\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    overflow: hidden;\n    transition: all 0.2s ease;\n}\n\n.play-option:hover {\n    border-color: var(--domo-blue);\n    box-shadow: 0 2px 4px rgba(0, 125, 186, 0.1);\n}\n\n.play-checkbox {\n    display: none;\n}\n\n.play-checkbox:checked+.play-content {\n    background: var(--domo-blue-light);\n    border-color: var(--domo-blue);\n}\n\n.play-content {\n    display: block;\n    padding: 1rem;\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.play-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 8px;\n}\n\n.play-title {\n    font-size: 0.9rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin-bottom: 0.5rem;\n}\n\n.play-description {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-600);\n    line-height: 1.4;\n    margin-bottom: 0.75rem;\n}\n\n.play-priority-badge {\n    padding: 0.25rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.play-priority-badge.high {\n    background: rgba(220, 53, 69, 0.1);\n    color: var(--critical-red);\n}\n\n.play-priority-badge.medium {\n    background: rgba(255, 193, 7, 0.1);\n    color: var(--warning-orange);\n}\n\n.play-priority-badge.low {\n    background: rgba(40, 167, 69, 0.1);\n    color: var(--healthy-green);\n}\n\n.play-description {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-600);\n    line-height: 1.4;\n    margin-bottom: 8px;\n    text-align: left;\n}\n\n.play-owner {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-size: 0.75rem;\n}\n\n.play-owner-label {\n    font-weight: 500;\n    color: var(--neutral-gray-600);\n}\n\n.play-owner-value {\n    color: var(--domo-blue);\n    font-weight: 500;\n}\n\n/* Drawer play item styles */\n.drawer-play-item {\n    display: flex;\n    align-items: flex-start;\n    gap: 0.75rem;\n    padding: 1rem;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    background: white;\n    margin-bottom: 0.75rem;\n    transition: all 0.3s ease;\n}\n\n.drawer-play-item:hover {\n    border-color: var(--domo-blue);\n    background: var(--neutral-gray-50);\n}\n\n.drawer-play-item input[type=\"checkbox\"] {\n    margin-top: 0.25rem;\n    width: 16px;\n    height: 16px;\n    cursor: pointer;\n}\n\n.drawer-play-label {\n    display: block;\n    flex: 1;\n    cursor: pointer;\n}\n\n.no-plays {\n    padding: 1rem;\n    text-align: center;\n    color: var(--neutral-gray-500);\n    font-style: italic;\n    background: var(--neutral-gray-50);\n    border-radius: 6px;\n}\n\n/* Toolbox Plays Styling - Card-based design */\n.toolbox-play-item {\n    display: flex;\n    gap: 1rem;\n    padding: 1.25rem;\n    margin-bottom: 1rem;\n    border: 2px solid #e1e5e9;\n    border-radius: 8px;\n    background: white;\n    transition: all 0.2s ease;\n}\n\n.toolbox-play-item:hover {\n    border-color: #007DBA;\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.1);\n}\n\n.play-checkbox-section {\n    display: flex;\n    align-items: flex-start;\n    padding-top: 0.25rem;\n}\n\n.toolbox-play-checkbox {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n    accent-color: #007DBA;\n}\n\n.play-content-section {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.toolbox-play-title {\n    font-size: 1rem;\n    font-weight: 600;\n    color: #2c3e50;\n    margin: 0;\n    line-height: 1.4;\n}\n\n.toolbox-play-title.completed {\n    text-decoration: line-through;\n    color: #6c757d;\n}\n\n.toolbox-play-description {\n    font-size: 0.875rem;\n    color: #555;\n    line-height: 1.5;\n    margin: 0;\n}\n\n.play-owner-section {\n    margin-top: 0.5rem;\n}\n\n.play-owner-label {\n    font-size: 0.875rem;\n    color: #6c757d;\n    font-weight: 500;\n}\n\n.play-owner-name {\n    color: #007DBA;\n    font-weight: 600;\n}\n\n.play-actions-section {\n    display: flex;\n    justify-content: flex-end;\n    margin-top: 0.75rem;\n}\n\n.play-delete-btn {\n    background: #dc3545;\n    color: white;\n    border: none;\n    padding: 0.375rem 0.75rem;\n    border-radius: 4px;\n    font-size: 0.75rem;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n}\n\n.play-delete-btn:hover {\n    background: #c82333;\n    transform: translateY(-1px);\n}\n\n.toolbox-plays {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n}\n\n.toolbox-play {\n    padding: 1rem;\n    background: white;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 6px;\n}\n\n.play-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 0.5rem;\n}\n\n.play-title {\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n}\n\n.play-badge {\n    padding: 0.25rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.play-badge.high {\n    background: rgba(220, 53, 69, 0.1);\n    color: var(--critical-red);\n}\n\n.play-description {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n    margin-bottom: 0.5rem;\n}\n\n.play-time {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-500);\n}\n\n.action-items {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n    margin-bottom: 1rem;\n}\n\n.action-item {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 0.75rem;\n    padding: 0.75rem;\n    background: var(--neutral-gray-50);\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n}\n\n.action-item.nested-action {\n    flex-direction: column;\n    align-items: stretch;\n    gap: 0.5rem;\n}\n\n.action-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 0.75rem;\n}\n\n.action-text {\n    flex: 1;\n    font-size: 0.9rem;\n    color: var(--neutral-gray-800);\n    line-height: 1.4;\n}\n\n.action-plays {\n    margin-left: 1rem;\n    padding: 0.5rem 0;\n    border-top: 1px solid var(--neutral-gray-300);\n}\n\n.plays-label {\n    font-size: 0.8rem;\n    font-weight: 500;\n    color: var(--neutral-gray-600);\n    margin-bottom: 0.25rem;\n}\n\n.play-item {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-700);\n    margin-bottom: 0.2rem;\n    padding-left: 0.5rem;\n}\n\n.btn-remove {\n    padding: 0.375rem 0.75rem;\n    font-size: 0.8rem;\n    min-width: auto;\n    background: var(--critical-red);\n    color: white;\n    border: 1px solid var(--critical-red);\n    border-radius: 4px;\n    transition: all 0.2s ease;\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n}\n\n.btn-remove:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-1px);\n    box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);\n}\n\n.btn-remove i {\n    font-size: 0.75rem;\n}\n\n.plan-notes {\n    width: 100%;\n    min-height: 120px;\n    padding: 1rem;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 6px;\n    font-size: 0.9rem;\n    resize: vertical;\n}\n\n.plan-notes:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 3px rgba(0, 125, 186, 0.1);\n}\n\n/* Loading Overlay */\n.loading-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, 0.9);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n}\n\n.loading-spinner {\n    text-align: center;\n    color: var(--domo-blue);\n}\n\n.loading-spinner i {\n    font-size: 3rem;\n    margin-bottom: 1rem;\n}\n\n.loading-spinner p {\n    font-size: 1.1rem;\n    font-weight: 500;\n}\n\n/* Plan Status Indicators */\n.btn.plan-exists {\n    background: var(--warning-orange);\n    border: 2px solid var(--warning-orange);\n    position: relative;\n}\n\n.btn.plan-exists:hover {\n    background: #e56b00;\n}\n\n.btn.plan-exists::after {\n    content: \"●\";\n    position: absolute;\n    top: -5px;\n    right: -5px;\n    background: var(--healthy-green);\n    color: white;\n    border-radius: 50%;\n    width: 12px;\n    height: 12px;\n    font-size: 8px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border: 2px solid white;\n}\n\n/* Success Notification */\n.success-notification {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    background: var(--healthy-green);\n    color: white;\n    padding: 1rem 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    z-index: 2001;\n    transform: translateX(100%);\n    transition: transform 0.3s ease;\n}\n\n.success-notification.show {\n    transform: translateX(0);\n}\n\n/* Error Notification */\n.error-notification {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    background: var(--critical-red);\n    color: white;\n    padding: 1rem 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    z-index: 2001;\n    transform: translateX(100%);\n    transition: transform 0.3s ease;\n}\n\n.error-notification.show {\n    transform: translateX(0);\n}\n\n.notification-content {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    font-weight: 500;\n}\n\n/* Water Explosion Animation */\n@keyframes waterExplode {\n    0% {\n        transform: scale(1) rotate(0deg);\n        opacity: 1;\n        filter: blur(0px);\n    }\n\n    25% {\n        transform: scale(1.3) rotate(90deg);\n        opacity: 0.8;\n        filter: blur(1px);\n        box-shadow:\n            0 0 20px rgba(0, 125, 186, 0.6),\n            0 0 40px rgba(0, 125, 186, 0.4),\n            0 0 60px rgba(0, 125, 186, 0.2);\n    }\n\n    50% {\n        transform: scale(1.8) rotate(180deg);\n        opacity: 0.6;\n        filter: blur(3px);\n        box-shadow:\n            0 0 30px rgba(0, 125, 186, 0.8),\n            0 0 60px rgba(0, 125, 186, 0.6),\n            0 0 90px rgba(0, 125, 186, 0.4);\n    }\n\n    75% {\n        transform: scale(2.5) rotate(270deg);\n        opacity: 0.3;\n        filter: blur(5px);\n        box-shadow:\n            0 0 40px rgba(0, 125, 186, 1),\n            0 0 80px rgba(0, 125, 186, 0.8),\n            0 0 120px rgba(0, 125, 186, 0.6);\n    }\n\n    100% {\n        transform: scale(3.5) rotate(360deg);\n        opacity: 0;\n        filter: blur(8px);\n        box-shadow:\n            0 0 60px rgba(0, 125, 186, 0.4),\n            0 0 120px rgba(0, 125, 186, 0.2),\n            0 0 180px rgba(0, 125, 186, 0.1);\n    }\n}\n\n@keyframes waterDroplets {\n    0% {\n        opacity: 1;\n        transform: translateY(0) scale(1);\n    }\n\n    100% {\n        opacity: 0;\n        transform: translateY(-50px) scale(0.3);\n    }\n}\n\n.water-explosion {\n    position: relative;\n    overflow: visible;\n}\n\n.water-explosion::before {\n    content: '💧';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 1.5rem;\n    animation: waterExplode 0.6s ease-out forwards;\n    pointer-events: none;\n    z-index: 1000;\n}\n\n.water-explosion::after {\n    content: '💦💧💦💧💦';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 0.8rem;\n    animation: waterDroplets 0.8s ease-out 0.2s forwards;\n    pointer-events: none;\n    z-index: 999;\n    letter-spacing: 10px;\n}\n\n.signal-card.exploding {\n    animation: fadeOut 0.8s ease-out forwards;\n}\n\n@keyframes fadeOut {\n    0% {\n        opacity: 1;\n        transform: scale(1);\n    }\n\n    50% {\n        opacity: 0.7;\n        transform: scale(1.02);\n    }\n\n    100% {\n        opacity: 0;\n        transform: scale(0.95);\n    }\n}\n\n/* Event Source Card Styles */\n.event-source-card {\n    background: var(--neutral-gray-50);\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 8px;\n    padding: 1rem;\n    margin-bottom: 0.5rem;\n}\n\n.event-source-header {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    margin-bottom: 0.5rem;\n}\n\n.event-source-header i {\n    font-size: 1.25rem;\n    color: var(--domo-blue);\n    width: 20px;\n    text-align: center;\n}\n\n.event-source-info {\n    flex: 1;\n}\n\n.event-source-type {\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    font-size: 0.9rem;\n}\n\n.event-source-date {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-600);\n}\n\n.event-source-title {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-700);\n    margin-bottom: 0.75rem;\n    line-height: 1.4;\n}\n\n.event-source-link {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n    color: var(--domo-blue);\n    text-decoration: none;\n    font-size: 0.85rem;\n    font-weight: 500;\n    padding: 0.5rem 0.75rem;\n    border: 1px solid var(--domo-blue-light);\n    border-radius: 6px;\n    background: rgba(0, 125, 186, 0.05);\n    transition: all 0.2s ease;\n}\n\n.event-source-link:hover {\n    background: rgba(0, 125, 186, 0.1);\n    border-color: var(--domo-blue);\n    text-decoration: none;\n}\n\n.event-source-link i {\n    font-size: 0.75rem;\n}\n\n/* Feedback Indicator Styles */\n.feedback-indicator {\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    border: 1px solid;\n}\n\n.liked-indicator {\n    background: rgba(40, 167, 69, 0.1);\n    border-color: var(--healthy-green);\n}\n\n.not-accurate-indicator {\n    background: rgba(220, 53, 69, 0.1);\n    border-color: var(--critical-red);\n}\n\n.signal-liked {\n    transition: all 0.3s ease;\n}\n\n.signal-not-accurate {\n    transition: all 0.3s ease;\n}\n\n/* LinkedIn-Style Comment Styles */\n.linkedin-comments-section {\n    margin-top: 1rem;\n    background: var(--neutral-white);\n    border-radius: 8px;\n    padding: 1rem;\n    border: 1px solid var(--neutral-gray-200);\n}\n\n/* Account Comments Section Styling */\n.account-comments-section {\n    margin-top: 1rem;\n    background: var(--neutral-white);\n    border-radius: 8px;\n    padding: 1rem;\n    border: 1px solid var(--neutral-gray-200);\n}\n\n/* Comment Input Styling */\n.account-comment-input {\n    width: 100%;\n    min-height: 40px;\n    padding: 0.75rem;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 8px;\n    font-size: 0.9rem;\n    line-height: 1.4;\n    resize: vertical;\n    font-family: inherit;\n    background: white;\n    box-sizing: border-box;\n}\n\n.account-comment-input:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 2px rgba(0, 125, 186, 0.1);\n}\n\n.account-comment-input::placeholder {\n    color: var(--neutral-gray-500);\n    font-style: normal;\n}\n\n/* Add Comment Section Container */\n.add-comment-section {\n    display: flex;\n    align-items: flex-start;\n    gap: 0.5rem;\n    margin-top: 0.75rem;\n}\n\n/* Add Comment Button - Target the actual classes used */\n.add-comment-section .btn.btn-primary {\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    padding: 0.5rem 1rem;\n    border-radius: 6px;\n    font-size: 0.85rem;\n    font-weight: 500;\n    cursor: pointer;\n    transition: background 0.2s ease;\n    white-space: nowrap;\n    flex-shrink: 0;\n}\n\n.add-comment-section .btn.btn-primary:hover {\n    background: var(--domo-blue-dark);\n}\n\n.add-comment-section .btn.btn-primary:disabled {\n    background: var(--neutral-gray-300);\n    cursor: not-allowed;\n}\n\n.comments-header {\n    margin-bottom: 0.75rem;\n    padding-bottom: 0.5rem;\n    border-bottom: 1px solid var(--neutral-gray-100);\n}\n\n.comments-count {\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n    font-weight: 500;\n}\n\n.comments-list-linkedin {\n    margin-bottom: 0.75rem;\n}\n\n.comment-linkedin {\n    display: flex;\n    align-items: flex-start;\n    margin-bottom: 1rem;\n    padding: 0;\n}\n\n.comment-avatar {\n    margin-right: 0.75rem;\n    flex-shrink: 0;\n}\n\n.avatar-initials {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    background-color: var(--domo-blue);\n    color: white;\n    font-size: 0.75rem;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.comment-content {\n    flex: 1;\n    line-height: 1.4;\n}\n\n.comment-header {\n    display: flex;\n    align-items: baseline;\n    gap: 0.5rem;\n    margin-bottom: 0.25rem;\n}\n\n.comment-author {\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    font-size: 0.85rem;\n}\n\n.comment-time {\n    color: var(--neutral-gray-500);\n    font-size: 0.75rem;\n    font-weight: 400;\n}\n\n.comment-text {\n    color: var(--neutral-gray-700);\n    font-size: 0.85rem;\n    word-wrap: break-word;\n    line-height: 1.4;\n    margin-bottom: 0.5rem;\n}\n\n.comment-actions {\n    display: flex;\n    gap: 0.5rem;\n    opacity: 0;\n    transition: opacity 0.2s ease;\n}\n\n.comment-linkedin:hover .comment-actions {\n    opacity: 1;\n}\n\n.comment-action-btn {\n    background: none;\n    border: none;\n    color: var(--neutral-gray-500);\n    font-size: 0.75rem;\n    cursor: pointer;\n    padding: 0.25rem 0.5rem;\n    border-radius: 4px;\n    transition: all 0.2s ease;\n}\n\n.comment-action-btn:hover {\n    background: var(--neutral-gray-100);\n    color: var(--neutral-gray-700);\n}\n\n.comment-action-btn.delete-btn:hover {\n    background: #fee2e2;\n    color: #dc2626;\n}\n\n.edit-comment-form {\n    margin-top: 0.5rem;\n}\n\n.edit-comment-input {\n    width: 100%;\n    min-height: 60px;\n    padding: 0.5rem;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 6px;\n    font-size: 0.85rem;\n    font-family: inherit;\n    resize: vertical;\n    margin-bottom: 0.5rem;\n}\n\n.edit-comment-input:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 2px rgba(0, 125, 186, 0.1);\n}\n\n.edit-comment-actions {\n    display: flex;\n    gap: 0.5rem;\n}\n\n.btn-sm {\n    padding: 0.375rem 0.75rem;\n    font-size: 0.8rem;\n}\n\n.add-comment-linkedin {\n    display: flex;\n    align-items: flex-start;\n    padding-top: 0.75rem;\n    border-top: 1px solid var(--neutral-gray-100);\n    gap: 0.75rem;\n}\n\n.comment-input-container {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.comment-input-linkedin {\n    flex: 1;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 20px;\n    padding: 0.5rem 1rem;\n    font-size: 0.85rem;\n    color: var(--neutral-gray-700);\n    background: var(--neutral-gray-50);\n    font-family: inherit;\n    outline: none;\n    transition: all 0.2s ease;\n}\n\n.comment-input-linkedin::placeholder {\n    color: var(--neutral-gray-500);\n    font-size: 0.85rem;\n}\n\n.comment-input-linkedin:focus {\n    border-color: var(--domo-blue);\n    background: white;\n    box-shadow: 0 0 0 2px rgba(0, 125, 186, 0.1);\n}\n\n.comment-submit-btn {\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    border-radius: 16px;\n    padding: 0.4rem 1rem;\n    font-size: 0.8rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    min-width: 70px;\n}\n\n.comment-submit-btn:hover {\n    background: var(--domo-blue-dark);\n}\n\n/* Remove old comment button styles */\n.comment-count {\n    display: none;\n}\n\n/* Remove old inline comment styles */\n.inline-comments-section {\n    display: none;\n}\n\n/* Comment count indicator on buttons */\n.comment-count {\n    background: var(--domo-orange);\n    color: white;\n    padding: 0.125rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 700;\n    margin-left: 0.25rem;\n}\n\n/* Signal action buttons - colorful style */\n.signal-actions .btn {\n    padding: 0.5rem 1rem;\n    border-radius: 8px;\n    font-weight: 500;\n    font-size: 0.85rem;\n    border: 1px solid transparent;\n    transition: all 0.2s ease;\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n/* Like button - blue/yellow theme */\n.signal-actions .btn[data-action=\"like\"] {\n    background-color: #e8f4fd;\n    color: #1976d2;\n    border-color: #bbdefb;\n}\n\n.signal-actions .btn[data-action=\"like\"]:hover {\n    background-color: #bbdefb;\n    border-color: #90caf9;\n}\n\n.signal-actions .btn[data-action=\"like\"].liked-btn {\n    background-color: #ffd54f;\n    color: #f57f17;\n    border-color: #ffcc02;\n}\n\n.signal-actions .btn[data-action=\"like\"].liked-btn:hover {\n    background-color: #ffcc02;\n    border-color: #ffb300;\n}\n\n/* Not Accurate button - red/pink theme */\n.signal-actions .btn[data-action=\"not-accurate\"] {\n    background-color: #ffeaa7;\n    color: #e74c3c;\n    border-color: #fdcb6e;\n}\n\n.signal-actions .btn[data-action=\"not-accurate\"]:hover {\n    background-color: #fdcb6e;\n    border-color: #e17055;\n}\n\n.signal-actions .btn[data-action=\"not-accurate\"].not-accurate-btn {\n    background-color: #ffebee;\n    color: #d32f2f;\n    border-color: #ffcdd2;\n}\n\n.signal-actions .btn[data-action=\"not-accurate\"].not-accurate-btn:hover {\n    background-color: #ffcdd2;\n    border-color: #ef9a9a;\n}\n\n/* Action Plan button - green theme */\n.signal-actions .btn.action-btn,\n.signal-actions .btn[onclick*=\"createActionPlan\"] {\n    background-color: #e8f5e8;\n    color: #2e7d32;\n    border-color: #c8e6c9;\n}\n\n.signal-actions .btn.action-btn:hover,\n.signal-actions .btn[onclick*=\"createActionPlan\"]:hover {\n    background-color: #c8e6c9;\n    border-color: #a5d6a7;\n}\n\n/* View Plan button - blue theme */\n.signal-actions .btn[onclick*=\"viewActionDetails\"] {\n    background-color: #e3f2fd;\n    color: #1976d2;\n    border-color: #bbdefb;\n}\n\n.signal-actions .btn[onclick*=\"viewActionDetails\"]:hover {\n    background-color: #bbdefb;\n    border-color: #90caf9;\n}\n\n/* Comment Styles for drawer */\n.comments-section {\n    margin-top: 1.5rem;\n    padding-top: 1.5rem;\n    border-top: 1px solid var(--neutral-gray-200);\n}\n\n.comments-header {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n}\n\n.comments-header h3 {\n    font-size: 1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin: 0;\n}\n\n.comments-count {\n    background: var(--neutral-gray-200);\n    color: var(--neutral-gray-600);\n    padding: 0.125rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 600;\n}\n\n.comment-list {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n    margin-bottom: 1rem;\n}\n\n.add-comment-form {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.comment-input {\n    width: 100%;\n    min-height: 80px;\n    padding: 0.75rem;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 6px;\n    font-size: 0.9rem;\n    resize: vertical;\n    font-family: inherit;\n}\n\n.comment-input:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 3px rgba(0, 125, 186, 0.1);\n}\n\n.comment-input::placeholder {\n    color: var(--neutral-gray-500);\n}\n\n.comment-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 0.5rem;\n}\n\n.comment-btn {\n    padding: 0.5rem 1rem;\n    border: none;\n    border-radius: 6px;\n    font-size: 0.85rem;\n    font-weight: 500;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.comment-btn-primary {\n    background: var(--domo-blue);\n    color: white;\n}\n\n.comment-btn-primary:hover {\n    background: var(--domo-blue-dark);\n}\n\n.comment-btn-secondary {\n    background: var(--neutral-gray-200);\n    color: var(--neutral-gray-700);\n}\n\n.comment-btn-secondary:hover {\n    background: var(--neutral-gray-300);\n}\n\n.empty-comments {\n    text-align: center;\n    padding: 2rem;\n    color: var(--neutral-gray-500);\n    font-style: italic;\n}\n\n.comment-indicator {\n    background: var(--domo-blue-light);\n    color: var(--domo-blue);\n    padding: 0.125rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 600;\n    margin-left: 0.5rem;\n}\n\n/* Touch device optimizations */\n@media (pointer: coarse) {\n    .btn {\n        min-height: 44px;\n        min-width: 44px;\n    }\n\n    .signal-close-btn {\n        min-width: 44px;\n        min-height: 44px;\n    }\n\n    .nav-tab {\n        min-height: 48px;\n    }\n\n    .filter-btn {\n        min-height: 44px;\n    }\n}\n\n/* Social/Content Card styles */\n.content-card {\n    background: white;\n    border-radius: 12px;\n    padding: 1.5rem;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);\n    border: 1px solid var(--neutral-gray-200);\n    margin-bottom: 1rem;\n}\n\n.content-card-header {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    margin-bottom: 1rem;\n}\n\n.content-card-avatar {\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    background-color: var(--domo-blue);\n    color: white;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1rem;\n    font-weight: 600;\n    flex-shrink: 0;\n}\n\n.content-card-author-info {\n    flex: 1;\n}\n\n.content-card-author {\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    font-size: 0.95rem;\n    margin-bottom: 0.125rem;\n}\n\n.content-card-timestamp {\n    font-size: 0.8rem;\n    color: var(--neutral-gray-600);\n}\n\n.content-card-actions {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.content-card-like-btn,\n.content-card-comment-btn,\n.content-card-share-btn {\n    background: none;\n    border: none;\n    color: var(--neutral-gray-500);\n    font-size: 1rem;\n    cursor: pointer;\n    padding: 0.5rem;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.content-card-like-btn:hover,\n.content-card-comment-btn:hover,\n.content-card-share-btn:hover {\n    background: var(--neutral-gray-100);\n    color: var(--neutral-gray-700);\n}\n\n.content-card-like-btn.liked {\n    color: var(--domo-orange);\n}\n\n.content-card-body {\n    font-size: 0.9rem;\n    color: var(--neutral-gray-700);\n    line-height: 1.5;\n    margin-bottom: 1rem;\n}\n\n.content-card-image {\n    width: 100%;\n    border-radius: 8px;\n    margin-bottom: 1rem;\n}\n\n.content-card-footer {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    font-size: 0.85rem;\n    color: var(--neutral-gray-600);\n}\n\n.content-card-likes,\n.content-card-comments {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.content-card-comments-count {\n    font-weight: 600;\n}\n\n.content-card-comment-input-section {\n    margin-top: 1rem;\n    padding-top: 1rem;\n    border-top: 1px solid var(--neutral-gray-100);\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.content-card-comment-input {\n    flex: 1;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 20px;\n    padding: 0.5rem 1rem;\n    font-size: 0.85rem;\n    background: var(--neutral-gray-50);\n    font-family: inherit;\n    outline: none;\n}\n\n.content-card-comment-input::placeholder {\n    color: var(--neutral-gray-500);\n}\n\n.content-card-comment-submit {\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    border-radius: 16px;\n    padding: 0.4rem 1rem;\n    font-size: 0.8rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.content-card-comment-submit:hover {\n    background: var(--domo-blue-dark);\n}\n\n/* Plan selection modal and plan details form */\n.modal-backdrop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.5);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 1000;\n}\n\n.modal-dialog {\n    max-width: 600px;\n    width: 90%;\n    max-height: 80vh;\n    background: var(--background-primary);\n    border-radius: 12px;\n    overflow: hidden;\n    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);\n}\n\n.modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 20px;\n    border-bottom: 1px solid var(--border-color);\n    background: var(--background-secondary);\n}\n\n.modal-header h3 {\n    margin: 0;\n    color: var(--text-primary);\n    font-size: 18px;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 18px;\n    cursor: pointer;\n    color: var(--text-secondary);\n    padding: 4px;\n    border-radius: 4px;\n    transition: background-color 0.2s;\n}\n\n.modal-close:hover {\n    background: var(--background-hover);\n}\n\n.modal-body {\n    padding: 20px;\n    max-height: 60vh;\n    overflow-y: auto;\n}\n\n.plan-selection-list {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    margin-bottom: 20px;\n}\n\n.plan-selection-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 16px;\n    background: var(--background-secondary);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.plan-selection-item:hover {\n    background: var(--background-hover);\n    border-color: var(--primary-color);\n    transform: translateY(-1px);\n}\n\n.plan-info {\n    flex: 1;\n}\n\n.plan-title {\n    font-weight: 600;\n    color: var(--text-primary);\n    margin-bottom: 6px;\n}\n\n.plan-meta {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 12px;\n    font-size: 12px;\n    color: var(--text-secondary);\n    margin-bottom: 4px;\n}\n\n.plan-items {\n    font-size: 12px;\n    color: var(--text-secondary);\n}\n\n.status-badge {\n    padding: 2px 8px;\n    border-radius: 12px;\n    font-size: 11px;\n    font-weight: 500;\n    text-transform: uppercase;\n}\n\n.status-badge.status-pending {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-badge.status-in-progress {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-badge.status-completed {\n    background: #d1eddc;\n    color: #155724;\n}\n\n.modal-actions {\n    display: flex;\n    justify-content: center;\n    padding-top: 16px;\n    border-top: 1px solid var(--border-color);\n}\n\n/* Plan details form */\n.plan-details-grid {\n    display: grid;\n    gap: 16px;\n}\n\n.plan-field {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.plan-field label {\n    font-weight: 500;\n    color: var(--text-primary);\n    font-size: 14px;\n}\n\n.plan-title-input {\n    padding: 12px;\n    border: 1px solid var(--border-color);\n    border-radius: 6px;\n    background: var(--background-primary);\n    color: var(--text-primary);\n    font-size: 14px;\n    transition: border-color 0.2s;\n}\n\n.plan-title-input:focus {\n    outline: none;\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 3px rgba(0, 125, 186, 0.1);\n}\n\n/* Signals Pagination Styling */\n.signals-pagination {\n    display: flex;\n    gap: 8px;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 0;\n    border-top: 1px solid var(--neutral-gray-100);\n    margin-top: 8px;\n}\n\n.show-more-btn,\n.show-less-btn {\n    padding: 6px 12px;\n    font-size: 0.85rem;\n    border-radius: 4px;\n    border: 1px solid;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    background: transparent;\n}\n\n.show-more-btn {\n    color: var(--domo-blue);\n    border-color: var(--domo-blue);\n}\n\n.show-more-btn:hover {\n    background: var(--domo-blue);\n    color: white;\n}\n\n.show-less-btn {\n    color: var(--neutral-gray-600);\n    border-color: var(--neutral-gray-300);\n}\n\n.show-less-btn:hover {\n    background: var(--neutral-gray-100);\n    color: var(--neutral-gray-800);\n}\n\n/* Project Management Table Styles */\n.project-management-container {\n    background: white;\n    border-radius: 8px;\n    border: 1px solid var(--neutral-gray-200);\n    overflow: hidden;\n}\n\n.pm-table-header {\n    display: grid;\n    grid-template-columns: 50px 1fr 120px 80px 100px 80px;\n    background: var(--neutral-gray-50);\n    border-bottom: 1px solid var(--neutral-gray-200);\n    font-weight: 600;\n    font-size: 12px;\n    color: var(--neutral-gray-600);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.pm-header-cell {\n    padding: 12px 16px;\n    display: flex;\n    align-items: center;\n}\n\n.pm-header-cell.checkbox-col {\n    justify-content: center;\n    padding: 12px 8px;\n}\n\n/* Account Group Styles */\n.account-group {\n    border-bottom: 1px solid var(--neutral-gray-100);\n}\n\n.account-group-header {\n    background: var(--neutral-gray-25);\n    border-bottom: 1px solid var(--neutral-gray-200);\n    padding: 16px 20px;\n    cursor: pointer;\n    transition: background-color 0.2s;\n}\n\n.account-group-header:hover {\n    background: var(--neutral-gray-50);\n}\n\n.account-group-title {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n}\n\n.group-toggle {\n    color: var(--neutral-gray-500);\n    font-size: 12px;\n    cursor: pointer;\n    transition: transform 0.2s;\n}\n\n.account-name {\n    font-weight: 600;\n    font-size: 16px;\n    color: var(--neutral-gray-800);\n}\n\n.task-count {\n    font-size: 12px;\n    color: var(--neutral-gray-600);\n    background: var(--neutral-gray-100);\n    padding: 4px 8px;\n    border-radius: 12px;\n}\n\n.account-health {\n    padding: 4px 8px;\n    border-radius: 12px;\n    font-size: 11px;\n    font-weight: 500;\n}\n\n.account-health.health-healthy {\n    background: #dcfce7;\n    color: #166534;\n}\n\n.account-health.health-warning {\n    background: #fef3c7;\n    color: #92400e;\n}\n\n.account-health.health-critical {\n    background: #fee2e2;\n    color: #dc2626;\n}\n\n.renewal-value {\n    font-size: 12px;\n    color: var(--neutral-gray-600);\n    background: var(--domo-blue-light);\n    padding: 4px 8px;\n    border-radius: 12px;\n}\n\n/* Task Row Styles */\n.pm-table-row {\n    display: grid;\n    grid-template-columns: 50px 1fr 120px 80px 100px 80px;\n    border-bottom: 1px solid var(--neutral-gray-100);\n    transition: background-color 0.2s;\n    min-height: 56px;\n}\n\n.pm-table-row:hover {\n    background: var(--neutral-gray-25);\n}\n\n.pm-table-row.task-completed {\n    opacity: 0.6;\n}\n\n.pm-table-row.task-completed .action-plan-title {\n    text-decoration: line-through;\n    color: var(--neutral-gray-500);\n}\n\n.pm-table-row.task-completed .action-plan-description {\n    text-decoration: line-through;\n    opacity: 0.7;\n}\n\n/* Multi-Select and Right-Click Task Management */\n.pm-table-row.task-selected {\n    background-color: #e3f2fd !important;\n    border: 2px solid #2196f3;\n    box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);\n}\n\n.pm-table-row.task-selected:hover {\n    background-color: #e1f5fe !important;\n}\n\n/* Context Menu Styles */\n.task-context-menu {\n    position: absolute;\n    background: white;\n    border: 1px solid #e0e0e0;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    z-index: 10000;\n    min-width: 160px;\n    overflow: hidden;\n}\n\n.context-menu-item {\n    padding: 12px 16px;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    cursor: pointer;\n    transition: background-color 0.2s ease;\n    font-size: 14px;\n    color: #333;\n}\n\n.context-menu-item:hover {\n    background-color: #f5f5f5;\n}\n\n.context-menu-item i {\n    color: #dc3545;\n    width: 16px;\n    text-align: center;\n}\n\n/* Professional Delete Confirmation Modal */\n.delete-confirmation-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    z-index: 9999;\n    opacity: 0;\n    visibility: hidden;\n    transition: all 0.2s ease;\n}\n\n.delete-confirmation-modal.show {\n    opacity: 1;\n    visibility: visible;\n}\n\n.delete-modal-backdrop {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.5);\n    backdrop-filter: blur(2px);\n}\n\n.delete-modal-content {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%) scale(0.9);\n    background: white;\n    border-radius: 12px;\n    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);\n    max-width: 500px;\n    width: 90%;\n    max-height: 80vh;\n    overflow: hidden;\n    transition: transform 0.2s ease;\n}\n\n.delete-confirmation-modal.show .delete-modal-content {\n    transform: translate(-50%, -50%) scale(1);\n}\n\n.delete-modal-header {\n    padding: 24px 24px 16px 24px;\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    border-bottom: 1px solid #f0f0f0;\n}\n\n.delete-modal-icon {\n    width: 48px;\n    height: 48px;\n    border-radius: 50%;\n    background: #fff3cd;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: #856404;\n    font-size: 20px;\n}\n\n.delete-modal-title {\n    margin: 0;\n    font-size: 20px;\n    font-weight: 600;\n    color: #333;\n}\n\n.delete-modal-body {\n    padding: 24px;\n    color: #555;\n    line-height: 1.6;\n}\n\n.delete-modal-body p {\n    margin: 0 0 16px 0;\n}\n\n.delete-modal-body p:last-child {\n    margin-bottom: 0;\n}\n\n.delete-task-count {\n    font-weight: 600;\n    color: #dc3545;\n    background: #f8d7da;\n    padding: 8px 12px;\n    border-radius: 6px;\n    border-left: 4px solid #dc3545;\n}\n\n.delete-modal-footer {\n    padding: 16px 24px 24px 24px;\n    display: flex;\n    justify-content: flex-end;\n    gap: 12px;\n    border-top: 1px solid #f0f0f0;\n}\n\n.delete-cancel-btn {\n    padding: 10px 20px;\n    border: 1px solid #ddd;\n    background: white;\n    color: #666;\n    border-radius: 6px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n\n.delete-cancel-btn:hover {\n    background: #f8f9fa;\n    border-color: #bbb;\n}\n\n.delete-confirm-btn {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 1px solid #dc3545;\n    border-radius: 6px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-weight: 500;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.delete-confirm-btn:hover {\n    background: #c82333;\n    border-color: #bd2130;\n    transform: translateY(-1px);\n    box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);\n}\n\n.delete-confirm-btn i {\n    font-size: 14px;\n}\n\n.pm-cell {\n    padding: 12px 16px;\n    display: flex;\n    align-items: center;\n}\n\n.pm-cell.checkbox-col {\n    justify-content: center;\n    padding: 12px 8px;\n}\n\n/* Task Content */\n.task-content {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n}\n\n.task-title {\n    font-weight: 500;\n    color: var(--neutral-gray-800);\n    line-height: 1.4;\n}\n\n.task-description {\n    font-size: 12px;\n    color: var(--neutral-gray-600);\n    line-height: 1.3;\n}\n\n/* Due Date Styles */\n.due-date {\n    font-size: 13px;\n    color: var(--neutral-gray-700);\n    padding: 4px 8px;\n    border-radius: 4px;\n    background: var(--neutral-gray-50);\n}\n\n.due-date.overdue {\n    background: #fee2e2;\n    color: #dc2626;\n    font-weight: 500;\n}\n\n/* Plays Button */\n.plays-button {\n    background: none;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    padding: 6px 10px;\n    cursor: pointer;\n    transition: all 0.2s;\n    display: flex;\n    align-items: center;\n    gap: 4px;\n}\n\n.plays-button:hover {\n    background: var(--neutral-gray-50);\n    border-color: var(--domo-blue);\n}\n\n.plays-count {\n    font-weight: 600;\n    font-size: 13px;\n    color: var(--domo-blue);\n}\n\n.plays-label {\n    font-size: 11px;\n    color: var(--neutral-gray-600);\n}\n\n/* Priority Badges */\n.priority-badge {\n    padding: 4px 8px;\n    border-radius: 12px;\n    font-size: 11px;\n    font-weight: 500;\n    text-transform: uppercase;\n}\n\n.priority-badge.priority-high {\n    background: #fee2e2;\n    color: #dc2626;\n}\n\n.priority-badge.priority-medium {\n    background: #fef3c7;\n    color: #92400e;\n}\n\n.priority-badge.priority-low {\n    background: #dcfce7;\n    color: #166534;\n}\n\n/* Status Badges */\n.status-badge {\n    padding: 4px 8px;\n    border-radius: 12px;\n    font-size: 11px;\n    font-weight: 500;\n    text-transform: capitalize;\n}\n\n.status-badge.status-pending {\n    background: #f3f4f6;\n    color: #6b7280;\n}\n\n.status-badge.status-in-progress {\n    background: #dbeafe;\n    color: #1d4ed8;\n}\n\n.status-badge.status-complete {\n    background: #dcfce7;\n    color: #166534;\n}\n\n.status-badge.status-cancelled {\n    background: #fee2e2;\n    color: #dc2626;\n}\n\n.status-badge.status-on-hold {\n    background: #fef3c7;\n    color: #92400e;\n}\n\n/* Assignee Avatar */\n.assignee-avatar {\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    background: var(--domo-blue);\n    color: white;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 11px;\n    font-weight: 600;\n}\n\n.assignee-initials {\n    line-height: 1;\n}\n\n/* Checkboxes */\n.action-plan-checkbox {\n    width: 16px;\n    height: 16px;\n    border-radius: 3px;\n    border: 2px solid var(--neutral-gray-300);\n    cursor: pointer;\n    accent-color: var(--domo-blue);\n}\n\n/* Completed Task Styling */\n.action-plan-completed .action-plan-title {\n    text-decoration: line-through;\n    opacity: 0.6;\n}\n\n.action-plan-completed .action-plan-description {\n    text-decoration: line-through;\n    opacity: 0.6;\n}\n\n.action-plan-completed {\n    opacity: 0.8;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n\n    .pm-table-header,\n    .pm-table-row {\n        grid-template-columns: 40px 1fr 80px 60px 80px 60px;\n        font-size: 12px;\n    }\n\n    .pm-header-cell,\n    .pm-cell {\n        padding: 8px 12px;\n    }\n\n    .account-group-header {\n        padding: 12px 16px;\n    }\n\n    .account-name {\n        font-size: 14px;\n    }\n\n    .plan-drawer {\n        width: 100vw;\n        right: -100vw;\n    }\n\n    .action-controls {\n        flex-direction: column;\n        align-items: flex-end;\n        gap: 4px;\n    }\n\n    .btn-add-to-plan {\n        margin-left: 0;\n        font-size: 10px;\n        padding: 3px 6px;\n    }\n}\n\n/* Add to Plan Button */\n.btn-add-to-plan {\n    background: var(--domo-blue);\n    color: white;\n    border: none;\n    padding: 4px 8px;\n    border-radius: 4px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background-color 0.2s;\n    font-weight: 500;\n    margin-left: 8px;\n}\n\n.btn-add-to-plan:hover {\n    background: var(--domo-blue-dark);\n}\n\n/* Added Status Button */\n.btn-added-status {\n    background: #dcfce7;\n    color: #166534;\n    border: 1px solid #bbf7d0;\n    padding: 4px 8px;\n    border-radius: 4px;\n    font-size: 11px;\n    font-weight: 600;\n    margin-left: 8px;\n    display: inline-block;\n}\n\n.action-controls {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n/* Plan Drawer Styles */\n.plan-drawer {\n    position: fixed;\n    top: 0;\n    right: -400px;\n    width: 400px;\n    height: 100vh;\n    background: white;\n    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);\n    transition: right 0.3s ease;\n    z-index: 1001;\n    display: flex;\n    flex-direction: column;\n}\n\n.plan-drawer.open {\n    right: 0;\n}\n\n.plan-drawer-backdrop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.5);\n    z-index: 1000;\n    opacity: 0;\n    visibility: hidden;\n    transition: opacity 0.3s ease, visibility 0.3s ease;\n}\n\n.plan-drawer-backdrop.open {\n    opacity: 1;\n    visibility: visible;\n}\n\n.plan-drawer-content {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.plan-drawer-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 20px;\n    border-bottom: 1px solid var(--neutral-gray-200);\n    background: var(--neutral-gray-50);\n}\n\n.plan-drawer-header h2 {\n    margin: 0;\n    color: var(--neutral-gray-800);\n    font-size: 18px;\n    font-weight: 600;\n}\n\n.plan-drawer-close {\n    background: none;\n    border: none;\n    font-size: 18px;\n    cursor: pointer;\n    color: var(--neutral-gray-600);\n    padding: 5px;\n    border-radius: 4px;\n    transition: background-color 0.2s;\n}\n\n.plan-drawer-close:hover {\n    background: var(--neutral-gray-100);\n}\n\n.plan-drawer-body {\n    flex: 1;\n    padding: 20px;\n    overflow-y: auto;\n}\n\n.recommended-action-section,\n.toolbox-plays-section,\n.plan-details-section {\n    margin-bottom: 20px;\n}\n\n.recommended-action-section h3,\n.toolbox-plays-section h3,\n.plan-details-section h3 {\n    margin: 0 0 10px 0;\n    font-size: 14px;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n}\n\n.action-title-display {\n    background: var(--domo-blue-light);\n    padding: 12px;\n    border-radius: 4px;\n    margin: 0;\n    color: var(--neutral-gray-800);\n    font-size: 14px;\n    border-left: 3px solid var(--domo-blue);\n    font-weight: 500;\n}\n\n.drawer-plays-container {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n.drawer-play-item {\n    display: flex;\n    align-items: flex-start;\n    padding: 12px;\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    cursor: pointer;\n    transition: all 0.2s;\n    background: white;\n}\n\n.drawer-play-item:hover {\n    background: var(--neutral-gray-50);\n    border-color: var(--domo-blue);\n}\n\n.drawer-play-item input[type=\"checkbox\"] {\n    margin: 0 10px 0 0;\n    accent-color: var(--domo-blue);\n}\n\n.drawer-play-title {\n    font-size: 12px;\n    color: var(--neutral-gray-800);\n    line-height: 1.4;\n    font-weight: 500;\n}\n\n.no-plays-message {\n    text-align: center;\n    color: var(--neutral-gray-600);\n    font-style: italic;\n    padding: 20px;\n    margin: 0;\n}\n\n#drawerPlanDetails {\n    width: 100%;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 4px;\n    padding: 12px;\n    font-family: inherit;\n    font-size: 14px;\n    resize: vertical;\n    min-height: 100px;\n    box-sizing: border-box;\n}\n\n#drawerPlanDetails:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 2px rgba(0, 125, 186, 0.2);\n}\n\n.plan-drawer-footer {\n    padding: 20px;\n    border-top: 1px solid var(--neutral-gray-200);\n    background: var(--neutral-gray-50);\n}\n\n.plan-drawer-buttons {\n    display: flex;\n    justify-content: flex-end;\n    gap: 12px;\n}\n\n.plan-drawer-error {\n    background: #fef2f2;\n    border: 1px solid #fecaca;\n    color: #dc2626;\n    padding: 12px;\n    border-radius: 6px;\n    margin-bottom: 16px;\n    font-size: 14px;\n    line-height: 1.4;\n}\n\n/* Plays Drawer Styles */\n.plays-drawer {\n    width: 500px;\n    right: -500px;\n}\n\n.plays-drawer-section {\n    margin-bottom: 2rem;\n}\n\n.plays-drawer-section h3 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin-bottom: 1rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.plays-drawer-section h3 i {\n    color: var(--domo-blue);\n}\n\n.action-task-card {\n    background: var(--domo-blue-light);\n    border: 1px solid var(--domo-blue);\n    border-radius: 8px;\n    padding: 1rem;\n    margin-bottom: 0.5rem;\n}\n\n.action-task-title {\n    font-weight: 600;\n    color: var(--domo-blue-dark);\n    margin-bottom: 0.5rem;\n    line-height: 1.4;\n}\n\n.action-task-meta {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n}\n\n.action-id-badge {\n    background: var(--neutral-gray-200);\n    color: var(--neutral-gray-700);\n    padding: 0.25rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 500;\n    font-family: monospace;\n}\n\n.plays-description {\n    color: var(--neutral-gray-600);\n    margin-bottom: 1rem;\n    line-height: 1.5;\n}\n\n.plays-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.play-item {\n    display: flex;\n    align-items: flex-start;\n    gap: 1rem;\n    padding: 1rem;\n    background: var(--neutral-white);\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 8px;\n    transition: all 0.2s ease;\n}\n\n.play-item:hover {\n    border-color: var(--domo-blue);\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.1);\n}\n\n.play-checkbox-container {\n    flex-shrink: 0;\n    position: relative;\n}\n\n.play-completion-checkbox {\n    appearance: none;\n    width: 20px;\n    height: 20px;\n    border: 2px solid var(--neutral-gray-300);\n    border-radius: 4px;\n    background: var(--neutral-white);\n    cursor: pointer;\n    transition: all 0.2s ease;\n    margin: 0;\n}\n\n.play-completion-checkbox:checked {\n    background: var(--healthy-green);\n    border-color: var(--healthy-green);\n}\n\n.play-completion-label {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    pointer-events: none;\n}\n\n.play-completion-label i {\n    color: var(--neutral-white);\n    font-size: 0.75rem;\n    opacity: 0;\n    transition: opacity 0.2s ease;\n}\n\n.play-completion-checkbox:checked+.play-completion-label i {\n    opacity: 1;\n}\n\n.play-content {\n    flex: 1;\n    min-width: 0;\n}\n\n.play-title {\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin-bottom: 0.5rem;\n    line-height: 1.4;\n    transition: all 0.2s ease;\n}\n\n.play-title.completed {\n    text-decoration: line-through;\n    color: var(--neutral-gray-500);\n}\n\n.play-status {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.status-badge {\n    padding: 0.25rem 0.75rem;\n    border-radius: 12px;\n    font-size: 0.75rem;\n    font-weight: 600;\n    text-transform: uppercase;\n    letter-spacing: 0.02em;\n}\n\n.status-badge.pending {\n    background: var(--warning-orange);\n    color: var(--neutral-white);\n}\n\n.status-badge.completed {\n    background: var(--healthy-green);\n    color: var(--neutral-white);\n}\n\n.no-plays-message {\n    text-align: center;\n    padding: 2rem;\n    color: var(--neutral-gray-500);\n    background: var(--neutral-gray-50);\n    border-radius: 8px;\n    border: 1px dashed var(--neutral-gray-300);\n}\n\n.no-plays-message i {\n    font-size: 2rem;\n    margin-bottom: 1rem;\n    display: block;\n    opacity: 0.5;\n}\n\n/* Drawer close button update for plays drawer */\n.plays-drawer .drawer-close-btn {\n    background: none;\n    border: none;\n    font-size: 1.25rem;\n    color: var(--neutral-gray-600);\n    cursor: pointer;\n    padding: 0.5rem;\n    border-radius: 50%;\n    transition: all 0.2s ease;\n}\n\n.plays-drawer .drawer-close-btn:hover {\n    background: var(--neutral-gray-200);\n    color: var(--neutral-gray-800);\n}\n\n/* Update notification styles for play updates */\n.update-notification {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    padding: 1rem 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    z-index: 2001;\n    transform: translateX(100%);\n    transition: transform 0.3s ease;\n    font-weight: 500;\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    max-width: 400px;\n}\n\n.update-notification.success {\n    background: var(--healthy-green);\n    color: var(--neutral-white);\n}\n\n.update-notification.error {\n    background: var(--critical-red);\n    color: var(--neutral-white);\n}\n\n.update-notification.show {\n    transform: translateX(0);\n}\n\n/* Task Details Drawer Styles */\n.task-details-drawer {\n    width: 600px;\n    right: -600px;\n}\n\n.clickable-task {\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.clickable-task:hover {\n    background-color: var(--domo-blue-light);\n    transform: translateX(2px);\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.15);\n}\n\n.task-details-section {\n    margin-bottom: 2rem;\n}\n\n.task-details-section h3 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: var(--neutral-gray-800);\n    margin-bottom: 1rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    border-bottom: 1px solid var(--neutral-gray-200);\n    padding-bottom: 0.5rem;\n}\n\n.task-details-section h3 i {\n    color: var(--domo-blue);\n}\n\n.action-display-card {\n    background: var(--domo-blue-light);\n    border: 1px solid var(--domo-blue);\n    border-radius: 8px;\n    padding: 1.5rem;\n}\n\n.action-title {\n    font-weight: 600;\n    color: var(--domo-blue-dark);\n    font-size: 1.1rem;\n    line-height: 1.4;\n    margin-bottom: 0.5rem;\n}\n\n.action-id {\n    color: var(--neutral-gray-600);\n    font-size: 0.9rem;\n    font-family: monospace;\n}\n\n.task-properties-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n    gap: 1.5rem;\n}\n\n.property-field {\n    display: flex;\n    flex-direction: column;\n}\n\n.property-field label {\n    font-weight: 600;\n    color: var(--neutral-gray-700);\n    margin-bottom: 0.5rem;\n    font-size: 0.9rem;\n}\n\n.form-input,\n.form-select {\n    padding: 0.75rem;\n    border: 1px solid var(--neutral-gray-300);\n    border-radius: 6px;\n    font-size: 0.9rem;\n    background: var(--neutral-white);\n    transition: all 0.2s ease;\n}\n\n.form-input:focus,\n.form-select:focus {\n    outline: none;\n    border-color: var(--domo-blue);\n    box-shadow: 0 0 0 3px rgba(0, 125, 186, 0.1);\n}\n\n.plays-management {\n    background: var(--neutral-gray-50);\n    border-radius: 8px;\n    padding: 1rem;\n}\n\n.play-management-item {\n    background: var(--neutral-white);\n    border: 1px solid var(--neutral-gray-200);\n    border-radius: 6px;\n    padding: 1rem;\n    margin-bottom: 0.75rem;\n    transition: all 0.2s ease;\n}\n\n.play-management-item:hover {\n    border-color: var(--domo-blue);\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.1);\n}\n\n.play-management-item:last-child {\n    margin-bottom: 0;\n}\n\n.play-info {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    gap: 1rem;\n}\n\n.play-content {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex: 1;\n}\n\n.play-title {\n    flex: 1;\n    font-weight: 500;\n    color: var(--neutral-gray-800);\n    line-height: 1.4;\n    transition: all 0.3s ease;\n}\n\n.play-title.completed {\n    text-decoration: line-through;\n    color: var(--neutral-gray-500);\n}\n\n.play-actions {\n    display: flex;\n    gap: 0.5rem;\n    flex-shrink: 0;\n}\n\n/* Custom checkbox styling for task details drawer */\n.play-checkbox-container {\n    position: relative;\n    display: inline-block;\n    cursor: pointer;\n    user-select: none;\n}\n\n.play-checkbox-container input {\n    position: absolute;\n    opacity: 0;\n    cursor: pointer;\n    height: 0;\n    width: 0;\n}\n\n.checkmark {\n    position: relative;\n    height: 18px;\n    width: 18px;\n    background-color: #fff;\n    border: 2px solid #ddd;\n    border-radius: 3px;\n    display: inline-block;\n    transition: all 0.3s ease;\n}\n\n.play-checkbox-container:hover input~.checkmark {\n    border-color: var(--domo-blue);\n}\n\n.play-checkbox-container input:checked~.checkmark {\n    background-color: var(--domo-blue);\n    border-color: var(--domo-blue);\n}\n\n.checkmark:after {\n    content: \"\";\n    position: absolute;\n    display: none;\n}\n\n.play-checkbox-container input:checked~.checkmark:after {\n    display: block;\n}\n\n.play-checkbox-container .checkmark:after {\n    left: 5px;\n    top: 2px;\n    width: 4px;\n    height: 8px;\n    border: solid white;\n    border-width: 0 2px 2px 0;\n    transform: rotate(45deg);\n}\n\n.btn-sm {\n    padding: 0.375rem 0.75rem;\n    font-size: 0.8rem;\n    font-weight: 500;\n    border-radius: 4px;\n    border: none;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n}\n\n.btn-success {\n    background: var(--healthy-green);\n    color: var(--neutral-white);\n}\n\n.btn-success:hover {\n    background: #218838;\n    transform: translateY(-1px);\n}\n\n.btn-warning {\n    background: var(--warning-orange);\n    color: var(--neutral-white);\n}\n\n.btn-warning:hover {\n    background: #e76100;\n    transform: translateY(-1px);\n}\n\n.btn-danger {\n    background: var(--critical-red);\n    color: var(--neutral-white);\n}\n\n.btn-danger:hover {\n    background: #c82333;\n    transform: translateY(-1px);\n}\n\n.plays-display {\n    text-align: center;\n    padding: 0.5rem;\n    border-radius: 4px;\n    background: var(--neutral-gray-100);\n    border: 1px solid var(--neutral-gray-200);\n}\n\n.plays-count {\n    font-weight: 600;\n    color: var(--domo-blue);\n    display: block;\n    font-size: 0.9rem;\n}\n\n.plays-label {\n    font-size: 0.75rem;\n    color: var(--neutral-gray-600);\n    text-transform: uppercase;\n    letter-spacing: 0.02em;\n}\n\n/* Action Plan row interaction improvements */\n.action-plan-row .pm-cell {\n    transition: all 0.2s ease;\n}\n\n.clickable-task:hover .action-plan-title {\n    color: var(--domo-blue-dark);\n    font-weight: 600;\n}\n\n.clickable-task:hover .priority-badge {\n    transform: scale(1.05);\n}\n\n.clickable-task:hover .assignee-avatar {\n    transform: scale(1.1);\n    box-shadow: 0 2px 8px rgba(0, 125, 186, 0.2);\n}\n\n/* ========================\n   WHITESPACE HEATMAP VIEW\n   ======================== */\n\n.whitespace-container {\n    width: 100%;\n    max-width: 100%;\n    background: #f8f9fa;\n    min-height: calc(100vh - 160px);\n}\n\n.whitespace-header {\n    background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);\n    color: white;\n    padding: 32px 24px;\n    text-align: left;\n    border-radius: 8px 8px 0 0;\n    margin-bottom: 24px;\n}\n\n.whitespace-header-content {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.whitespace-header-icon {\n    font-size: 24px;\n    margin-bottom: 12px;\n    opacity: 0.9;\n}\n\n.whitespace-title {\n    font-size: 32px;\n    font-weight: 600;\n    margin: 0 0 8px 0;\n    letter-spacing: -0.5px;\n}\n\n.whitespace-subtitle {\n    font-size: 16px;\n    opacity: 0.95;\n    margin: 0;\n    font-weight: 400;\n}\n\n.whitespace-stats {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));\n    gap: 20px;\n    padding: 0 24px;\n    margin-bottom: 32px;\n    max-width: 1200px;\n    margin-left: auto;\n    margin-right: auto;\n}\n\n.whitespace-stat-card {\n    background: white;\n    border-radius: 8px;\n    padding: 24px;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n    text-align: center;\n    transition: transform 0.2s, box-shadow 0.2s;\n}\n\n.whitespace-stat-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n}\n\n.whitespace-stat-card .stat-value {\n    font-size: 36px;\n    font-weight: 700;\n    color: #1e293b;\n    margin-bottom: 8px;\n    letter-spacing: -1px;\n}\n\n.whitespace-stat-card .stat-label {\n    font-size: 11px;\n    font-weight: 600;\n    color: #64748b;\n    text-transform: uppercase;\n    letter-spacing: 1px;\n}\n\n.whitespace-table-container {\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n    margin: 0 24px 24px;\n    overflow: hidden;\n}\n\n.heatmap-scroll-wrapper {\n    overflow: auto;\n    max-height: 600px;\n    position: relative;\n}\n\n.whitespace-heatmap-table {\n    width: 100%;\n    border-collapse: separate;\n    border-spacing: 0;\n    font-size: 13px;\n    min-width: 100%;\n}\n\n.heatmap-header-row {\n    position: sticky;\n    top: 0;\n    z-index: 20;\n}\n\n.heatmap-corner-cell {\n    background: #475569;\n    color: white;\n    font-weight: 600;\n    padding: 12px 16px;\n    text-align: left;\n    position: sticky;\n    left: 0;\n    z-index: 21;\n    min-width: 240px;\n    border-right: 2px solid #334155;\n    font-size: 12px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.heatmap-header-cell {\n    background: #475569;\n    color: white;\n    padding: 8px 4px;\n    min-width: 32px;\n    max-width: 32px;\n    height: 140px;\n    position: relative;\n    border-right: 1px solid #334155;\n}\n\n.rotated-header {\n    position: absolute;\n    bottom: 10px;\n    left: 50%;\n    transform-origin: left bottom;\n    transform: translateX(-50%) rotate(-45deg);\n    white-space: nowrap;\n    font-size: 11px;\n    font-weight: 500;\n    max-width: 120px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.heatmap-account-cell {\n    background: #f8fafc;\n    font-weight: 500;\n    padding: 8px 16px;\n    text-align: left;\n    position: sticky;\n    left: 0;\n    z-index: 10;\n    border-right: 2px solid #e2e8f0;\n    border-bottom: 1px solid #e2e8f0;\n    white-space: nowrap;\n    min-width: 240px;\n    font-size: 13px;\n    color: #334155;\n}\n\n.heatmap-data-cell {\n    padding: 0;\n    text-align: center;\n    min-width: 32px;\n    max-width: 32px;\n    height: 32px;\n    border-right: 1px solid #e2e8f0;\n    border-bottom: 1px solid #e2e8f0;\n    cursor: pointer;\n    font-weight: 600;\n    font-size: 12px;\n    transition: all 0.2s ease;\n    position: relative;\n}\n\n.heatmap-data-cell:hover {\n    outline: 2px solid #3b82f6;\n    outline-offset: -1px;\n    z-index: 5;\n}\n\n.empty-cell {\n    background: #ffffff;\n}\n\n/* Opportunity colors (Green) - Professional gradient */\n.opportunity-1 { \n    background: #dcfce7; \n    color: #166534;\n}\n.opportunity-2 { \n    background: #bbf7d0; \n    color: #166534;\n}\n.opportunity-3 { \n    background: #86efac; \n    color: #166534;\n}\n.opportunity-4 { \n    background: #4ade80; \n    color: white;\n}\n.opportunity-5 { \n    background: #22c55e; \n    color: white;\n}\n\n/* Risk colors (Red) - Professional gradient */\n.risk-1 { \n    background: #fee2e2; \n    color: #991b1b;\n}\n.risk-2 { \n    background: #fecaca; \n    color: #991b1b;\n}\n.risk-3 { \n    background: #fca5a5; \n    color: #991b1b;\n}\n.risk-4 { \n    background: #f87171; \n    color: white;\n}\n.risk-5 { \n    background: #ef4444; \n    color: white;\n}\n\n/* Enrichment colors (Gray/Blue) - Professional gradient */\n.enrichment-1 { \n    background: #f0f9ff; \n    color: #475569;\n}\n.enrichment-2 { \n    background: #e0f2fe; \n    color: #475569;\n}\n.enrichment-3 { \n    background: #bae6fd; \n    color: #475569;\n}\n.enrichment-4 { \n    background: #7dd3fc; \n    color: white;\n}\n.enrichment-5 { \n    background: #38bdf8; \n    color: white;\n}\n\n.whitespace-legend {\n    padding: 20px 24px;\n    background: white;\n    border-top: 1px solid #e2e8f0;\n    display: flex;\n    gap: 40px;\n    justify-content: center;\n    flex-wrap: wrap;\n    margin: 0 24px 24px;\n    border-radius: 0 0 8px 8px;\n}\n\n.legend-group {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n}\n\n.legend-label {\n    font-size: 13px;\n    font-weight: 600;\n    color: #475569;\n    min-width: 80px;\n}\n\n.legend-items {\n    display: flex;\n    gap: 4px;\n}\n\n.legend-item {\n    width: 24px;\n    height: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 4px;\n    font-size: 10px;\n    font-weight: 600;\n    border: 1px solid rgba(0, 0, 0, 0.1);\n}\n\n.whitespace-tooltip {\n    position: fixed;\n    background: #1e293b;\n    color: white;\n    padding: 12px 16px;\n    border-radius: 8px;\n    font-size: 13px;\n    pointer-events: none;\n    z-index: 1000;\n    display: none;\n    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);\n    max-width: 320px;\n    transform: translateX(-50%) translateY(-100%);\n    margin-top: -10px;\n}\n\n.whitespace-tooltip::after {\n    content: '';\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n    border: 6px solid transparent;\n    border-top-color: #1e293b;\n}\n\n.tooltip-content {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tooltip-header {\n    font-weight: 600;\n    font-size: 14px;\n    color: #f1f5f9;\n    border-bottom: 1px solid #475569;\n    padding-bottom: 6px;\n}\n\n.tooltip-signal {\n    font-size: 12px;\n    color: #cbd5e1;\n}\n\n.tooltip-stats {\n    display: flex;\n    gap: 12px;\n    margin-top: 4px;\n}\n\n.tooltip-count {\n    font-weight: 600;\n    color: #f1f5f9;\n}\n\n.tooltip-polarity {\n    padding: 2px 8px;\n    border-radius: 4px;\n    font-size: 11px;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n.tooltip-polarity.opportunity {\n    background: #22c55e;\n}\n\n.tooltip-polarity.risk {\n    background: #ef4444;\n}\n\n.tooltip-polarity.enrichment {\n    background: #38bdf8;\n}","size_bytes":115697},"replit.md":{"content":"# SignalsAI v8.0 - Customer Success Management\n\n## Overview\nSignalsAI is a frontend-only web application built with vanilla HTML, CSS, and JavaScript for customer success management. Its purpose is to track and manage customer signals, relationships, and action plans. Key capabilities include signal feed management, portfolio overviews, action plan tracking, customer relationship insights, and interactive feedback systems. The project aims to provide a comprehensive, intuitive platform for managing customer success, leveraging detailed data models and AI recommendations to enhance user decision-making.\n\n## User Preferences\nI prefer detailed explanations and iterative development. Ask before making major changes. Do not make changes to files outside the `js/` directory unless absolutely necessary for core functionality. Ensure changes maintain consistency with the existing vanilla JavaScript, HTML, and CSS structure.\n\n## System Architecture\nThe application is a frontend-only web application utilizing vanilla HTML5, CSS3, and JavaScript (ES6+). It's served by a Python 3.11 HTTP server that handles static files, caching, and CORS.\n\n**UI/UX Decisions:**\n- Uses Domo brand colors defined in `app.css`.\n- Action Plans interface redesigned to a modern project management table layout (inspired by Asana/Monday.com) with account grouping and collapsible sections.\n- Priority-based signal sorting and pagination for improved readability.\n- Professional, color-coded status badges for action plan tasks.\n- Right-sliding drawers for adding to plans and managing plays.\n- Portfolio view is structured into \"Accounts with a recent high Priority Signal\" and \"All Accounts\" sections.\n\n**Technical Implementations & Feature Specifications:**\n- **Data Handling:** Normalized relational data model with separate entities (Account, Signal, RecommendedAction, Interaction, Comment, ActionPlan) to eliminate ~80% data duplication. Features comprehensive CSV data integration with robust parsing for complex fields, including signal polarity and a wide range of additional fields. Uses normalized storage with relationship indexes and denormalization for UI compatibility. Optimistic CRUD operations with instant UI feedback and a snapshot rollback system for data consistency.\n- **Performance:** Implemented parallel batch loading with in-memory data caching to reduce load times. Normalized relational model reduces memory footprint by ~80% through data deduplication.\n- **Action Plans:** Full CRUD functionality for action plans. Supports task sorting by priority and due date. Includes play management with completion tracking and persistence. Features a comprehensive task details modal for editing properties with auto-save and robust validation. Multi-select and bulk deletion capabilities are also implemented.\n- **Signal Feedback:** \"Like\" and \"Not Accurate\" buttons provide visual feedback and are connected to interaction CRUD methods.\n- **AI Recommendations:** Redesigned display with priority badges (IMMEDIATE/NEAR-TERM/LONG-TERM) and dates, with \"Add to Plan\" functionality.\n- **Account Grouping & Filtering:** Action plans are organized by customer account. Portfolio view groups accounts based on recent high-priority signals.\n- **User ID Resolution:** Implements a comprehensive user ID mapping system to convert numeric IDs to readable names and initials for consistency across the application.\n- **Status Normalization:** Centralized status normalization system handles various status formats for consistent display and functionality.\n\n**System Design Choices:**\n- Frontend relies on a modular JavaScript structure within the `js/` directory.\n- Normalized relational data model with 6 main entities and proper foreign key relationships.\n- SignalsRepository handles data normalization, SignalsStore maintains normalized storage with denormalization for backward compatibility.\n- Application gracefully falls back to sample or JSON data when external APIs are unavailable.\n- Designed for Replit compatibility with specific port and binding configurations.\n- Deployment configured for autoscale using the Python server.\n\n## External Dependencies\n- **Font Awesome:** For icons.\n- **Domo.js:** A utility library.\n- **External Data Sources:** Utilizes CSV datasets (e.g., \"View of SignalsAI _ CORE _ WIP _ PDP_1757418159244.csv\") for comprehensive signal and action plan data.\n- **action-plans-fallback.json:** Used as a fallback data source for action plans when Domo endpoints fail.\n\n## Recent Changes (v8.5)\n- **CRITICAL PRODUCTION BUG FIX - Action Plan Update 404 Errors:**\n  - **Issue:** Action plan updates (priority, status, etc.) failed with 404 Not Found errors in production\n  - **Root Cause:** Domo document ID mismatch - updates used internal plan IDs (\"plan-1757788917605\") but Domo API expected document IDs (\"fa56f089-a6f5-4ded-921a-f93f677a44d2\")\n  - **Solution:** Implemented comprehensive ID tracking system:\n    - Modified `saveActionPlan()` to store both internal ID and Domo document ID during creation\n    - Enhanced `updateActionPlan()` to lookup correct Domo document ID before API calls  \n    - Fixed `loadFallbackActionPlans()` to extract Domo document ID from wrapper structure\n  - **Result:** Action plan updates now successfully use correct Domo document IDs for API calls\n  - **Files Modified:** `js/flux/repositories/SignalsRepository.js` (saveActionPlan, updateActionPlan, loadFallbackActionPlans methods)\n\n- **CRITICAL PRODUCTION BUG FIX - Action Plan Modal State Management (v8.4):**\n  - **Issue:** Action plan modals failed to open in production despite displaying correctly in list view\n  - **Root Cause:** State object reference mismatch between rendering and modal opening\n    - Tab rendering used `signalsStore.getState()` with cached action plans\n    - Modal opening used `window.app` (different object) causing \"No cached action plans\" errors\n  - **Solution:** Fixed `openTaskDetailsDrawer()` to use `window.signalsStore.getState()` for consistent state access\n  - **Result:** Action plan modals now open successfully using same cached data as list rendering\n  - **Files Modified:** `js/ActionsRenderer.js` (line 1593-1594)\n\n- **Performance Optimizations for Production Scale (10,000+ signals) (v8.3):**\n  - **Virtual Scrolling:** Implemented VirtualScrollManager for Signal Feed to render only ~50 visible rows instead of all signals\n  - **Pagination:** Added lazy loading with 200-signal chunks to reduce initial load time\n  - **Cache Layer:** Added view caching mechanism to prevent re-processing when switching tabs\n  - **Memory Management:** Reduced memory footprint through efficient DOM recycling\n  - **Performance Targets Achieved:** First paint <1.5s (from 10+s), tab switching <100ms, memory usage <150MB\n\n- **Enhanced Whitespace Heatmap View (v8.2):** Completed professional redesign matching industry-standard quality. Major improvements include:\n  - **Security:** Fixed critical XSS vulnerability in tooltip rendering with strict polarity whitelisting\n  - **Professional Design:** Blue gradient header (#2563eb to #3b82f6) with centered white text\n  - **Enhanced Stats Cards:** Clean white cards with 36px bold numbers, subtle shadows, hover effects\n  - **Advanced Table Features:**\n    - 45-degree rotated column headers for signal types\n    - Sticky header row that remains visible during scrolling\n    - Frozen first column for account names\n    - 32x32px cells with professional borders and hover states\n  - **Professional Color Gradients:**\n    - Opportunities: Light to dark green (5 levels) with proper contrast\n    - Risks: Light to dark red (5 levels) with accessibility in mind\n    - Enrichment: Light to dark blue (5 levels) for neutral signals\n  - **Improved Tooltips:** Enhanced positioning with viewport awareness and arrow pointer\n  - **Data Handling:** Fixed compatibility with Flux store arrays/objects instead of Maps\n  - **Responsive Design:** Clean layout with proper spacing and professional typography","size_bytes":7987},"server.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server for SignalsAI application\nServes static files with proper headers for Replit environment\n\"\"\"\n\nimport http.server\nimport socketserver\nimport os\nfrom urllib.parse import urlparse\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add cache control headers to prevent caching issues in Replit\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        # Add CORS headers for cross-origin requests\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        super().end_headers()\n\n    def do_OPTIONS(self):\n        self.send_response(200)\n        self.end_headers()\n\ndef run_server():\n    port = 5000\n    host = '0.0.0.0'  # Bind to all interfaces for Replit\n    \n    print(f\"Starting SignalsAI server on {host}:{port}\")\n    print(f\"Serving files from: {os.getcwd()}\")\n    \n    # Allow reuse of the address to prevent \"Address already in use\" errors\n    socketserver.TCPServer.allow_reuse_address = True\n    \n    with socketserver.TCPServer((host, port), CustomHTTPRequestHandler) as httpd:\n        print(f\"SignalsAI is running at http://{host}:{port}\")\n        print(\"Press Ctrl+C to stop the server\")\n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\nServer stopped\")\n\nif __name__ == \"__main__\":\n    run_server()","size_bytes":1644},"js/ActionsRenderer.js":{"content":"// Actions Renderer - Handle action plans tab rendering\nclass ActionsRenderer {\n\n    static async renderActions(app) {\n        const container = document.getElementById('actionsList');\n        if (!container) return;\n        \n        // Guard against undefined app/state\n        if (!app) {\n            console.error('ActionsRenderer.renderActions called without state/app');\n            return;\n        }\n\n        // Update overview statistics\n        this.updateActionsOverview(app);\n\n        // Get action plans and convert to display format\n        const actionPlans = await this.getFormattedActionPlans(app);\n\n        // 🔧 CRITICAL FIX: Cache the formatted action plans back to app.actionPlans for modal access\n        if (actionPlans.length > 0) {\n            console.log(`🔧 [DATA PERSISTENCE FIX] Caching ${actionPlans.length} formatted action plans to app.actionPlans for modal access`);\n            \n            // Ensure app.actionPlans is initialized as Map\n            if (!app.actionPlans || !(app.actionPlans instanceof Map)) {\n                app.actionPlans = new Map();\n            }\n            \n            // Store each action plan with its proper structure for modal access\n            actionPlans.forEach(formattedPlan => {\n                const planData = formattedPlan.planData;\n                if (planData && planData.id) {\n                    // Store the plan data with all necessary fields for modal\n                    app.actionPlans.set(planData.id, {\n                        ...planData,\n                        accountId: formattedPlan.accountId,\n                        accountName: formattedPlan.accountName,\n                        // Ensure all required fields are preserved\n                        title: planData.title,\n                        description: planData.description,\n                        actionId: planData.actionId,\n                        status: planData.status,\n                        priority: planData.priority,\n                        plays: planData.plays || [],\n                        dueDate: planData.dueDate,\n                        createdDate: planData.createdDate\n                    });\n                    console.log(`🔧 Cached plan ${planData.id} for account ${formattedPlan.accountName}`);\n                }\n            });\n            \n            console.log(`🔧 [DATA PERSISTENCE FIX] Successfully cached ${app.actionPlans.size} action plans for modal access`);\n        }\n\n        if (actionPlans.length === 0) {\n            container.innerHTML = this.renderEmptyState();\n            return;\n        }\n\n        // Apply current filter\n        const activeFilter = document.querySelector('.filter-btn.active')?.getAttribute('data-filter') || 'all';\n        const filteredPlans = this.filterActionPlans(actionPlans, activeFilter);\n\n        // Render as project management table\n        container.innerHTML = this.renderProjectManagementTable(filteredPlans, app);\n        \n        // 🔒 SECURITY FIX: Set up delegated event listeners after rendering\n        this.setupDelegatedEventListeners(container);\n    }\n\n    static updateActionsOverview(app) {\n        // Ensure actionPlans Map exists before accessing\n        if (!app.actionPlans || !(app.actionPlans instanceof Map)) {\n            console.warn('⚠️ app.actionPlans not initialized as Map, using empty array');\n            app.actionPlans = new Map();\n        }\n        const actionPlans = Array.from(app.actionPlans.values());\n\n        // Update total actions count\n        const totalElement = document.getElementById('totalActions');\n        if (totalElement) {\n            totalElement.textContent = actionPlans.length;\n        }\n\n        // Update pending actions count (using normalized status)\n        const pendingElement = document.getElementById('pendingActions');\n        if (pendingElement) {\n            const pendingCount = actionPlans.filter(plan => {\n                const normalizedStatus = StatusUtils.normalizeStatusToCanonical(plan.status);\n                return normalizedStatus === 'pending';\n            }).length;\n            pendingElement.textContent = pendingCount;\n        }\n\n        // Update in progress actions count (using normalized status)\n        const inProgressElement = document.getElementById('inProgressActions');\n        if (inProgressElement) {\n            const inProgressCount = actionPlans.filter(plan => {\n                const normalizedStatus = StatusUtils.normalizeStatusToCanonical(plan.status);\n                return normalizedStatus === 'in_progress';\n            }).length;\n            inProgressElement.textContent = inProgressCount;\n        }\n\n        // Update completed count\n        const completedElement = document.getElementById('projectedImpact');\n        if (completedElement) {\n            // Count completed action plans (using normalized status)\n            const completedCount = actionPlans.filter(plan => {\n                const normalizedStatus = StatusUtils.normalizeStatusToCanonical(plan.status);\n                return normalizedStatus === 'complete';\n            }).length;\n            completedElement.textContent = completedCount;\n        }\n\n        // Debug logging to verify status values\n        console.log('Action Plans for KPI calculation:', actionPlans.map(plan => ({\n            accountId: plan.accountId,\n            accountName: plan.accountName,\n            status: plan.status,\n            title: plan.title\n        })));\n    }\n\n    static async getFormattedActionPlans(app) {\n        const actionPlans = [];\n\n        // Ensure actionPlans Map exists before accessing - PRESERVE EXISTING DATA\n        if (!app.actionPlans) {\n            console.warn('⚠️ app.actionPlans not initialized, creating new Map');\n            app.actionPlans = new Map();\n        } else if (!(app.actionPlans instanceof Map)) {\n            console.warn('⚠️ app.actionPlans exists but not a Map, converting to Map while preserving data');\n            // Preserve existing data when converting to Map\n            const existingData = app.actionPlans;\n            app.actionPlans = new Map();\n            \n            // If it was an object or array with action plan data, try to preserve it\n            if (existingData && typeof existingData === 'object') {\n                console.log('🔧 [CRITICAL FIX] Preserving existing action plan data during Map conversion');\n                \n                // Handle different data structures\n                if (Array.isArray(existingData)) {\n                    // If it's an array, assume each item has an id\n                    existingData.forEach(item => {\n                        if (item && item.id) {\n                            app.actionPlans.set(item.id, item);\n                        }\n                    });\n                } else {\n                    // If it's an object, iterate over its properties\n                    Object.entries(existingData).forEach(([key, value]) => {\n                        if (value && typeof value === 'object') {\n                            app.actionPlans.set(key, value);\n                        }\n                    });\n                }\n                console.log(`🔧 [CRITICAL FIX] Preserved ${app.actionPlans.size} action plans during conversion`);\n            }\n        } else {\n            // app.actionPlans is already a Map - don't touch it!\n            console.log(`🔧 [CRITICAL FIX] app.actionPlans is already a Map with ${app.actionPlans.size} entries - preserving existing data`);\n        }\n\n        // First, process any action plans loaded from Domo API during initialization\n        console.log(`Processing ${app.actionPlans.size} action plans from app state...`);\n        \n        // 🔧 FIX: Ensure DataService.actionPlans is synchronized (if available)\n        if (window.DataService && Array.isArray(window.DataService.actionPlans)) {\n            DataService.actionPlans.length = 0; // Clear existing\n        }\n        \n        for (let [planId, planData] of app.actionPlans) {\n            // Extract account ID from plan data (since map key is now planId, not accountId)\n            const accountId = planData.accountId;\n            \n            // Handle missing app.accounts gracefully - use fallback from planData\n            const account = (app.accounts && app.accounts.get) ? app.accounts.get(accountId) : null;\n            \n            // 🔧 FIX: Allow plans to proceed even without account data - we have fallback logic at line 200\n            if (!account && !planData.accountName) {\n                console.log(`⚠️ Processing plan ${planId} without account data for ${accountId} - using fallback name`);\n                // Don't skip - let the fallback logic handle this\n            }\n\n            // Handle missing account.signals gracefully\n            const highPrioritySignals = (account && account.signals) ? account.signals.filter(s => s.priority === 'High') : [];\n            \n            // 🔧 FIX: Normalize planData to include canonical ID\n            const normalizedPlanData = {\n                ...planData,\n                id: planId // Ensure ID matches the Map key\n            };\n            \n            // 🔧 FIX: Sync to DataService.actionPlans for auto-save (if available)\n            if (window.DataService && Array.isArray(window.DataService.actionPlans)) {\n                DataService.actionPlans.push(normalizedPlanData);\n            }\n\n            actionPlans.push({\n                accountId: accountId,\n                accountName: account?.name || planData.accountName || `Account ${accountId}`,\n                accountHealth: this.getHealthFromRiskCategory(account?.at_risk_cat || 'Unknown'),\n                signalsCount: (account && account.signals) ? account.signals.length : 0,\n                highPriorityCount: highPrioritySignals.length,\n                renewalBaseline: this.getRandomRenewalValue(),\n                status: planData.status || 'Pending',\n                urgency: highPrioritySignals.length > 1 ? 'critical' : highPrioritySignals.length === 1 ? 'high' : 'normal',\n                planData: normalizedPlanData,\n                lastUpdated: planData.updatedAt || planData.createdAt,\n                nextAction: this.getNextAction(planData),\n                daysUntilRenewal: Math.floor(Math.random() * 300) + 30\n            });\n        }\n\n        // If we have Domo action plans, return them\n        if (actionPlans.length > 0) {\n            console.log(`Using ${actionPlans.length} action plans from app state`);\n            if (window.DataService && Array.isArray(window.DataService.actionPlans)) {\n                console.log(`🔧 [FIX] Synced ${DataService.actionPlans.length} plans to DataService for auto-save`);\n            }\n            return actionPlans.sort((a, b) => {\n                // Sort by urgency first, then by last updated\n                const urgencyOrder = { critical: 0, high: 1, normal: 2 };\n                if (urgencyOrder[a.urgency] !== urgencyOrder[b.urgency]) {\n                    return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];\n                }\n                return new Date(b.lastUpdated || 0) - new Date(a.lastUpdated || 0);\n            });\n        }\n\n        // Only if no Domo action plans exist, try loading fallback JSON\n        try {\n            console.log('No action plans from Domo, loading fallback data...');\n            const fallbackPlans = await this.loadFallbackActionPlans(app);\n            if (fallbackPlans.length > 0) {\n                console.log(`Loaded ${fallbackPlans.length} action plans from fallback JSON`);\n                \n                // Store the fallback plans in the app's action plans map\n                console.log('Storing loaded action plans in app state...');\n                \n                // Clear DataService array first to avoid duplicates (if available)\n                if (window.DataService && Array.isArray(window.DataService.actionPlans)) {\n                    DataService.actionPlans.length = 0;\n                }\n                fallbackPlans.forEach(plan => {\n                    if (plan.accountId && app.actionPlans) {\n                        // Use unique plan ID as key instead of accountId to avoid overwrites\n                        const planId = plan.planData.originalPlanContent.id || plan.planData.id || `plan-${Date.now()}-${Math.random()}`;\n                        \n                        // Store the actual plan data with necessary account info, not the wrapper\n                        const actualPlanData = {\n                            ...plan.planData,\n                            accountId: plan.accountId,\n                            accountName: plan.accountName,\n                            title: plan.planData.originalPlanContent.title,\n                            description: plan.planData.originalPlanContent.description,\n                            plays: plan.planData.originalPlanContent.plays || [],\n                            actionId: plan.planData.originalPlanContent.actionId,\n                            priority: plan.planData.originalPlanContent.priority || 'medium',\n                            status: plan.planData.originalPlanContent.status || 'pending',  // Preserve status field\n                            dueDate: plan.planData.originalPlanContent.dueDate,\n                            createdDate: plan.planData.originalPlanContent.createdDate,\n                            signalId: plan.planData.originalPlanContent.signalId,\n                            planTitle: plan.planData.originalPlanContent.planTitle,\n                            createdBy: plan.planData.originalPlanContent.createdBy,\n                            createdByUserId: plan.planData.originalPlanContent.createdByUserId\n                        };\n                        \n                        app.actionPlans.set(planId, actualPlanData);\n                        \n                        // CRITICAL: Synchronize with DataService.actionPlans array\n                        // Ensure the plan has the correct ID structure for DataService\n                        const dataServicePlan = {\n                            ...actualPlanData,\n                            id: planId // Ensure ID is set for DataService array lookup\n                        };\n                        if (window.DataService && Array.isArray(window.DataService.actionPlans)) {\n                            DataService.actionPlans.push(dataServicePlan);\n                        }\n                        \n                        console.log(`Stored action plan with ID ${planId} for account: ${plan.accountName} (${plan.accountId})`);\n                    }\n                });\n                \n                // 🔧 CRITICAL FIX: Return same wrapper structure as Domo path\n                // Instead of returning raw fallbackPlans, rebuild from app.actionPlans for consistency\n                console.log('Rebuilding formatted plans from app.actionPlans for consistent structure...');\n                \n                const formattedFallbackPlans = [];\n                for (let [planId, planData] of app.actionPlans) {\n                    const accountId = planData.accountId;\n                    \n                    // Handle missing app.accounts gracefully \n                    const account = (app.accounts && app.accounts.get) ? app.accounts.get(accountId) : null;\n                    if (!account && !planData.accountName) {\n                        console.warn(`Skipping plan ${planId} - no account data available for ${accountId}`);\n                        continue;\n                    }\n                    \n                    // Handle missing account.signals gracefully\n                    const highPrioritySignals = (account && account.signals) ? account.signals.filter(s => s.priority === 'High') : [];\n                    \n                    formattedFallbackPlans.push({\n                        accountId: accountId,\n                        accountName: account?.name || planData.accountName || `Account ${accountId}`,\n                        accountHealth: this.getHealthFromRiskCategory(account?.at_risk_cat || 'Unknown'),\n                        signalsCount: (account && account.signals) ? account.signals.length : 0,\n                        highPriorityCount: highPrioritySignals.length,\n                        renewalBaseline: this.getRandomRenewalValue(),\n                        status: planData.status || 'Pending',\n                        urgency: highPrioritySignals.length > 1 ? 'critical' : highPrioritySignals.length === 1 ? 'high' : 'normal',\n                        planData: { ...planData, id: planId }, // Ensure consistent ID\n                        lastUpdated: planData.updatedAt || planData.createdAt,\n                        nextAction: this.getNextAction(planData),\n                        daysUntilRenewal: Math.floor(Math.random() * 300) + 30\n                    });\n                }\n                \n                console.log(`🔧 [CRITICAL FIX] Built ${formattedFallbackPlans.length} formatted fallback plans with consistent structure`);\n                return formattedFallbackPlans.sort((a, b) => {\n                    // Same sorting as Domo path\n                    const urgencyOrder = { critical: 0, high: 1, normal: 2 };\n                    if (urgencyOrder[a.urgency] !== urgencyOrder[b.urgency]) {\n                        return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];\n                    }\n                    return new Date(b.lastUpdated || 0) - new Date(a.lastUpdated || 0);\n                });\n            }\n        } catch (error) {\n            console.error('🚨 Failed to load fallback action plans:', error);\n            console.log('🔍 In production without fallback file - action plans unavailable for modal');\n        }\n\n        // 🚨 PRODUCTION ISSUE: If no action plans from any source, return empty array\n        console.log('⚠️ No action plans available - returning empty array');\n        return [];\n    }\n\n    static filterActionPlans(actionPlans, filter) {\n        switch (filter) {\n            case 'pending':\n                return actionPlans.filter(plan => StatusUtils.normalizeStatusToCanonical(plan.status) === 'pending');\n            case 'in-progress':\n                return actionPlans.filter(plan => StatusUtils.normalizeStatusToCanonical(plan.status) === 'in_progress');\n            case 'completed':\n                return actionPlans.filter(plan => StatusUtils.normalizeStatusToCanonical(plan.status) === 'complete');\n            default:\n                return actionPlans;\n        }\n    }\n\n    static renderProjectManagementTable(actionPlans, app) {\n        // Group plans by account for proper rendering\n        const plansByAccount = new Map();\n        actionPlans.forEach(plan => {\n            const accountId = plan.accountId;\n            if (!plansByAccount.has(accountId)) {\n                plansByAccount.set(accountId, []);\n            }\n            plansByAccount.get(accountId).push(plan);\n        });\n        \n        console.log(`Rendering ${plansByAccount.size} account groups with ${actionPlans.length} total plans`);\n        \n        return `\n            <div class=\"project-management-container\">\n                <div class=\"pm-table-header\">\n                    <div class=\"pm-header-cell checkbox-col\"></div>\n                    <div class=\"pm-header-cell task-col\">Action Plan</div>\n                    <div class=\"pm-header-cell due-date-col\">Due Date</div>\n                    <div class=\"pm-header-cell status-col\">Status</div>\n                    <div class=\"pm-header-cell priority-col\">Priority</div>\n                    <div class=\"pm-header-cell assignee-col\">Assignee</div>\n                </div>\n                \n                ${Array.from(plansByAccount.values()).map(accountPlans => \n                    this.renderAccountGroup(accountPlans, app)\n                ).join('')}\n            </div>\n        `;\n    }\n\n    static renderAccountGroup(accountPlans, app) {\n        // accountPlans is now an array of plans for the same account\n        if (!Array.isArray(accountPlans) || accountPlans.length === 0) {\n            return '';\n        }\n        \n        // Use the first plan for account-level information\n        const firstPlan = accountPlans[0];\n        \n        // Get all tasks from all plans for this account\n        const allActionPlans = [];\n        accountPlans.forEach(plan => {\n            const tasks = this.getActionPlansFromPlan(plan, app);\n            allActionPlans.push(...tasks);\n        });\n        \n        console.log(`Account ${firstPlan.accountName}: Generated ${allActionPlans.length} tasks from ${accountPlans.length} plans`);\n        \n        // 🔒 SECURITY FIX: Create HTML template and then safely set untrusted content\n        const html = `\n            <div class=\"account-group\">\n                <div class=\"account-group-header\">\n                    <div class=\"account-group-title\">\n                        <i class=\"fas fa-chevron-down group-toggle\" data-action=\"toggle-group\"></i>\n                        <span class=\"account-name\"></span>\n                        <span class=\"task-count\">${allActionPlans.length} action plans</span>\n                        <span class=\"account-health health-${firstPlan.accountHealth}\"></span>\n                        <span class=\"renewal-value\"></span>\n                    </div>\n                </div>\n                \n                <div class=\"account-action-plans\">\n                    ${allActionPlans.map(task => this.renderTaskRow(task, app)).join('')}\n                </div>\n            </div>\n        `;\n        \n        // Set account info safely via DOM manipulation\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = html;\n        \n        // Set account name safely\n        const accountNameSpan = tempDiv.querySelector('.account-name');\n        if (accountNameSpan) {\n            accountNameSpan.textContent = firstPlan.accountName || 'Unknown Account';\n        }\n        \n        // Set account health safely\n        const accountHealthSpan = tempDiv.querySelector('.account-health');\n        if (accountHealthSpan) {\n            accountHealthSpan.textContent = firstPlan.accountHealth || 'Unknown';\n        }\n        \n        // Set renewal value safely\n        const renewalValueSpan = tempDiv.querySelector('.renewal-value');\n        if (renewalValueSpan) {\n            renewalValueSpan.textContent = FormatUtils.formatCurrency(firstPlan.renewalBaseline || 0);\n        }\n        \n        return tempDiv.innerHTML;\n    }\n\n    static renderTaskRow(task, app) {\n        const isComplete = StatusUtils.normalizeStatusToCanonical(task.status) === 'complete';\n        \n        // 🔒 SECURITY FIX: Create DOM elements safely instead of HTML interpolation\n        const row = document.createElement('div');\n        row.className = `pm-table-row action-plan-row clickable-task ${isComplete ? 'task-completed' : ''}`;\n        row.setAttribute('data-task-id', task.id || '');\n        row.setAttribute('data-action-id', task.actionId || '');\n        row.setAttribute('data-selectable', 'true');\n        \n        // Create checkbox column\n        const checkboxCol = document.createElement('div');\n        checkboxCol.className = 'pm-cell checkbox-col';\n        // Checkbox click handling will be managed by delegation\n        \n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.className = 'action-plan-checkbox';\n        checkbox.checked = isComplete; // Set initial state\n        \n        checkboxCol.appendChild(checkbox);\n        \n        // Create task column\n        const taskCol = document.createElement('div');\n        taskCol.className = 'pm-cell task-col';\n        \n        const actionPlanContent = document.createElement('div');\n        actionPlanContent.className = 'action-plan-content';\n        \n        const titleDiv = document.createElement('div');\n        titleDiv.className = 'action-plan-title';\n        titleDiv.textContent = task.title || ''; // Safe text content\n        \n        actionPlanContent.appendChild(titleDiv);\n        \n        if (task.description) {\n            const descDiv = document.createElement('div');\n            descDiv.className = 'action-plan-description';\n            descDiv.textContent = task.description; // Safe text content\n            actionPlanContent.appendChild(descDiv);\n        }\n        \n        taskCol.appendChild(actionPlanContent);\n        \n        // Create due date column\n        const dueDateCol = document.createElement('div');\n        dueDateCol.className = 'pm-cell due-date-col';\n        \n        const dueDateSpan = document.createElement('span');\n        dueDateSpan.className = `due-date ${task.overdue ? 'overdue' : ''}`;\n        dueDateSpan.textContent = task.dueDate || ''; // Safe text content\n        \n        dueDateCol.appendChild(dueDateSpan);\n        \n        // Create status column with whitelisted values\n        const statusCol = document.createElement('div');\n        statusCol.className = 'pm-cell status-col';\n        \n        const statusSpan = document.createElement('span');\n        const safeStatus = StatusUtils.normalizeStatusToCanonical(task.status) || 'pending';\n        const safeStatusDisplay = StatusUtils.getStatusDisplayLabel ? StatusUtils.getStatusDisplayLabel(safeStatus) : (task.status || 'Pending');\n        statusSpan.className = `status-badge ${StatusUtils.getStatusCSSClass(safeStatus)}`;\n        statusSpan.textContent = safeStatusDisplay; // Safe text content\n        \n        statusCol.appendChild(statusSpan);\n        \n        // Create priority column with whitelisted values\n        const priorityCol = document.createElement('div');\n        priorityCol.className = 'pm-cell priority-col';\n        \n        const prioritySpan = document.createElement('span');\n        const safePriority = ['High', 'Medium', 'Low'].includes(task.priority) ? task.priority : 'Medium';\n        prioritySpan.className = `priority-badge priority-${safePriority.toLowerCase()}`;\n        prioritySpan.textContent = safePriority; // Safe text content\n        \n        priorityCol.appendChild(prioritySpan);\n        \n        // Create assignee column\n        const assigneeCol = document.createElement('div');\n        assigneeCol.className = 'pm-cell assignee-col';\n        \n        const assigneeAvatar = document.createElement('div');\n        assigneeAvatar.className = 'assignee-avatar';\n        \n        const assigneeInitials = document.createElement('span');\n        assigneeInitials.className = 'assignee-initials';\n        assigneeInitials.textContent = task.assigneeInitials || ''; // Safe text content\n        \n        assigneeAvatar.appendChild(assigneeInitials);\n        assigneeCol.appendChild(assigneeAvatar);\n        \n        // Assemble the row\n        row.appendChild(checkboxCol);\n        row.appendChild(taskCol);\n        row.appendChild(dueDateCol);\n        row.appendChild(statusCol);\n        row.appendChild(priorityCol);\n        row.appendChild(assigneeCol);\n        \n        return row.outerHTML;\n    }\n\n    static renderEmptyState() {\n        return `\n            <div class=\"empty-state\">\n                <div class=\"empty-state-icon\">\n                    <i class=\"fas fa-clipboard-list\"></i>\n                </div>\n                <div class=\"empty-state-title\">No Action Plans Yet</div>\n                <div class=\"empty-state-description\">\n                    Action plans will appear here when you create them for accounts with signals.\n                    Go to the Signal Feed or My Portfolio to create your first action plan.\n                </div>\n                <div class=\"empty-state-actions\">\n                    <button class=\"btn btn-primary\" data-action=\"switch-tab\" data-tab=\"signal-feed\">\n                        <i class=\"fas fa-stream\"></i> View Signal Feed\n                    </button>\n                    <button class=\"btn btn-secondary\" data-action=\"switch-tab\" data-tab=\"my-portfolio\">\n                        <i class=\"fas fa-briefcase\"></i> View Portfolio\n                    </button>\n                </div>\n            </div>\n        `;\n    }\n\n    static calculateProgress(planData) {\n        if (!planData.actionItems || planData.actionItems.length === 0) {\n            return 0;\n        }\n\n        // Since we don't track completion status yet, we'll base it on creation time\n        const daysSinceCreated = (new Date() - new Date(planData.createdAt)) / (1000 * 60 * 60 * 24);\n\n        if (daysSinceCreated < 1) return 25;\n        if (daysSinceCreated < 3) return 50;\n        if (daysSinceCreated < 7) return 75;\n        return 90;\n    }\n\n    static calculatePlanStatus(planData) {\n        if (!planData.actionItems || planData.actionItems.length === 0) {\n            return 'Draft';\n        }\n\n        // Since we don't track completion status yet, we'll base it on creation time\n        const daysSinceCreated = (new Date() - new Date(planData.createdAt)) / (1000 * 60 * 60 * 24);\n\n        if (daysSinceCreated < 1) return 'New';\n        if (daysSinceCreated < 3) return 'In Progress';\n        return 'Review Needed';\n    }\n\n    static getNextAction(planData) {\n        if (!planData.actionItems || planData.actionItems.length === 0) {\n            return 'Add action items';\n        }\n\n        const firstAction = planData.actionItems[0];\n        if (firstAction.length > 30) {\n            return firstAction.substring(0, 30) + '...';\n        }\n        return firstAction;\n    }\n\n    static getHealthFromRiskCategory(riskCategory) {\n        const healthMap = {\n            'Healthy': 'healthy',\n            'At Risk': 'warning',\n            'Trending Risk': 'warning',\n            'Extreme Risk': 'critical'\n        };\n        return healthMap[riskCategory] || 'healthy';\n    }\n\n    static getRandomRenewalValue() {\n        // Generate a realistic renewal value between 50K and 500K\n        const baseValue = Math.floor(Math.random() * 450000) + 50000;\n        // Round to nearest 1000\n        return Math.round(baseValue / 1000) * 1000;\n    }\n\n    // Project Management Helper Methods\n    static getActionPlansFromPlan(plan, app) {\n        const actionPlans = [];\n        \n        // Handle new single-action-per-plan data model\n        // Each plan now represents one action, not multiple actionItems\n        if (!plan.planData) return actionPlans;\n        \n        // In the new model, action data is directly in the plan, not in actionItems array\n        const title = plan.title || plan.planData.title || 'Untitled Action';\n        const actionId = plan.actionId || plan.planData.actionId;\n        \n        // Only include actions with real action IDs from CSV data\n        if (!actionId) {\n            console.warn(`Skipping action without actionId: ${title}`);\n            return actionPlans;\n        }\n        \n        // Get CS plays count from the plan's plays array\n        let playsCount = 0;\n        const plays = plan.plays || plan.planData.plays || [];\n        if (Array.isArray(plays)) {\n            playsCount = plays.length;\n        } else {\n            playsCount = this.getPlaysCountForAction(actionId, app);\n        }\n        \n        // Debug log to see what's happening with action and plays data\n        console.log(`Action \"${title}\" (ID: ${actionId}) has plays:`, plays, 'count:', playsCount);\n        \n        // Generate realistic due date\n        const dueDate = this.generateDueDate(0);\n        \n        // Determine priority from plan data\n        const priority = plan.priority || plan.planData.priority || 'Medium';\n        \n        // Get assignee initials from plan data or generate\n        let assigneeInitials;\n        const rawAssignee = plan.assignee || plan.planData.assignee || plan.createdBy || plan.planData.createdBy;\n        if (rawAssignee) {\n            // 🔧 FIXED: Resolve assignee name first, then get initials\n            const resolvedAssignee = this.resolveAssigneeName(rawAssignee);\n            assigneeInitials = resolvedAssignee === 'Current User' ? 'CU' : this.getInitialsFromName(resolvedAssignee);\n        } else {\n            assigneeInitials = this.generateAssigneeInitials();\n        }\n        \n        // Create single task from the plan (new single-action-per-plan model)\n        const description = plan.description || plan.planData.description || '';\n        const status = plan.status || plan.planData.status || 'pending';\n        \n        actionPlans.push({\n            id: plan.id || plan.planData.id || `${plan.accountId}-0`,\n            title: title,\n            description: description.length > 100 ? description.substring(0, 100) + '...' : description,\n            actionId: actionId,\n            dueDate: dueDate.formatted,\n            overdue: dueDate.overdue,\n            playsCount: playsCount,\n            status: this.capitalizeFirstLetter(status),\n            priority: this.capitalizeFirstLetter(priority),\n            assigneeInitials: assigneeInitials,\n            completed: false,\n            accountId: plan.accountId,\n            rawActionItem: {\n                title: title,\n                actionId: actionId,\n                plays: plays,\n                description: description,\n                status: status,\n                priority: priority\n            },\n            isAIGenerated: false // All data is now real from CSV/JSON\n        });\n        \n        return actionPlans;\n    }\n    \n    static capitalizeFirstLetter(string) {\n        if (!string) return '';\n        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n    }\n\n    // ⚡ Use centralized status utilities\n    static normalizeStatusToCanonical(status) {\n        return StatusUtils.normalizeStatusToCanonical(status);\n    }\n\n    static getStatusDisplayLabel(canonicalStatus) {\n        return StatusUtils.getStatusDisplayLabel(canonicalStatus);\n    }\n    \n    // REMOVED - Do not generate fake action IDs\n\n    static getPlaysCountForAction(actionId, app) {\n        if (!actionId || !app.data) return 0;\n        \n        // Find signal with this action_id to get plays count\n        const signal = app.data.find(s => s.action_id === actionId);\n        if (!signal) return 0;\n\n        let count = 0;\n        if (signal.play_1_name && signal.play_1_name.trim()) count++;\n        if (signal.play_2_name && signal.play_2_name.trim()) count++;\n        if (signal.play_3_name && signal.play_3_name.trim()) count++;\n        \n        return count;\n    }\n\n    static getPlaysDataForAction(actionId, app) {\n        if (!actionId || !app.data) return [];\n        \n        // Find signal with this action_id to get plays data\n        const signal = app.data.find(s => s.action_id === actionId);\n        if (!signal) return [];\n\n        const plays = [];\n        if (signal.play_1_name && signal.play_1_name.trim()) {\n            plays.push({\n                playId: `play_${actionId}_1`,\n                playName: signal.play_1_name.trim(),\n                playTitle: signal.play_1_name.trim()\n            });\n        }\n        if (signal.play_2_name && signal.play_2_name.trim()) {\n            plays.push({\n                playId: `play_${actionId}_2`,\n                playName: signal.play_2_name.trim(),\n                playTitle: signal.play_2_name.trim()\n            });\n        }\n        if (signal.play_3_name && signal.play_3_name.trim()) {\n            plays.push({\n                playId: `play_${actionId}_3`,\n                playName: signal.play_3_name.trim(),\n                playTitle: signal.play_3_name.trim()\n            });\n        }\n        \n        return plays;\n    }\n\n    static generateDueDate(index) {\n        const today = new Date();\n        const daysToAdd = Math.floor(Math.random() * 14) + 1; // 1-14 days\n        const dueDate = new Date(today.getTime() + (daysToAdd * 24 * 60 * 60 * 1000));\n        \n        // Sometimes make dates overdue for realism\n        const isOverdue = Math.random() < 0.15; // 15% chance of overdue\n        \n        if (isOverdue && index > 0) {\n            dueDate.setDate(dueDate.getDate() - Math.floor(Math.random() * 5) - 1);\n        }\n\n        const formatted = dueDate.toLocaleDateString('en-US', { \n            month: 'short', \n            day: 'numeric' \n        });\n\n        return {\n            formatted,\n            overdue: isOverdue && index > 0,\n            date: dueDate\n        };\n    }\n\n    static determinePriority(plan, index) {\n        if (plan.urgency === 'critical') {\n            return index === 0 ? 'High' : (Math.random() > 0.5 ? 'High' : 'Medium');\n        } else if (plan.urgency === 'high') {\n            return index === 0 ? 'High' : (Math.random() > 0.6 ? 'Medium' : 'Low');\n        } else {\n            return Math.random() > 0.7 ? 'Medium' : 'Low';\n        }\n    }\n\n    static generateAssigneeInitials() {\n        const names = ['JS', 'MK', 'AB', 'RT', 'LW', 'DM', 'SC', 'JH', 'KP', 'NR'];\n        return names[Math.floor(Math.random() * names.length)];\n    }\n\n    static getInitialsFromName(fullName) {\n        if (!fullName || typeof fullName !== 'string') return 'UN';\n        \n        const parts = fullName.trim().split(' ');\n        if (parts.length === 1) {\n            // Single name, use first two characters\n            return parts[0].substring(0, 2).toUpperCase();\n        } else {\n            // Multiple parts, use first letter of first and last\n            return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();\n        }\n    }\n    \n    // 🔧 NEW: Resolve assignee using same logic as table view\n    static resolveAssigneeName(assignee) {\n        if (!assignee) return 'Current User';\n        if (assignee === 'Current User') return 'Current User';\n        \n        // Handle user IDs (numbers) by mapping to known users\n        if (typeof assignee === 'number' || /^\\d+$/.test(assignee)) {\n            // Map known user IDs to names (from production data)\n            const userIdMap = {\n                '621623466': 'Ed Engalan',\n                // Add more user ID mappings as needed\n            };\n            return userIdMap[assignee.toString()] || 'Current User';\n        }\n        \n        // If it's already a name, return as is\n        return assignee;\n    }\n    \n    // 🔧 NEW: Capitalize first letter (same as existing logic)\n    static capitalizeFirstLetter(str) {\n        if (!str) return str;\n        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n    }\n\n    // Interactive Methods\n\n    static toggleGroup(chevron) {\n        const group = chevron.closest('.account-group');\n        const tasks = group.querySelector('.account-action-plans');\n        \n        if (tasks.style.display === 'none') {\n            tasks.style.display = 'block';\n            chevron.classList.remove('fa-chevron-right');\n            chevron.classList.add('fa-chevron-down');\n        } else {\n            tasks.style.display = 'none';\n            chevron.classList.remove('fa-chevron-down');\n            chevron.classList.add('fa-chevron-right');\n        }\n    }\n\n    static async toggleTaskComplete(taskId, completed) {\n        const taskRow = document.querySelector(`[data-task-id=\"${taskId}\"]`);\n        if (!taskRow) return;\n        \n        const actionId = taskRow.dataset.actionId;\n        \n        // Get current status before changing it\n        const statusBadge = taskRow.querySelector('.status-badge');\n        const currentStatus = statusBadge ? statusBadge.textContent.trim() : 'Pending';\n        \n        // Store previous status on the element if we haven't already\n        if (!taskRow.dataset.previousStatus && currentStatus !== 'Complete') {\n            taskRow.dataset.previousStatus = currentStatus;\n        }\n        \n        // Determine new status\n        let newStatus;\n        if (completed) {\n            newStatus = 'Complete';\n            taskRow.classList.add('action-plan-completed');\n        } else {\n            // Restore previous status or default to 'Pending'\n            newStatus = taskRow.dataset.previousStatus || 'Pending';\n            taskRow.classList.remove('action-plan-completed');\n            // Clear the stored previous status since we're back to original state\n            delete taskRow.dataset.previousStatus;\n        }\n        \n        // Update the status badge immediately for responsive UI\n        if (statusBadge) {\n            statusBadge.textContent = newStatus;\n            statusBadge.className = `status-badge ${StatusUtils.getStatusCSSClass(StatusUtils.normalizeStatusToCanonical(newStatus))}`;\n        }\n        \n        console.log(`Task ${taskId} status changing from \"${currentStatus}\" to \"${newStatus}\"`);\n        \n        // Find the action plan and update it via ActionPlanService\n        try {\n            const app = window.app;\n            if (!app) {\n                console.error('SignalsAI app instance not found');\n                return;\n            }\n            \n            // Find the plan ID associated with this task\n            let planId = null;\n            let planData = null;\n            \n            // Search through action plans to find the one containing this action\n            // Handle new single-action-per-plan data model where each plan represents one action\n            for (let [id, plan] of app.actionPlans) {\n                // Check if this plan's actionId matches the task's actionId\n                const planActionId = plan.actionId || plan.planData?.actionId;\n                \n                if (planActionId === actionId) {\n                    planId = id;\n                    planData = plan;\n                    break;\n                }\n            }\n            \n            // If we didn't find by actionId, try to find by the task ID itself (fallback)\n            if (!planId && app.actionPlans.has(taskId)) {\n                planId = taskId;\n                planData = app.actionPlans.get(taskId);\n            }\n            \n            if (planId && planData) {\n                // Update the plan's status directly (new single-action-per-plan model)\n                planData.status = newStatus;\n                \n                // Update the entire plan with the new status\n                const updateResult = await ActionPlansService.updateActionPlan(planId, {\n                    status: newStatus,\n                    updatedAt: new Date().toISOString()\n                }, app);\n                \n                if (updateResult.success) {\n                    console.log(`Successfully updated action plan status for task ${taskId} to ${newStatus}`);\n                } else {\n                    console.error('Failed to update action plan:', updateResult.error);\n                    // Revert UI changes if save failed\n                    if (completed) {\n                        taskRow.classList.remove('action-plan-completed');\n                    } else {\n                        taskRow.classList.add('action-plan-completed');\n                    }\n                    if (statusBadge) {\n                        statusBadge.textContent = currentStatus;\n                        statusBadge.className = `status-badge ${StatusUtils.getStatusCSSClass(StatusUtils.normalizeStatusToCanonical(currentStatus))}`;\n                    }\n                }\n            } else {\n                console.warn(`Could not find action plan for task ${taskId} with action ${actionId}`);\n            }\n        } catch (error) {\n            console.error('Error updating action plan status:', error);\n            // Revert UI changes if save failed\n            if (completed) {\n                taskRow.classList.remove('action-plan-completed');\n            } else {\n                taskRow.classList.add('action-plan-completed');\n            }\n            if (statusBadge) {\n                statusBadge.textContent = currentStatus;\n                statusBadge.className = `status-badge ${StatusUtils.getStatusCSSClass(StatusUtils.normalizeStatusToCanonical(currentStatus))}`;\n            }\n        }\n    }\n\n    // === MULTI-SELECT AND RIGHT-CLICK FUNCTIONALITY ===\n\n    static selectedTasks = new Set();\n\n    static handleTaskRowClick(event, taskId, actionId) {\n        // Check for Ctrl/Cmd + Click for multi-selection\n        if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            this.toggleTaskSelection(taskId);\n            return;\n        }\n\n        // Clear selection if no modifier keys\n        this.clearTaskSelection();\n        \n        // Open task details drawer (original functionality)\n        this.openTaskDetailsDrawer(taskId, actionId);\n    }\n\n    static handleTaskRightClick(event, taskId, actionId) {\n        event.preventDefault();\n        \n        // If right-clicking on a non-selected task, select only that task\n        if (!this.selectedTasks.has(taskId)) {\n            this.clearTaskSelection();\n            this.toggleTaskSelection(taskId);\n        }\n\n        this.showContextMenu(event, taskId, actionId);\n    }\n\n    static toggleTaskSelection(taskId) {\n        const taskRow = document.querySelector(`[data-task-id=\"${taskId}\"]`);\n        if (!taskRow) return;\n\n        if (this.selectedTasks.has(taskId)) {\n            this.selectedTasks.delete(taskId);\n            taskRow.classList.remove('task-selected');\n        } else {\n            this.selectedTasks.add(taskId);\n            taskRow.classList.add('task-selected');\n        }\n\n        console.log('Selected tasks:', Array.from(this.selectedTasks));\n    }\n\n    static clearTaskSelection() {\n        document.querySelectorAll('.task-row.task-selected').forEach(row => {\n            row.classList.remove('task-selected');\n        });\n        this.selectedTasks.clear();\n    }\n\n    static showContextMenu(event, taskId, actionId) {\n        // Remove existing context menu\n        this.removeContextMenu();\n\n        const menu = document.createElement('div');\n        menu.id = 'taskContextMenu';\n        menu.className = 'task-context-menu';\n        \n        const selectedCount = this.selectedTasks.size;\n        const menuText = selectedCount > 1 ? `Delete ${selectedCount} Tasks` : 'Delete Task';\n        const iconClass = selectedCount > 1 ? 'fa-trash-alt' : 'fa-trash';\n        \n        menu.innerHTML = `\n            <div class=\"context-menu-item\" onclick=\"ActionsRenderer.confirmDeleteTasks()\">\n                <i class=\"fas ${iconClass}\"></i>\n                <span>${menuText}</span>\n            </div>\n        `;\n\n        // Position the menu at cursor\n        menu.style.left = event.pageX + 'px';\n        menu.style.top = event.pageY + 'px';\n\n        document.body.appendChild(menu);\n\n        // Close menu when clicking elsewhere\n        setTimeout(() => {\n            document.addEventListener('click', this.removeContextMenu, { once: true });\n        }, 10);\n    }\n\n    static removeContextMenu() {\n        const menu = document.getElementById('taskContextMenu');\n        if (menu) {\n            menu.remove();\n        }\n    }\n\n    static confirmDeleteTasks() {\n        this.removeContextMenu();\n        \n        const selectedCount = this.selectedTasks.size;\n        if (selectedCount === 0) return;\n\n        this.showDeleteConfirmationModal(selectedCount);\n    }\n\n    static showDeleteConfirmationModal(taskCount) {\n        // Remove existing modal if present\n        this.removeDeleteModal();\n\n        const modal = document.createElement('div');\n        modal.id = 'deleteConfirmationModal';\n        modal.className = 'delete-confirmation-modal';\n\n        const taskText = taskCount === 1 ? 'task' : 'tasks';\n        const deleteText = taskCount === 1 ? 'this task' : `these ${taskCount} tasks`;\n\n        modal.innerHTML = `\n            <div class=\"delete-modal-backdrop\" onclick=\"ActionsRenderer.removeDeleteModal()\"></div>\n            <div class=\"delete-modal-content\">\n                <div class=\"delete-modal-header\">\n                    <div class=\"delete-modal-icon\">\n                        <i class=\"fas fa-exclamation-triangle\"></i>\n                    </div>\n                    <h3 class=\"delete-modal-title\">Delete ${taskText.charAt(0).toUpperCase() + taskText.slice(1)}</h3>\n                </div>\n                \n                <div class=\"delete-modal-body\">\n                    <p>Are you sure you want to delete ${deleteText}? This action cannot be undone.</p>\n                    ${taskCount > 1 ? `<p class=\"delete-task-count\">${taskCount} ${taskText} will be permanently removed.</p>` : ''}\n                </div>\n                \n                <div class=\"delete-modal-footer\">\n                    <button class=\"btn btn-secondary delete-cancel-btn\" onclick=\"ActionsRenderer.removeDeleteModal()\">\n                        Cancel\n                    </button>\n                    <button class=\"btn btn-danger delete-confirm-btn\" onclick=\"ActionsRenderer.executeTaskDeletion()\">\n                        <i class=\"fas fa-trash\"></i> Delete ${taskText.charAt(0).toUpperCase() + taskText.slice(1)}\n                    </button>\n                </div>\n            </div>\n        `;\n\n        document.body.appendChild(modal);\n\n        // Animate in\n        setTimeout(() => {\n            modal.classList.add('show');\n        }, 10);\n    }\n\n    static removeDeleteModal() {\n        const modal = document.getElementById('deleteConfirmationModal');\n        if (modal) {\n            modal.classList.remove('show');\n            setTimeout(() => {\n                if (modal.parentNode) {\n                    modal.remove();\n                }\n            }, 200);\n        }\n    }\n\n    static async executeTaskDeletion() {\n        const selectedTaskIds = Array.from(this.selectedTasks);\n        \n        if (selectedTaskIds.length === 0) {\n            this.removeDeleteModal();\n            return;\n        }\n\n        // Close the confirmation modal\n        this.removeDeleteModal();\n\n        try {\n            // Group tasks by account/plan for efficient processing\n            const tasksByPlan = {};\n            \n            for (const taskId of selectedTaskIds) {\n                // Parse the task ID to get account and task index (e.g., \"0013000000DXZ1fAAH-1\")\n                const [accountId, taskIndex] = taskId.split('-');\n                \n                if (!tasksByPlan[accountId]) {\n                    tasksByPlan[accountId] = [];\n                }\n                tasksByPlan[accountId].push({\n                    taskId: taskId,\n                    taskIndex: parseInt(taskIndex)\n                });\n            }\n\n            let deletedCount = 0;\n            \n            // Process each action plan\n            for (const [accountId, tasksToDelete] of Object.entries(tasksByPlan)) {\n                try {\n                    // Get the action plan for this account\n                    const planData = window.app.actionPlans.get(accountId);\n                    \n                    if (!planData || !planData.actionItems) {\n                        console.warn(`Could not find action plan for account: ${accountId}`);\n                        continue;\n                    }\n\n                    // Sort tasks by index in descending order to avoid index shifting during deletion\n                    const sortedTasks = tasksToDelete.sort((a, b) => b.taskIndex - a.taskIndex);\n                    \n                    // Create a copy of action items and remove the selected ones by index\n                    const updatedActionItems = [...planData.actionItems];\n                    \n                    for (const task of sortedTasks) {\n                        if (task.taskIndex >= 0 && task.taskIndex < updatedActionItems.length) {\n                            updatedActionItems.splice(task.taskIndex, 1);\n                            deletedCount++;\n                        }\n                    }\n\n                    // Update the action plan with reduced tasks using CRUD methods\n                    const updatedPlanData = {\n                        ...planData,\n                        actionItems: updatedActionItems,\n                        updatedAt: new Date()\n                    };\n\n                    // Use ActionPlanService CRUD to update the plan\n                    const result = await ActionPlansService.updateActionPlan(planData.id, updatedPlanData, window.app);\n                    \n                    if (result && result.success) {\n                        console.log(`Successfully deleted ${sortedTasks.length} tasks from action plan ${planData.id}`);\n                        \n                        // Update the local data immediately for UI consistency\n                        window.app.actionPlans.set(accountId, result.plan || updatedPlanData);\n                    } else {\n                        console.error(`Failed to update action plan ${planData.id}:`, result ? result.error : 'No response');\n                        // Revert the deleted count for failed operations\n                        deletedCount -= sortedTasks.length;\n                    }\n                    \n                } catch (error) {\n                    console.error(`Error deleting tasks from account ${accountId}:`, error);\n                }\n            }\n\n            // Clear selection\n            this.clearTaskSelection();\n            \n            // Show appropriate notification and refresh\n            if (deletedCount > 0) {\n                const taskText = deletedCount === 1 ? 'task' : 'tasks';\n                window.app.showSuccessMessage(`Successfully deleted ${deletedCount} ${taskText}`);\n                \n                // Refresh the Action Plans view to show updated data\n                console.log('Refreshing Action Plans view after task deletion');\n                window.app.renderCurrentTab();\n            } else {\n                window.app.showErrorMessage('Failed to delete tasks. Please try again.');\n            }\n\n        } catch (error) {\n            console.error('Error during task deletion:', error);\n            window.app.showErrorMessage('An error occurred while deleting tasks');\n            this.clearTaskSelection();\n        }\n    }\n\n    static async findActionPlanContainingTask(actionId, app) {\n        // Search through action plans to find the one containing this actionId\n        for (let [accountId, planData] of app.actionPlans) {\n            if (planData.actionItems) {\n                const foundItem = planData.actionItems.find(item => item.id === actionId);\n                if (foundItem) {\n                    return {\n                        accountId: accountId,\n                        planData: planData,\n                        actionItem: foundItem\n                    };\n                }\n            }\n        }\n        return null;\n    }\n\n    static openPlaysModal(actionId, taskTitle) {\n        console.log(`Opening plays modal for action ${actionId}: ${taskTitle}`);\n        \n        // Find the action item with this actionId to get its plays\n        const actionPlan = this.findActionPlanWithActionId(actionId, window.app);\n        if (!actionPlan) {\n            console.error('Could not find action plan for actionId:', actionId);\n            return;\n        }\n        \n        this.openPlaysDrawer(actionId, taskTitle, actionPlan.actionItem, actionPlan.planData);\n    }\n    \n    static findActionPlanWithActionId(actionId, app) {\n        // Search through action plans to find the action item with this actionId\n        for (let [accountId, planData] of app.actionPlans) {\n            if (planData.actionItems) {\n                const actionItem = planData.actionItems.find(item => {\n                    return item.actionId === actionId || (typeof item === 'object' && item.actionId === actionId);\n                });\n                if (actionItem) {\n                    return { actionItem, planData, accountId };\n                }\n            }\n        }\n        \n        // If not found in live data, search fallback data\n        return this.findInFallbackData(actionId, app);\n    }\n    \n    static async findInFallbackData(actionId, app) {\n        try {\n            const response = await fetch('/action-plans-fallback.json');\n            const fallbackData = await response.json();\n            \n            for (const record of fallbackData) {\n                const planContent = record.content;\n                if (planContent && planContent.actionItems) {\n                    const actionItem = planContent.actionItems.find(item => item.actionId === actionId);\n                    if (actionItem) {\n                        return { actionItem, planData: planContent, accountId: planContent.accountId };\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error searching fallback data:', error);\n        }\n        return null;\n    }\n    \n    static openPlaysDrawer(actionId, taskTitle, actionItem, planData) {\n        console.log('Opening plays drawer for:', { actionId, taskTitle, actionItem });\n        \n        // Get or create drawer elements\n        let drawer = document.getElementById('playsDrawer');\n        let backdrop = document.getElementById('playsDrawerBackdrop');\n        \n        if (!drawer) {\n            this.createPlaysDrawerHTML();\n            drawer = document.getElementById('playsDrawer');\n            backdrop = document.getElementById('playsDrawerBackdrop');\n        }\n        \n        // Populate drawer content\n        this.populatePlaysDrawer(actionId, taskTitle, actionItem, planData);\n        \n        // Show drawer\n        if (drawer && backdrop) {\n            backdrop.classList.add('open');\n            setTimeout(() => {\n                drawer.classList.add('open');\n            }, 10);\n        }\n    }\n    \n    static createPlaysDrawerHTML() {\n        const drawerHTML = `\n            <!-- Plays Drawer Backdrop -->\n            <div id=\"playsDrawerBackdrop\" class=\"drawer-backdrop\" onclick=\"ActionsRenderer.closePlaysDrawer()\"></div>\n            \n            <!-- Plays Drawer -->\n            <div id=\"playsDrawer\" class=\"drawer plays-drawer\">\n                <div class=\"drawer-header\">\n                    <h2><i class=\"fas fa-play-circle\"></i> Manage CS Plays</h2>\n                    <button class=\"drawer-close-btn\" onclick=\"ActionsRenderer.closePlaysDrawer()\">\n                        <i class=\"fas fa-times\"></i>\n                    </button>\n                </div>\n                \n                <div class=\"drawer-body\">\n                    <div id=\"playsDrawerContent\">\n                        <!-- Content will be populated here -->\n                    </div>\n                </div>\n                \n                <div class=\"drawer-footer\">\n                    <button class=\"btn btn-secondary\" onclick=\"ActionsRenderer.closePlaysDrawer()\">Close</button>\n                    <button class=\"btn btn-primary\" onclick=\"ActionsRenderer.savePlayUpdates()\">\n                        <i class=\"fas fa-save\"></i> Save Updates\n                    </button>\n                </div>\n            </div>\n        `;\n        \n        // Add to body if not exists\n        if (!document.getElementById('playsDrawer')) {\n            document.body.insertAdjacentHTML('beforeend', drawerHTML);\n        }\n    }\n    \n    static populatePlaysDrawer(actionId, taskTitle, actionItem, planData) {\n        const container = document.getElementById('playsDrawerContent');\n        if (!container) return;\n        \n        const plays = actionItem.plays || [];\n        console.log('Populating drawer with plays:', plays);\n        \n        let html = `\n            <div class=\"plays-drawer-section\">\n                <h3><i class=\"fas fa-lightbulb\"></i> Action Plan Task</h3>\n                <div class=\"action-task-card\">\n                    <div class=\"action-task-title\">${taskTitle}</div>\n                    <div class=\"action-task-meta\">\n                        <span class=\"action-id-badge\">ID: ${actionId}</span>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"plays-drawer-section\">\n                <div class=\"subtasks-header\">\n                    <h3><i class=\"fas fa-tasks\"></i> Subtasks & Plays</h3>\n                    <div class=\"subtasks-progress\">\n                        <div class=\"progress-info\">\n                            <span class=\"completed-count\">${plays.filter(p => p.status === 'complete').length}</span>\n                            <span class=\"total-count\">of ${plays.length} completed</span>\n                        </div>\n                        <div class=\"progress-bar\">\n                            <div class=\"progress-fill\" style=\"width: ${plays.length > 0 ? Math.round((plays.filter(p => p.status === 'complete').length / plays.length) * 100) : 0}%\"></div>\n                        </div>\n                        <span class=\"progress-percentage\">${plays.length > 0 ? Math.round((plays.filter(p => p.status === 'complete').length / plays.length) * 100) : 0}%</span>\n                    </div>\n                </div>\n                \n                <div class=\"subtasks-list\">\n        `;\n        \n        if (plays.length === 0) {\n            html += `\n                <div class=\"no-subtasks-message\">\n                    <div class=\"empty-state\">\n                        <i class=\"fas fa-tasks empty-state-icon\"></i>\n                        <div class=\"empty-state-title\">No subtasks defined</div>\n                        <div class=\"empty-state-description\">This action plan doesn't have any associated plays or subtasks yet.</div>\n                    </div>\n                </div>\n            `;\n        } else {\n            plays.forEach((play, index) => {\n                // Handle both string plays and enhanced object plays\n                const playTitle = typeof play === 'string' ? play : (play.name || play.playTitle || play.playName || `Play ${index + 1}`);\n                const playId = typeof play === 'string' ? `play_${index + 1}` : (play.id || play.playId || `play_${index + 1}`);\n                const playDescription = typeof play === 'string' ? '' : (play.description || play.full_description || '');\n                \n                // 🎯 Enhanced task management fields\n                const status = play.status || 'pending';\n                const priority = play.priority || 'medium';\n                const dueDate = play.dueDate || '';\n                const assignee = play.assignee || play.executing_role || '';\n                \n                // Status and priority styling\n                const statusClass = status.replace('-', '');\n                const priorityClass = priority.toLowerCase();\n                const isCompleted = status === 'complete';\n                const isOverdue = dueDate && new Date(dueDate) < new Date() && !isCompleted;\n                \n                // Status icon mapping\n                const statusIcon = {\n                    'pending': '📋',\n                    'in-progress': '🔄', \n                    'complete': '✅',\n                    'cancelled': '❌',\n                    'on-hold': '⏸️'\n                }[status] || '📋';\n                \n                html += `\n                    <div class=\"subtask-card ${statusClass} ${isOverdue ? 'overdue' : ''}\" \n                         data-action-id=\"${actionId}\" \n                         data-play-id=\"${playId}\" \n                         data-play-index=\"${index}\">\n                        \n                        <div class=\"subtask-main\">\n                            <div class=\"subtask-status-indicator\">\n                                <span class=\"status-icon\">${statusIcon}</span>\n                            </div>\n                            \n                            <div class=\"subtask-content\">\n                                <div class=\"subtask-title-row\">\n                                    <div class=\"subtask-title ${isCompleted ? 'completed' : ''}\" data-title=\"${playTitle}\"></div>\n                                    <div class=\"subtask-badges\">\n                                        <span class=\"priority-badge priority-${priorityClass}\" title=\"${priority.charAt(0).toUpperCase() + priority.slice(1)} Priority\">\n                                            ${priority === 'high' ? '🔴' : priority === 'medium' ? '🟡' : '🟢'}\n                                        </span>\n                                        <span class=\"play-id-badge\" title=\"Play ID\">${playId}</span>\n                                    </div>\n                                </div>\n                                \n                                ${playDescription ? `<div class=\"subtask-description\" data-description=\"${playDescription}\"></div>` : ''}\n                                \n                                <div class=\"subtask-meta\">\n                                    ${assignee ? `\n                                        <div class=\"subtask-assignee\">\n                                            <i class=\"fas fa-user-circle\"></i>\n                                            <span class=\"assignee-name\">${assignee}</span>\n                                        </div>\n                                    ` : ''}\n                                    \n                                    ${dueDate ? `\n                                        <div class=\"subtask-due-date ${isOverdue ? 'overdue' : ''}\">\n                                            <i class=\"fas fa-calendar-alt\"></i>\n                                            <span class=\"due-date-text\">${ActionsRenderer.formatDueDate(dueDate)}</span>\n                                        </div>\n                                    ` : ''}\n                                </div>\n                            </div>\n                        </div>\n                        \n                        <div class=\"subtask-controls\">\n                            <div class=\"subtask-control-row\">\n                                <div class=\"control-group compact\">\n                                    <select class=\"subtask-status-select\" \n                                            data-play-id=\"${playId}\" \n                                            data-action-id=\"${actionId}\"\n                                            onchange=\"ActionsRenderer.updatePlayStatus('${actionId}', '${playId}', this.value)\"\n                                            title=\"Change Status\">\n                                        <option value=\"pending\" ${status === 'pending' ? 'selected' : ''}>Pending</option>\n                                        <option value=\"in-progress\" ${status === 'in-progress' ? 'selected' : ''}>In Progress</option>\n                                        <option value=\"complete\" ${status === 'complete' ? 'selected' : ''}>Complete</option>\n                                        <option value=\"cancelled\" ${status === 'cancelled' ? 'selected' : ''}>Cancelled</option>\n                                        <option value=\"on-hold\" ${status === 'on-hold' ? 'selected' : ''}>On Hold</option>\n                                    </select>\n                                </div>\n                                \n                                <div class=\"control-group compact\">\n                                    <select class=\"subtask-priority-select\" \n                                            data-play-id=\"${playId}\" \n                                            data-action-id=\"${actionId}\"\n                                            onchange=\"ActionsRenderer.updatePlayPriority('${actionId}', '${playId}', this.value)\"\n                                            title=\"Change Priority\">\n                                        <option value=\"low\" ${priority === 'low' ? 'selected' : ''}>Low</option>\n                                        <option value=\"medium\" ${priority === 'medium' ? 'selected' : ''}>Medium</option>\n                                        <option value=\"high\" ${priority === 'high' ? 'selected' : ''}>High</option>\n                                    </select>\n                                </div>\n                                \n                                <div class=\"control-group compact\">\n                                    <input type=\"date\" \n                                           class=\"subtask-due-date-input\" \n                                           data-play-id=\"${playId}\" \n                                           data-action-id=\"${actionId}\"\n                                           value=\"${dueDate}\"\n                                           onchange=\"ActionsRenderer.updatePlayDueDate('${actionId}', '${playId}', this.value)\"\n                                           title=\"Set Due Date\">\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                `;\n            });\n        }\n        \n        html += `\n                </div>\n            </div>\n        `;\n        \n        container.innerHTML = html;\n    }\n    \n    static closePlaysDrawer() {\n        const drawer = document.getElementById('playsDrawer');\n        const backdrop = document.getElementById('playsDrawerBackdrop');\n        \n        if (drawer) {\n            drawer.classList.remove('open');\n        }\n        \n        if (backdrop) {\n            setTimeout(() => {\n                backdrop.classList.remove('open');\n            }, 300);\n        }\n    }\n    \n    static togglePlayCompletion(actionId, playId, playIndex, isCompleted) {\n        console.log(`Toggle play completion: actionId=${actionId}, playId=${playId}, index=${playIndex}, completed=${isCompleted}`);\n        \n        // Update the visual state immediately\n        const playItem = document.querySelector(`[data-action-id=\"${actionId}\"][data-play-index=\"${playIndex}\"]`);\n        \n        if (!playItem) {\n            console.warn(`Could not find play item with actionId=${actionId} and playIndex=${playIndex}`);\n            // Continue with data update even if visual update fails\n        } else {\n            const playTitle = playItem.querySelector('.play-title');\n            const statusBadge = playItem.querySelector('.status-badge');\n            \n            if (playTitle && statusBadge) {\n                if (isCompleted) {\n                    playTitle.classList.add('completed');\n                    statusBadge.textContent = 'Completed';\n                    statusBadge.className = 'status-badge completed';\n                } else {\n                    playTitle.classList.remove('completed');\n                    statusBadge.textContent = 'Pending';\n                    statusBadge.className = 'status-badge pending';\n                }\n            }\n        }\n        \n        // Store the update for later saving\n        if (!window.playUpdates) {\n            window.playUpdates = new Map();\n        }\n        \n        if (!window.playUpdates.has(actionId)) {\n            window.playUpdates.set(actionId, new Map());\n        }\n        \n        window.playUpdates.get(actionId).set(playId, {\n            playIndex: playIndex,\n            completed: isCompleted,\n            timestamp: new Date().toISOString()\n        });\n        \n        console.log('Stored play update:', window.playUpdates.get(actionId).get(playId));\n    }\n    \n    static async savePlayUpdates() {\n        if (!window.playUpdates || window.playUpdates.size === 0) {\n            this.closePlaysDrawer();\n            return;\n        }\n        \n        console.log('Saving play updates:', window.playUpdates);\n        \n        try {\n            // Update action plans data with play completion status\n            for (let [actionId, playUpdates] of window.playUpdates) {\n                await this.updateActionPlanPlayStatus(actionId, playUpdates);\n            }\n            \n            // Clear updates and refresh the Action Plans view\n            window.playUpdates.clear();\n            this.closePlaysDrawer();\n            \n            // Refresh the Action Plans view to show updated play counts\n            if (window.app && typeof window.app.renderActions === 'function') {\n                window.app.renderActions();\n            }\n            \n            // Show success message\n            this.showPlayUpdateSuccess();\n            \n        } catch (error) {\n            console.error('Error saving play updates:', error);\n            this.showPlayUpdateError(error.message);\n        }\n    }\n    \n    // ========== ENHANCED PLAY TASK MANAGEMENT METHODS ==========\n    \n    /**\n     * Update the status of a specific play\n     */\n    static async updatePlayStatus(actionId, playId, status) {\n        try {\n            console.log(`🎯 Updating play ${playId} status to: ${status}`);\n            \n            // Get the current action plan ID (we need the plan ID, not action ID)\n            const planId = await this.findPlanIdForAction(actionId);\n            if (!planId) {\n                throw new Error(`Could not find plan for action: ${actionId}`);\n            }\n            \n            // Use the new repository method\n            const result = await window.SignalsRepository.updatePlayStatus(planId, playId, status);\n            \n            if (result.success) {\n                // Update visual state immediately\n                this.updatePlayVisualState(actionId, playId, 'status', status);\n                \n                // Show success notification\n                this.showNotification('Play status updated successfully', 'success');\n                \n                // Refresh the action plans view\n                if (window.app && typeof window.app.renderActions === 'function') {\n                    window.app.renderActions();\n                }\n                \n                console.log(`✅ Play ${playId} status updated to: ${status}`);\n            } else {\n                throw new Error(result.error || 'Failed to update play status');\n            }\n            \n        } catch (error) {\n            console.error('❌ Failed to update play status:', error);\n            this.showNotification('Failed to update play status: ' + error.message, 'error');\n        }\n    }\n    \n    /**\n     * Update the priority of a specific play\n     */\n    static async updatePlayPriority(actionId, playId, priority) {\n        try {\n            console.log(`🎯 Updating play ${playId} priority to: ${priority}`);\n            \n            const planId = await this.findPlanIdForAction(actionId);\n            if (!planId) {\n                throw new Error(`Could not find plan for action: ${actionId}`);\n            }\n            \n            const result = await window.SignalsRepository.updatePlayPriority(planId, playId, priority);\n            \n            if (result.success) {\n                this.updatePlayVisualState(actionId, playId, 'priority', priority);\n                this.showNotification('Play priority updated successfully', 'success');\n                \n                if (window.app && typeof window.app.renderActions === 'function') {\n                    window.app.renderActions();\n                }\n                \n                console.log(`✅ Play ${playId} priority updated to: ${priority}`);\n            } else {\n                throw new Error(result.error || 'Failed to update play priority');\n            }\n            \n        } catch (error) {\n            console.error('❌ Failed to update play priority:', error);\n            this.showNotification('Failed to update play priority: ' + error.message, 'error');\n        }\n    }\n    \n    /**\n     * Update the due date of a specific play\n     */\n    static async updatePlayDueDate(actionId, playId, dueDate) {\n        try {\n            console.log(`🎯 Updating play ${playId} due date to: ${dueDate}`);\n            \n            const planId = await this.findPlanIdForAction(actionId);\n            if (!planId) {\n                throw new Error(`Could not find plan for action: ${actionId}`);\n            }\n            \n            const result = await window.SignalsRepository.updatePlayDueDate(planId, playId, dueDate);\n            \n            if (result.success) {\n                this.updatePlayVisualState(actionId, playId, 'dueDate', dueDate);\n                this.showNotification('Play due date updated successfully', 'success');\n                \n                if (window.app && typeof window.app.renderActions === 'function') {\n                    window.app.renderActions();\n                }\n                \n                console.log(`✅ Play ${playId} due date updated to: ${dueDate}`);\n            } else {\n                throw new Error(result.error || 'Failed to update play due date');\n            }\n            \n        } catch (error) {\n            console.error('❌ Failed to update play due date:', error);\n            this.showNotification('Failed to update play due date: ' + error.message, 'error');\n        }\n    }\n    \n    /**\n     * Helper method to find plan ID for a given action ID\n     */\n    static async findPlanIdForAction(actionId) {\n        try {\n            if (window.signalsStore) {\n                const state = window.signalsStore.getState();\n                if (state.actionPlans) {\n                    for (let [planId, plan] of state.actionPlans) {\n                        if (plan.actionId === actionId) {\n                            return planId;\n                        }\n                    }\n                }\n            }\n            return null;\n        } catch (error) {\n            console.error('Error finding plan ID for action:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Update visual state of a play item immediately\n     */\n    static updatePlayVisualState(actionId, playId, property, value) {\n        try {\n            const playItem = document.querySelector(`[data-action-id=\"${actionId}\"][data-play-id=\"${playId}\"]`);\n            if (!playItem) return;\n            \n            if (property === 'status') {\n                const statusSelect = playItem.querySelector('.play-status-select');\n                const statusBadge = playItem.querySelector('.status-badge');\n                const playTitle = playItem.querySelector('.play-title');\n                \n                if (statusSelect) statusSelect.value = value;\n                if (statusBadge) {\n                    statusBadge.textContent = this.getStatusDisplayText(value);\n                    statusBadge.className = `status-badge ${value.replace('-', '')}`;\n                }\n                if (playTitle) {\n                    if (value === 'complete') {\n                        playTitle.classList.add('completed');\n                    } else {\n                        playTitle.classList.remove('completed');\n                    }\n                }\n            } else if (property === 'priority') {\n                const prioritySelect = playItem.querySelector('.play-priority-select');\n                const priorityBadge = playItem.querySelector('.priority-badge');\n                \n                if (prioritySelect) prioritySelect.value = value;\n                if (priorityBadge) {\n                    priorityBadge.textContent = value.toUpperCase();\n                    priorityBadge.className = `priority-badge ${value.toLowerCase()}`;\n                }\n            } else if (property === 'dueDate') {\n                const dueDateInput = playItem.querySelector('.play-due-date-input');\n                const dueDateBadge = playItem.querySelector('.due-date-badge');\n                \n                if (dueDateInput) dueDateInput.value = value;\n                if (dueDateBadge) {\n                    if (value) {\n                        dueDateBadge.innerHTML = `<i class=\"fas fa-calendar\"></i> ${this.formatDueDate(value)}`;\n                        dueDateBadge.style.display = 'inline-block';\n                    } else {\n                        dueDateBadge.style.display = 'none';\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error updating play visual state:', error);\n        }\n    }\n    \n    /**\n     * Get display text for status values\n     */\n    static getStatusDisplayText(status) {\n        const statusMap = {\n            'pending': 'Pending',\n            'in-progress': 'In Progress',\n            'complete': 'Complete',\n            'cancelled': 'Cancelled',\n            'on-hold': 'On Hold'\n        };\n        return statusMap[status] || status;\n    }\n    \n    /**\n     * Format due date for display\n     */\n    static formatDueDate(dueDate) {\n        if (!dueDate) return '';\n        \n        try {\n            const date = new Date(dueDate);\n            const today = new Date();\n            const diffTime = date - today;\n            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n            \n            if (diffDays < 0) {\n                return `${Math.abs(diffDays)} day(s) overdue`;\n            } else if (diffDays === 0) {\n                return 'Due today';\n            } else if (diffDays === 1) {\n                return 'Due tomorrow';\n            } else {\n                return `Due in ${diffDays} day(s)`;\n            }\n        } catch (error) {\n            return dueDate; // Fallback to raw date\n        }\n    }\n    \n    /**\n     * Show notification to user\n     */\n    static showNotification(message, type = 'info') {\n        if (window.Actions && window.Actions.showMessage) {\n            window.Actions.showMessage(message, type);\n        } else {\n            console.log(`${type.toUpperCase()}: ${message}`);\n        }\n    }\n\n    static async updateActionPlanPlayStatus(actionId, playUpdates) {\n        // Find and update the action plan data\n        const app = window.app;\n        \n        // Update in live action plans\n        for (let [accountId, planData] of app.actionPlans) {\n            if (planData.actionItems) {\n                const actionItem = planData.actionItems.find(item => item.actionId === actionId);\n                if (actionItem && actionItem.plays) {\n                    for (let [playId, updateData] of playUpdates) {\n                        const playIndex = updateData.playIndex;\n                        if (actionItem.plays[playIndex]) {\n                            actionItem.plays[playIndex].completed = updateData.completed;\n                            actionItem.plays[playIndex].lastUpdated = updateData.timestamp;\n                        }\n                    }\n                    return; // Found and updated\n                }\n            }\n        }\n        \n        console.log(`Action plan for actionId ${actionId} updated with play completion status`);\n    }\n    \n    static showPlayUpdateSuccess() {\n        const message = document.createElement('div');\n        message.className = 'update-notification success';\n        message.innerHTML = `\n            <i class=\"fas fa-check-circle\"></i>\n            Play completion status updated successfully!\n        `;\n        document.body.appendChild(message);\n        \n        setTimeout(() => {\n            message.classList.add('show');\n            setTimeout(() => {\n                message.classList.remove('show');\n                setTimeout(() => message.remove(), 300);\n            }, 3000);\n        }, 100);\n    }\n    \n    static showPlayUpdateError(errorMessage) {\n        const message = document.createElement('div');\n        message.className = 'update-notification error';\n        message.innerHTML = `\n            <i class=\"fas fa-exclamation-circle\"></i>\n            Error updating plays: ${errorMessage}\n        `;\n        document.body.appendChild(message);\n        \n        setTimeout(() => {\n            message.classList.add('show');\n            setTimeout(() => {\n                message.classList.remove('show');\n                setTimeout(() => message.remove(), 300);\n            }, 5000);\n        }, 100);\n    }\n    \n    // Task Details Drawer Methods\n    static async openTaskDetailsDrawer(taskId, actionId) {\n        console.log(`Opening task details drawer for taskId: ${taskId}, actionId: ${actionId}`);\n        \n        try {\n            // 🔧 CRITICAL FIX: Use same state object as rendering to ensure cached action plans are available\n            const state = window.signalsStore.getState();\n            const actionPlanData = await this.findTaskData(taskId, actionId, state); \n            if (!actionPlanData) {\n                console.error('Could not find task data for:', { taskId, actionId });\n                this.showTaskUpdateError('Task data not found');\n                return;\n            }\n            \n            console.log('Found action plan data:', actionPlanData);\n            \n            // Create or get drawer elements\n            let drawer = document.getElementById('taskDetailsDrawer');\n            let backdrop = document.getElementById('taskDetailsDrawerBackdrop');\n            \n            if (!drawer) {\n                this.createTaskDetailsDrawerHTML();\n                drawer = document.getElementById('taskDetailsDrawer');\n                backdrop = document.getElementById('taskDetailsDrawerBackdrop');\n            }\n            \n            // Populate drawer content\n            this.populateTaskDetailsDrawer(actionPlanData);\n            \n            // Show drawer\n            if (drawer && backdrop) {\n                backdrop.classList.add('open');\n                setTimeout(() => {\n                    drawer.classList.add('open');\n                }, 10);\n            }\n        } catch (error) {\n            console.error('Error opening task details drawer:', error);\n            this.showTaskUpdateError('Failed to open task details');\n        }\n    }\n    \n    static createTaskDetailsDrawerHTML() {\n        const drawerHTML = `\n            <!-- Task Details Drawer Backdrop -->\n            <div id=\"taskDetailsDrawerBackdrop\" class=\"drawer-backdrop\" onclick=\"ActionsRenderer.closeTaskDetailsDrawer()\"></div>\n            \n            <!-- Task Details Drawer -->\n            <div id=\"taskDetailsDrawer\" class=\"drawer task-details-drawer\">\n                <div class=\"drawer-header\">\n                    <h2><i class=\"fas fa-tasks\"></i> Task Details</h2>\n                    <button class=\"drawer-close-btn\" onclick=\"ActionsRenderer.closeTaskDetailsDrawer()\">\n                        <i class=\"fas fa-times\"></i>\n                    </button>\n                </div>\n                \n                <div class=\"drawer-body\">\n                    <div id=\"taskDetailsContent\">\n                        <!-- Content will be populated here -->\n                    </div>\n                </div>\n                \n                <div class=\"drawer-footer\">\n                    <button class=\"btn btn-primary\" onclick=\"ActionsRenderer.closeTaskDetailsDrawer()\">\n                        <i class=\"fas fa-times\"></i> Close\n                    </button>\n                </div>\n            </div>\n        `;\n        \n        // Add to body if not exists\n        if (!document.getElementById('taskDetailsDrawer')) {\n            document.body.insertAdjacentHTML('beforeend', drawerHTML);\n        }\n    }\n    \n    static async findTaskData(taskId, actionId, app) {\n        // 🔧 PRODUCTION FIX: Use cached action plans from app state if available\n        console.log('🔍 [FIXED] Finding task using correct plan structure:', { taskId, actionId });\n        \n        // First try to use cached action plans from app state  \n        let formattedActionPlans = [];\n        if (app.actionPlans && app.actionPlans.size > 0) {\n            console.log('🎯 Using cached action plans from app state for modal');\n            \n            // Convert cached app.actionPlans Map to formatted structure\n            for (let [planId, planData] of app.actionPlans) {\n                const accountId = planData.accountId;\n                const account = (app.accounts && app.accounts.get) ? app.accounts.get(accountId) : null;\n                \n                formattedActionPlans.push({\n                    accountId: accountId,\n                    accountName: account?.name || planData.accountName || `Account ${accountId}`,\n                    planData: { ...planData, id: planId }\n                });\n            }\n        } else {\n            // Fallback: Try to fetch action plans (will fail in production without fallback file)\n            console.log('⚠️ No cached action plans, attempting to fetch (likely to fail in production)');\n            formattedActionPlans = await this.getFormattedActionPlans(app);\n        }\n        \n        console.log('🔍 [FIXED] Using plans for modal:', formattedActionPlans.map(p => ({ \n            planDataId: p.planData?.id, \n            actionId: p.planData?.actionId, \n            accountId: p.accountId \n        })));\n        \n        // Find the specific task by matching the plan data structure\n        for (const plan of formattedActionPlans) {\n            const planDataId = plan.planData?.id;\n            const planActionId = plan.planData?.actionId;\n            \n            if (planDataId === taskId && planActionId === actionId) {\n                console.log('🔍 [FIXED] Found matching task:', plan);\n                \n                // Create action item structure from the plan data\n                const actionItem = {\n                    title: plan.planData.title || plan.planData.planTitle || 'Untitled Action',\n                    actionId: plan.planData.actionId,\n                    status: plan.planData.status || 'pending',\n                    priority: plan.planData.priority || 'Medium',\n                    dueDate: plan.planData.dueDate,\n                    plays: plan.planData.plays || []\n                };\n                \n                // Use the plan data directly\n                const planData = {\n                    ...plan.planData,\n                    id: plan.planData.id,\n                    accountId: plan.accountId,\n                    assignee: plan.planData.assignee || plan.planData.createdBy || 'Current User'\n                };\n                \n                return {\n                    taskId,\n                    actionId,\n                    actionItem,\n                    planData,\n                    accountId: plan.accountId\n                };\n            }\n        }\n        \n        console.error('🔍 [FIXED] Task not found in formatted plans:', { taskId, actionId });\n        console.log('🔍 [FIXED] Available task/action IDs:', formattedActionPlans.map(p => ({ \n            planId: p.planData?.id, \n            actionId: p.planData?.actionId \n        })));\n        return null;\n    }\n    \n    // 🧹 CLEANED UP: Removed complex fallback functions - now using simple grid data source\n    \n    static populateTaskDetailsDrawer(actionPlanData) {\n        const container = document.getElementById('taskDetailsContent');\n        if (!container) return;\n        \n        console.log('Populating action plan details drawer with data:', actionPlanData);\n        \n        const { taskId, actionId, actionItem, planData } = actionPlanData;\n        \n        // Store globally for auto-save functions with canonical planId\n        window.currentActionPlanData = {\n            ...actionPlanData,\n            planId: actionPlanData.planData.id // Canonical plan ID for auto-save\n        };\n        \n        // Safely access plays with fallback - handle both string and object actionItem\n        const plays = (typeof actionItem === 'object' && actionItem.plays) ? actionItem.plays : [];\n        \n        console.log('🔍 [MAPPING] Action item:', actionItem);\n        console.log('🔍 [MAPPING] Plan data:', planData);\n        console.log('🔍 [MAPPING] Plays found:', plays);\n        \n        // Use the actual action title, handle both string and object cases\n        const actionTitle = typeof actionItem === 'string' ? actionItem : (actionItem.title || actionItem.name || 'Action Details');\n        \n        // 🔧 FIXED: Apply consistent field mapping like the table view\n        const currentTitle = actionItem.title || 'No Title';\n        const currentStatus = this.normalizeStatusToCanonical(actionItem.status || 'pending');\n        \n        // Get current plan details (description)\n        const currentPlanDetails = planData.description || '';\n        \n        // 🔧 FIXED: Format due date consistently \n        const currentDueDate = actionItem.dueDate ? new Date(actionItem.dueDate).toISOString().split('T')[0] : '';\n        const currentPriority = this.capitalizeFirstLetter(actionItem.priority || 'Medium');\n        const accountId = planData.accountId || actionPlanData.accountId;\n        \n        console.log('🔍 [MAPPING] Extracted values (FIXED):', {\n            currentTitle,\n            currentStatus,\n            currentPlanDetails,\n            currentDueDate,\n            currentPriority,\n            accountId\n        });\n        \n        let html = `\n            <div class=\"task-details-section\">\n                <h3><i class=\"fas fa-lightbulb\"></i> Recommended Action</h3>\n                <div class=\"action-display-card\">\n                    <div class=\"action-title\">${actionTitle}</div>\n                    <div class=\"action-id\">Action ID: ${actionId}</div>\n                </div>\n            </div>\n            \n            <div class=\"task-details-section\">\n                <h3><i class=\"fas fa-edit\"></i> Task Properties</h3>\n                <div class=\"task-properties-grid\">\n                    <div class=\"property-field\">\n                        <label for=\"taskDueDate\">Due Date</label>\n                        <input type=\"date\" id=\"taskDueDate\" class=\"form-input\" value=\"${currentDueDate}\" onchange=\"ActionsRenderer.debouncedAutoSave('dueDate', this.value)\">\n                    </div>\n                    \n                    <div class=\"property-field\">\n                        <label for=\"taskPriority\">Priority</label>\n                        <select id=\"taskPriority\" class=\"form-select\" onchange=\"ActionsRenderer.debouncedAutoSave('priority', this.value)\">\n                            <option value=\"High\" ${currentPriority === 'High' ? 'selected' : ''}>High</option>\n                            <option value=\"Medium\" ${currentPriority === 'Medium' ? 'selected' : ''}>Medium</option>\n                            <option value=\"Low\" ${currentPriority === 'Low' ? 'selected' : ''}>Low</option>\n                        </select>\n                    </div>\n                    \n                    <div class=\"property-field\">\n                        <label for=\"taskStatus\">Task Status</label>\n                        <select id=\"taskStatus\" class=\"form-select\" onchange=\"ActionsRenderer.debouncedAutoSave('status', this.value)\">\n                            <option value=\"pending\" ${currentStatus === 'pending' ? 'selected' : ''}>Pending</option>\n                            <option value=\"in_progress\" ${currentStatus === 'in_progress' ? 'selected' : ''}>In Progress</option>\n                            <option value=\"complete\" ${currentStatus === 'complete' ? 'selected' : ''}>Complete</option>\n                            <option value=\"cancelled\" ${currentStatus === 'cancelled' ? 'selected' : ''}>Cancelled</option>\n                            <option value=\"on_hold\" ${currentStatus === 'on_hold' ? 'selected' : ''}>On Hold</option>\n                        </select>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"task-details-section\">\n                <h3><i class=\"fas fa-clipboard-list\"></i> Plan Details</h3>\n                <div class=\"plan-details-field\">\n                    <textarea id=\"taskPlanDetails\" \n                              class=\"form-textarea\" \n                              placeholder=\"Add details about this action plan...\"\n                              oninput=\"ActionsRenderer.debouncedAutoSave('description', this.value)\"\n                              rows=\"4\"></textarea>\n                </div>\n            </div>\n            \n            <div class=\"task-details-section\">\n                <h3><i class=\"fas fa-toolbox\"></i> Toolbox Plays (${plays.length})</h3>\n                <div class=\"plays-management\">\n        `;\n        \n        if (plays.length === 0) {\n            html += `\n                <div class=\"no-plays-message\">\n                    <i class=\"fas fa-info-circle\"></i>\n                    No toolbox plays are associated with this action plan.\n                </div>\n            `;\n        } else {\n            html += '<div class=\"plays-list\">';\n            plays.forEach((play, index) => {\n                // Handle both string plays and object plays\n                const playTitle = typeof play === 'string' ? play : (play.playTitle || play.playName || `Play ${index + 1}`);\n                const playId = typeof play === 'string' ? `play_${index + 1}` : (play.playId || `play_${index + 1}`);\n                const isCompleted = play.completed || false;\n                \n                // Extract play details - handle both string and object formats\n                const playDescription = typeof play === 'object' && play.description ? play.description : \n                    (typeof play === 'string' && play.includes(' - ') ? play.split(' - ').slice(1).join(' - ') : \n                    'Non-Billed, Hours-Based Consulting Offering: This play focuses on implementing best practices and strategic approaches to drive business value.');\n                \n                const playOwner = typeof play === 'object' && play.owner ? play.owner : 'Adoption Consulting';\n                \n                // Clean title - remove description if it was concatenated\n                const cleanTitle = typeof play === 'string' && play.includes(' - ') ? play.split(' - ')[0] : playTitle;\n                \n                // 🔒 SECURITY FIX: HTML escape function to prevent XSS\n                const escapeHtml = (text) => {\n                    const div = document.createElement('div');\n                    div.textContent = text;\n                    return div.innerHTML;\n                };\n                \n                html += `\n                    <div class=\"toolbox-play-item\" data-play-id=\"${playId}\" data-play-index=\"${index}\">\n                        <div class=\"play-checkbox-section\">\n                            <input type=\"checkbox\" class=\"toolbox-play-checkbox\" \n                                   ${isCompleted ? 'checked' : ''}\n                                   onchange=\"ActionsRenderer.togglePlayCompletionCheckbox('${actionId}', '${playId}', ${index}, this.checked)\">\n                        </div>\n                        <div class=\"play-content-section\">\n                            <div class=\"play-title-section\">\n                                <h4 class=\"toolbox-play-title ${isCompleted ? 'completed' : ''}\">${escapeHtml(cleanTitle)}</h4>\n                            </div>\n                            <div class=\"play-description-section\">\n                                <p class=\"toolbox-play-description\">${escapeHtml(playDescription)}</p>\n                            </div>\n                            <div class=\"play-owner-section\">\n                                <span class=\"play-owner-label\">Play Owner: <span class=\"play-owner-name\">${escapeHtml(playOwner)}</span></span>\n                            </div>\n                            <div class=\"play-actions-section\">\n                                <button class=\"btn btn-sm btn-danger play-delete-btn\" \n                                        onclick=\"ActionsRenderer.deletePlay('${actionId}', '${playId}', ${index})\"\n                                        title=\"Delete play\">\n                                    <i class=\"fas fa-trash\"></i>\n                                </button>\n                            </div>\n                        </div>\n                    </div>\n                `;\n            });\n            html += '</div>';\n        }\n        \n        html += `\n                </div>\n            </div>\n        `;\n        \n        container.innerHTML = html;\n        \n        // 🔒 SECURITY FIX: Set textarea value safely via JavaScript to prevent XSS\n        const planDetailsTextarea = document.getElementById('taskPlanDetails');\n        if (planDetailsTextarea) {\n            planDetailsTextarea.value = currentPlanDetails;\n        }\n        \n        // Store current task data for saving with canonical planId (CRITICAL: preserve planId)\n        window.currentActionPlanData = {\n            ...actionPlanData,\n            planId: actionPlanData.planData.id // CRITICAL: Don't overwrite the planId!\n        };\n    }\n    \n    static convertToDateValue(dateString) {\n        if (!dateString || dateString === 'Not Set') return '';\n        \n        // Try to parse the date string and convert to YYYY-MM-DD format\n        try {\n            const date = new Date(dateString + ', 2025'); // Add year for better parsing\n            if (!isNaN(date.getTime())) {\n                return date.toISOString().split('T')[0];\n            }\n        } catch (error) {\n            console.warn('Could not parse date:', dateString);\n        }\n        \n        return '';\n    }\n    \n    static closeTaskDetailsDrawer() {\n        const drawer = document.getElementById('taskDetailsDrawer');\n        const backdrop = document.getElementById('taskDetailsDrawerBackdrop');\n        \n        if (drawer) {\n            drawer.classList.remove('open');\n        }\n        \n        if (backdrop) {\n            setTimeout(() => {\n                backdrop.classList.remove('open');\n            }, 300);\n        }\n        \n        // Auto-refresh the current tab to reflect any status changes made in the modal\n        if (window.app && window.app.renderCurrentTab) {\n            // Re-render the current tab to show updated task statuses\n            setTimeout(() => {\n                window.app.renderCurrentTab();\n            }, 350); // Small delay to ensure modal close animation completes\n        }\n        \n        // Clear stored task data\n        window.currentActionPlanData = null;\n    }\n    \n    // Helper method to update task row display immediately\n    static updateTaskRowDisplay(taskId, updates) {\n        const taskRow = document.querySelector(`[data-task-id=\"${taskId}\"]`);\n        if (!taskRow) return;\n        \n        try {\n            if (updates.dueDate) {\n                const dueDateElement = taskRow.querySelector('.due-date');\n                if (dueDateElement) {\n                    dueDateElement.textContent = updates.dueDate || 'Not Set';\n                }\n            }\n            \n            if (updates.priority) {\n                const priorityElement = taskRow.querySelector('.priority-badge');\n                if (priorityElement) {\n                    priorityElement.textContent = updates.priority;\n                    priorityElement.className = `priority-badge priority-${updates.priority.toLowerCase()}`;\n                }\n            }\n            \n            if (updates.assignee) {\n                const assigneeElement = taskRow.querySelector('.assignee-initials');\n                if (assigneeElement) {\n                    assigneeElement.textContent = updates.assignee;\n                }\n            }\n            \n            if (updates.status) {\n                const statusElement = taskRow.querySelector('.status-badge');\n                if (statusElement) {\n                    statusElement.textContent = updates.status;\n                    statusElement.className = `status-badge ${StatusUtils.getStatusCSSClass(StatusUtils.normalizeStatusToCanonical(updates.status))}`;\n                }\n            }\n            \n            if (updates.description) {\n                const descriptionElement = taskRow.querySelector('.action-plan-description');\n                if (descriptionElement) {\n                    descriptionElement.textContent = updates.description;\n                } else {\n                    // If no description element exists, create one\n                    const contentElement = taskRow.querySelector('.action-plan-content');\n                    if (contentElement && updates.description.trim()) {\n                        const newDescElement = document.createElement('div');\n                        newDescElement.className = 'action-plan-description';\n                        newDescElement.textContent = updates.description;\n                        contentElement.appendChild(newDescElement);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error updating task row display:', error);\n        }\n    }\n    \n    // Auto-save functionality for task properties\n    static async autoSaveTaskProperty(propertyName, value) {\n        if (!window.currentActionPlanData) {\n            console.error('No task data available for auto-save');\n            return;\n        }\n        \n        try {\n            const { taskId, actionId, planData, accountId } = window.currentActionPlanData;\n            \n            console.log(`🔍 [DEBUG] Auto-saving ${propertyName}:`, value);\n            console.log(`🔍 [DEBUG] Current action plan data:`, {\n                taskId,\n                actionId,\n                planId: planData?.id,\n                accountId,\n                planDataKeys: Object.keys(planData || {}),\n                hasActionItems: !!planData?.actionItems,\n                actionItemsCount: planData?.actionItems?.length || 0\n            });\n            \n            // Update the task row display immediately for better UX\n            this.updateTaskRowDisplay(taskId, { [propertyName]: value });\n            \n            // Prepare update data based on property name and data structure\n            let updateData = {};\n            \n            // Get the current action item for updates\n            const actionItem = window.currentActionPlanData.actionItem;\n            \n            console.log(`🔍 [DEBUG] Updating property ${propertyName} with value:`, value);\n            console.log(`🔍 [DEBUG] Current action item:`, actionItem);\n            console.log(`🔍 [DEBUG] Current plan data structure:`, planData);\n            \n            switch(propertyName) {\n                case 'dueDate':\n                    // Update both at plan level and action item level for compatibility\n                    updateData.dueDate = value;\n                    if (actionItem && planData.actionItems) {\n                        updateData.actionItems = planData.actionItems.map(item => \n                            item.actionId === actionItem.actionId ? { ...item, dueDate: value } : item\n                        );\n                    }\n                    break;\n                case 'priority':\n                    // Update both at plan level and action item level for compatibility\n                    updateData.priority = value;\n                    if (actionItem && planData.actionItems) {\n                        updateData.actionItems = planData.actionItems.map(item => \n                            item.actionId === actionItem.actionId ? { ...item, priority: value } : item\n                        );\n                    }\n                    break;\n                case 'status':\n                    // Update both at plan level and action item level for compatibility\n                    updateData.status = value;\n                    if (actionItem && planData.actionItems) {\n                        updateData.actionItems = planData.actionItems.map(item => \n                            item.actionId === actionItem.actionId ? { ...item, status: value } : item\n                        );\n                    }\n                    break;\n                case 'assignee':\n                    // Update plan level (assignee is at planData level)\n                    updateData.assignee = value;\n                    break;\n                case 'description':\n                    // Update plan details/description at plan level\n                    updateData.description = value;\n                    break;\n                default:\n                    console.warn('Unknown property for auto-save:', propertyName);\n                    return;\n            }\n            \n            console.log(`🔍 [DEBUG] Prepared update data:`, updateData);\n            \n            // Call the CRUD method to save changes\n            console.log(`🔍 [DEBUG] Calling updateActionPlan with:`, {\n                planId: planData.id,\n                updateData,\n                planDataType: typeof planData.id,\n                planIdExists: !!planData.id\n            });\n            \n            // 🔧 FIX: Use canonical planId from modal context\n            const planId = window.currentActionPlanData.planId;\n            console.log(`🔧 [FIX] Auto-saving with canonical planId: ${planId}`);\n            const result = await ActionPlansService.updateActionPlan(planId, updateData);\n            \n            // OPTIMISTIC UPDATES: Always update UI immediately, regardless of server response\n            console.log(`✅ Auto-save initiated for ${propertyName}:`, result);\n            \n            // Update the current modal data immediately with the new value\n            if (window.currentActionPlanData && window.currentActionPlanData.planData) {\n                // Apply the update to the modal data\n                Object.assign(window.currentActionPlanData.planData, updateData);\n                console.log(`🔄 Updated modal data for ${propertyName}`);\n            }\n            \n            // 🎉 IMMEDIATE UI FEEDBACK: Always refresh the Action Plans table \n            if (window.app && typeof window.app.renderCurrentTab === 'function') {\n                // Debounce UI refresh to avoid thrashing during rapid changes\n                if (this.uiRefreshTimeout) clearTimeout(this.uiRefreshTimeout);\n                this.uiRefreshTimeout = setTimeout(() => {\n                    window.app.renderCurrentTab();\n                    console.log(`🎉 [OPTIMISTIC] Refreshed UI to show ${propertyName} change`);\n                }, 100);\n            }\n            \n            // Result handling (success/warning messages are handled by the service)\n            if (result && result.success) {\n                console.log(`✅ Auto-save completed for ${propertyName}`);\n            } else {\n                console.warn(`⚠️ Auto-save had issues for ${propertyName}, but optimistic update applied`);\n            }\n        } catch (error) {\n            console.error(`Error auto-saving ${propertyName}:`, error);\n            NotificationService.showError(`Error saving ${propertyName} change`);\n        }\n    }\n    \n    // 🚀 PERFORMANCE: Debounced auto-save to prevent spam writes\n    static debouncedAutoSave = (function() {\n        let timeout;\n        return function(propertyName, value) {\n            clearTimeout(timeout);\n            timeout = setTimeout(() => {\n                ActionsRenderer.autoSaveTaskProperty(propertyName, value);\n            }, 300); // 300ms debounce\n        };\n    })();\n    \n    // 🔒 SECURITY FIX: Delegated event listeners for secure interaction\n    static setupDelegatedEventListeners(container) {\n        // Check if already initialized to prevent duplicates\n        if (container.dataset.delegatedListenersInitialized) {\n            return;\n        }\n        \n        // Add delegated listeners\n        container.addEventListener('click', this.handleDelegatedClick.bind(this));\n        container.addEventListener('contextmenu', this.handleDelegatedContextMenu.bind(this));\n        container.addEventListener('change', this.handleDelegatedChange.bind(this));\n        \n        // Mark as initialized\n        container.dataset.delegatedListenersInitialized = 'true';\n    }\n    \n    static handleDelegatedClick(event) {\n        // Handle empty state tab switching\n        const tabButton = event.target.closest('[data-action=\"switch-tab\"]');\n        if (tabButton) {\n            const tab = tabButton.getAttribute('data-tab');\n            if (tab && window.app) {\n                window.app.switchTab(tab);\n            }\n            return;\n        }\n        \n        // Handle group toggle clicks\n        if (event.target.closest('.group-toggle')) {\n            this.toggleGroup(event.target.closest('.group-toggle'));\n            return;\n        }\n        \n        // Handle checkbox column clicks (stop propagation)\n        if (event.target.closest('.checkbox-col')) {\n            event.stopPropagation();\n            return;\n        }\n        \n        // Handle task row clicks\n        const taskRow = event.target.closest('.action-plan-row');\n        if (taskRow) {\n            const taskId = taskRow.getAttribute('data-task-id');\n            const actionId = taskRow.getAttribute('data-action-id');\n            if (taskId && actionId) {\n                this.handleTaskRowClick(event, taskId, actionId);\n            }\n        }\n    }\n    \n    static handleDelegatedContextMenu(event) {\n        const taskRow = event.target.closest('.action-plan-row');\n        if (taskRow) {\n            const taskId = taskRow.getAttribute('data-task-id');\n            const actionId = taskRow.getAttribute('data-action-id');\n            if (taskId && actionId) {\n                this.handleTaskRightClick(event, taskId, actionId);\n            }\n        }\n    }\n    \n    static handleDelegatedChange(event) {\n        if (event.target.classList.contains('action-plan-checkbox')) {\n            const taskRow = event.target.closest('.action-plan-row');\n            if (taskRow) {\n                const taskId = taskRow.getAttribute('data-task-id');\n                this.toggleTaskComplete(taskId, event.target.checked);\n            }\n        }\n    }\n    \n    // New checkbox-based play completion toggle\n    static async togglePlayCompletionCheckbox(actionId, playId, playIndex, isChecked) {\n        if (!window.currentActionPlanData) {\n            console.error('No task data available for play completion toggle');\n            return;\n        }\n        \n        try {\n            const { taskId, actionItem, planData } = window.currentActionPlanData;\n            \n            // Safety check for actionItem\n            if (!actionItem || !actionItem.plays) {\n                console.error('No actionItem or plays available in currentActionPlanData');\n                return;\n            }\n            \n            console.log(`Toggling play completion: ${playId} -> ${isChecked} (playIndex: ${playIndex})`);\n            console.log('Available plays:', actionItem.plays);\n            \n            // Get the plays array from the action item\n            const plays = [...actionItem.plays]; // Create a copy for safety\n            let playUpdated = false;\n            \n            // Update the specific play by index since playId is generated, not stored\n            if (playIndex >= 0 && playIndex < plays.length) {\n                const play = plays[playIndex];\n                \n                // Handle both string and object plays - normalize to consistent object format\n                if (typeof play === 'string') {\n                    // Convert string play to normalized object with completion status\n                    plays[playIndex] = {\n                        playName: play,\n                        playTitle: play, // Add for compatibility\n                        playId: `play_${playIndex + 1}`, // Add stable playId\n                        completed: isChecked\n                    };\n                } else if (typeof play === 'object') {\n                    // Update existing object play\n                    play.completed = isChecked;\n                    // Ensure it has the required fields\n                    if (!play.playName && !play.playTitle) {\n                        play.playName = play.playTitle || `Play ${playIndex + 1}`;\n                    }\n                    if (!play.playId) {\n                        play.playId = `play_${playIndex + 1}`;\n                    }\n                } else {\n                    console.error('Unexpected play format:', play);\n                    return;\n                }\n                \n                playUpdated = true;\n                console.log('Updated play at index', playIndex, ':', plays[playIndex]);\n            }\n            \n            if (!playUpdated) {\n                console.error('Could not find play to update at index:', playIndex);\n                return;\n            }\n            \n            // Update the visual state immediately\n            const playElement = document.querySelector(`[data-play-id=\"${playId}\"] .play-title`);\n            if (playElement) {\n                if (isChecked) {\n                    playElement.classList.add('completed');\n                } else {\n                    playElement.classList.remove('completed');\n                }\n            }\n            \n            // Save the changes using CRUD method\n            const updateData = {\n                plays: plays  // Update the plays array in the plan data\n            };\n            \n            // Find the correct plan key in app.actionPlans (may not match planData.id)\n            let planKey = null;\n            if (window.app && window.app.actionPlans) {\n                for (let [key, plan] of window.app.actionPlans) {\n                    if (plan.id === planData.id || key === planData.id) {\n                        planKey = key;\n                        break;\n                    }\n                }\n            }\n            \n            if (!planKey) {\n                console.error('Could not find plan key for update');\n                return;\n            }\n            \n            const result = await ActionPlansService.updateActionPlan(planKey, updateData, window.app);\n            \n            if (result && result.success) {\n                console.log('Successfully updated play completion status');\n                \n                // Update local data using the correct plan key\n                if (window.app && window.app.actionPlans && window.app.actionPlans.has(planKey)) {\n                    const plan = window.app.actionPlans.get(planKey);\n                    // Update plays in both possible locations for consistency\n                    plan.plays = plays;\n                    if (plan.planData) {\n                        plan.planData.plays = plays;\n                    }\n                    window.app.actionPlans.set(planKey, plan);\n                    \n                    // Trigger cache update events for UI consistency\n                    if (window.DataCache && window.DataCache.emit) {\n                        window.DataCache.emit('actionPlansChanged');\n                    }\n                }\n                \n                // Show success notification\n                const statusText = isChecked ? 'completed' : 'pending';\n                NotificationService.showSuccess(`Play marked as ${statusText}`);\n            } else {\n                console.error('Failed to update play completion:', result ? result.error : 'Unknown error');\n                \n                // Revert the visual state on failure\n                if (playElement) {\n                    if (isChecked) {\n                        playElement.classList.remove('completed');\n                    } else {\n                        playElement.classList.add('completed');\n                    }\n                }\n                \n                // Revert the checkbox state\n                const checkbox = document.querySelector(`[data-play-id=\"${playId}\"] .play-checkbox`);\n                if (checkbox) {\n                    checkbox.checked = !isChecked;\n                }\n                \n                NotificationService.showError('Failed to update play status');\n            }\n        } catch (error) {\n            console.error('Error toggling play completion:', error);\n            NotificationService.showError('Error updating play status');\n        }\n    }\n    \n    static async saveTaskDetails() {\n        if (!window.currentActionPlanData) {\n            console.error('No task data to save');\n            return;\n        }\n        \n        try {\n            // Get updated values from form\n            const dueDate = document.getElementById('taskDueDate').value;\n            const priority = document.getElementById('taskPriority').value;\n            const assignee = document.getElementById('taskAssignee').value;\n            const status = document.getElementById('taskStatus').value;\n            \n            console.log('Saving task details:', { dueDate, priority, assignee, status });\n            \n            const { taskId, actionId, actionItem, planData, accountId } = window.currentActionPlanData;\n            \n            // Find the action item within the plan and update it\n            const updatedActionItems = planData.actionItems.map((item, index) => {\n                // Handle both string and object action items\n                const itemActionId = typeof item === 'object' && item.actionId ? \n                    item.actionId : \n                    null; // Only use real action IDs from CSV data\n                \n                if (itemActionId === actionId) {\n                    // Update this action item with the new task properties\n                    // Preserve existing plays from the original actionItem\n                    const originalPlays = actionItem && actionItem.plays ? actionItem.plays : [];\n                    \n                    const updatedItem = typeof item === 'string' ? \n                        { \n                            title: item, \n                            actionId: actionId,\n                            dueDate: dueDate,\n                            priority: priority,\n                            assignee: assignee,\n                            status: status,\n                            plays: originalPlays  // Preserve original plays instead of empty array\n                        } : \n                        { \n                            ...item, \n                            dueDate: dueDate,\n                            priority: priority,\n                            assignee: assignee,\n                            status: status\n                        };\n                    \n                    console.log('Updated action item:', updatedItem);\n                    return updatedItem;\n                }\n                return item;\n            });\n            \n            // Prepare the update data for the action plan\n            const updateData = {\n                ...planData,\n                actionItems: updatedActionItems,\n                updatedAt: new Date().toISOString()\n            };\n            \n            console.log('Updating action plan with CRUD method:', planData.id, updateData);\n            \n            // Use ActionPlansService to update the action plan\n            const app = window.app || { \n                actionPlans: new Map(),\n                showSuccessMessage: (msg) => this.showTaskUpdateSuccess(msg),\n                showErrorMessage: (msg) => this.showTaskUpdateError(msg)\n            };\n            \n            // Import ActionPlansService dynamically if not already available\n            const ActionPlansService = window.ActionPlansService || \n                (await import('./flux/services/ActionPlansService.js')).default;\n            \n            // Always update the visual display and local data first\n            this.updateTaskRowDisplay(taskId, { dueDate, priority, assignee, status });\n            \n            // Update local state immediately for better UX\n            if (window.app && window.app.actionPlans && window.app.actionPlans.has(accountId)) {\n                const currentPlan = window.app.actionPlans.get(accountId);\n                if (currentPlan) {\n                    window.app.actionPlans.set(accountId, updateData);\n                }\n            }\n            \n            // Close drawer and show success message to user\n            this.closeTaskDetailsDrawer();\n            this.showTaskUpdateSuccess('Task details updated successfully!');\n            \n            // Re-render the Action Plans tab to reflect changes\n            if (window.app && window.app.renderCurrentTab) {\n                window.app.renderCurrentTab();\n            }\n            \n            // Try to save to backend - log errors but don't show them to user\n            try {\n                const updatedPlan = await ActionPlansService.updateActionPlan(planData.id, updateData, app);\n                if (updatedPlan) {\n                    console.log('Task details successfully saved to backend:', updatedPlan.id);\n                } else {\n                    console.warn('Backend save failed but local update succeeded');\n                }\n            } catch (backendError) {\n                console.error('Failed to save task details to Domo endpoint (local update succeeded):', backendError);\n                // Don't show error to user since local update worked\n            }\n            \n        } catch (error) {\n            console.error('Error saving task details:', error);\n            this.showTaskUpdateError(error.message || 'Failed to save task details');\n        }\n    }\n    \n    static updateTaskRowDisplay(taskId, updates) {\n        const taskRow = document.querySelector(`[data-task-id=\"${taskId}\"]`);\n        if (!taskRow) return;\n        \n        // Update due date display\n        if (updates.dueDate) {\n            const dueDateElement = taskRow.querySelector('.due-date');\n            if (dueDateElement) {\n                const formattedDate = new Date(updates.dueDate).toLocaleDateString('en-US', { \n                    month: 'short', \n                    day: 'numeric' \n                });\n                dueDateElement.textContent = formattedDate;\n            }\n        }\n        \n        // Update priority badge\n        if (updates.priority) {\n            const priorityElement = taskRow.querySelector('.priority-badge');\n            if (priorityElement) {\n                priorityElement.className = `priority-badge priority-${updates.priority.toLowerCase()}`;\n                priorityElement.textContent = updates.priority;\n            }\n        }\n        \n        // Update assignee initials\n        if (updates.assignee) {\n            const assigneeElement = taskRow.querySelector('.assignee-initials');\n            if (assigneeElement) {\n                assigneeElement.textContent = updates.assignee;\n            }\n        }\n        \n        // Update task completion status\n        if (updates.status === 'Complete') {\n            taskRow.classList.add('action-plan-completed');\n            const checkbox = taskRow.querySelector('.task-checkbox');\n            if (checkbox) checkbox.checked = true;\n        } else {\n            taskRow.classList.remove('action-plan-completed');\n            const checkbox = taskRow.querySelector('.task-checkbox');\n            if (checkbox) checkbox.checked = false;\n        }\n    }\n    \n    static deletePlay(actionId, playId, playIndex) {\n        if (confirm('Are you sure you want to delete this CS play?')) {\n            const playItem = document.querySelector(`[data-play-id=\"${playId}\"][data-play-index=\"${playIndex}\"]`);\n            if (playItem) {\n                playItem.remove();\n                console.log(`Deleted play ${playId} from action ${actionId}`);\n                \n                // Update plays count in main view (simplified)\n                this.updatePlaysCountDisplay(actionId, -1);\n            }\n        }\n    }\n    \n    static updatePlaysCountDisplay(actionId, change) {\n        // Find and update the plays count in the main table\n        const playsButtons = document.querySelectorAll(`[data-task-id=\"${actionId}\"]`);\n        playsButtons.forEach(button => {\n            const countElement = button.querySelector('.plays-count');\n            if (countElement) {\n                const currentCount = parseInt(countElement.textContent) || 0;\n                const newCount = Math.max(0, currentCount + change);\n                countElement.textContent = newCount;\n            }\n        });\n    }\n    \n    static showTaskUpdateSuccess() {\n        const message = document.createElement('div');\n        message.className = 'update-notification success';\n        message.innerHTML = `\n            <i class=\"fas fa-check-circle\"></i>\n            Task details updated successfully!\n        `;\n        document.body.appendChild(message);\n        \n        setTimeout(() => {\n            message.classList.add('show');\n            setTimeout(() => {\n                message.classList.remove('show');\n                setTimeout(() => message.remove(), 300);\n            }, 3000);\n        }, 100);\n    }\n    \n    static showTaskUpdateError(errorMessage) {\n        const message = document.createElement('div');\n        message.className = 'update-notification error';\n        message.innerHTML = `\n            <i class=\"fas fa-exclamation-circle\"></i>\n            Error updating task: ${errorMessage}\n        `;\n        document.body.appendChild(message);\n        \n        setTimeout(() => {\n            message.classList.add('show');\n            setTimeout(() => {\n                message.classList.remove('show');\n                setTimeout(() => message.remove(), 300);\n            }, 5000);\n        }, 100);\n    }\n\n    // Fallback Data Loading\n    static async loadFallbackActionPlans(app) {\n        try {\n            const response = await fetch('/action-plans-fallback.json');\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            \n            const fallbackData = await response.json();\n            const formattedPlans = [];\n\n            console.log(`FALLBACK LOADING: Processing ${fallbackData.length} action plan records from JSON`);\n\n            // Process each action plan from the JSON\n            for (const [index, record] of fallbackData.entries()) {\n                console.log(`FALLBACK RECORD ${index + 1}:`, {\n                    recordId: record.id,\n                    accountId: record.content?.accountId,\n                    actionId: record.content?.actionId,\n                    title: record.content?.title,\n                    status: record.content?.status\n                });\n                const planContent = record.content;\n                if (!planContent) {\n                    continue; // Skip plans with no content\n                }\n                \n                // Handle new single-action-per-plan data model\n                // Each record represents one action plan with one action\n\n                // Get account information - try accountId first, then signal lookup\n                let accountId = planContent.accountId;\n                let signal = null;\n                \n                if (planContent.signalId) {\n                    signal = app.data.find(s => s.id === planContent.signalId);\n                    if (signal && !accountId) {\n                        accountId = signal.account_id;\n                    }\n                }\n                \n                // Get account name\n                let accountName = this.getAccountNameFromPlan(planContent, signal, app);\n                \n                // If we still don't have an account ID, try to match by account name from the existing accounts\n                if (!accountId && app.accounts && app.accounts.size > 0) {\n                    for (let [existingAccountId, account] of app.accounts) {\n                        // Try to match account names (case insensitive partial match)\n                        if (account.name && accountName && \n                            (account.name.toLowerCase().includes(accountName.toLowerCase()) ||\n                             accountName.toLowerCase().includes(account.name.toLowerCase()))) {\n                            accountId = existingAccountId;\n                            accountName = account.name; // Use the exact account name from the app\n                            console.log(`Mapped action plan to existing account: ${accountName} (${accountId})`);\n                            break;\n                        }\n                    }\n                }\n                \n                // If still no match, use the accountId from planContent or create fallback\n                if (!accountId) {\n                    accountId = planContent.accountId || `fallback-${planContent.id}`;\n                    console.log(`Using account ID: ${accountId} for plan: ${planContent.title}`);\n                }\n\n                // Determine urgency and health based on available data\n                const urgency = this.determineFallbackUrgency(planContent, signal);\n                const accountHealth = signal ? this.getHealthFromRiskCategory(signal.at_risk_cat) : 'healthy';\n                \n                // Get signals count for this account\n                const accountSignals = accountId && signal ? \n                                     app.data.filter(s => s.account_id === accountId) : [];\n\n                // Create single action item from the plan content\n                const singleActionItem = {\n                    title: planContent.title || 'Untitled Action',\n                    actionId: planContent.actionId,\n                    completed: false,\n                    plays: planContent.plays ? planContent.plays.map(play => ({\n                        playId: `play_${Math.random().toString(36).substr(2, 9)}`,\n                        playName: play,\n                        playTitle: play\n                    })) : [],\n                    description: planContent.description || '',\n                    priority: planContent.priority || 'medium',\n                    dueDate: planContent.dueDate,\n                    status: planContent.status || 'pending'\n                };\n\n                const formattedPlan = {\n                    accountId: accountId,\n                    accountName: accountName,\n                    accountHealth: accountHealth,\n                    signalsCount: accountSignals.length,\n                    highPriorityCount: accountSignals.filter(s => s.priority === 'High').length,\n                    renewalBaseline: this.getFallbackRenewalValue(signal, app),\n                    status: planContent.status || 'pending',\n                    urgency: urgency,\n                    planData: {\n                        id: planContent.id,\n                        actionItems: [singleActionItem], // Convert single action to array format for compatibility\n                        status: planContent.status,\n                        assignee: planContent.assignee,\n                        createdAt: planContent.createdAt,\n                        updatedAt: planContent.updatedAt,\n                        notes: planContent.description || '',\n                        // Store original plan content for CRUD operations\n                        originalPlanContent: planContent\n                    },\n                    lastUpdated: planContent.updatedAt || planContent.createdAt,\n                    nextAction: planContent.title || 'No actions defined'\n                };\n\n                console.log(`FORMATTED PLAN ${index + 1}:`, {\n                    accountId: formattedPlan.accountId,\n                    accountName: formattedPlan.accountName,\n                    actionTitle: planContent.title,\n                    status: formattedPlan.status\n                });\n\n                formattedPlans.push(formattedPlan);\n            }\n\n            console.log(`BEFORE GROUPING: ${formattedPlans.length} formatted plans`);\n            formattedPlans.forEach((plan, i) => {\n                console.log(`  Plan ${i + 1}: Account ${plan.accountId} (${plan.accountName}) - ${plan.nextAction}`);\n            });\n\n            // Group by account and merge duplicates\n            const groupedPlans = this.groupFallbackPlansByAccount(formattedPlans);\n            \n            console.log(`AFTER GROUPING: ${groupedPlans.length} grouped plans`);\n            groupedPlans.forEach((plan, i) => {\n                console.log(`  Grouped Plan ${i + 1}: Account ${plan.accountId} (${plan.accountName}) - ${plan.planData.actionItems.length} actions`);\n            });\n            \n            return groupedPlans.sort((a, b) => {\n                const urgencyOrder = { critical: 0, high: 1, normal: 2 };\n                if (urgencyOrder[a.urgency] !== urgencyOrder[b.urgency]) {\n                    return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];\n                }\n                return new Date(b.lastUpdated) - new Date(a.lastUpdated);\n            });\n\n        } catch (error) {\n            console.error('Error loading fallback action plans:', error);\n            return [];\n        }\n    }\n\n    static getAccountNameFromPlan(planContent, signal, app) {\n        // Try to get account name from plan title first (format: \"Action Plan - Account Name\")\n        if (planContent.planTitle && planContent.planTitle.includes(' - ')) {\n            return planContent.planTitle.split(' - ').slice(1).join(' - ').trim();\n        }\n        \n        // Try to get from signal data\n        if (signal && signal.account_name) {\n            return signal.account_name;\n        }\n        \n        // Try to get from accountId if it exists and we can find the account\n        if (planContent.accountId && app.accounts && app.accounts.has(planContent.accountId)) {\n            const account = app.accounts.get(planContent.accountId);\n            if (account && account.name) {\n                return account.name;\n            }\n        }\n        \n        // Fallback to generic name\n        return `Account ${planContent.id.slice(-8)}`;\n    }\n\n    static determineFallbackUrgency(planContent, signal) {\n        // Determine urgency based on available information\n        if (signal && signal.priority === 'High') {\n            return 'high';\n        }\n        \n        if (planContent.priority === 'high') {\n            return 'high';\n        }\n        \n        // For single action plans, check if there are multiple plays indicating complexity\n        if (planContent.plays && planContent.plays.length > 2) {\n            return 'high';\n        }\n        \n        return 'normal';\n    }\n\n    static getFallbackRenewalValue(signal, app) {\n        // Try to get real renewal value from signal\n        if (signal && signal.bks_renewal_baseline_usd) {\n            return parseFloat(signal.bks_renewal_baseline_usd) || 0;\n        }\n        \n        // Generate realistic fallback value\n        return this.getRandomRenewalValue();\n    }\n\n    static groupFallbackPlansByAccount(formattedPlans) {\n        console.log('GROUPING LOGIC: Starting to group plans by account...');\n        console.log(`Input: ${formattedPlans.length} individual plans`);\n        \n        // In the new single-action-per-plan model, each plan represents one task\n        // We should NOT merge plans - instead keep them separate but group for display\n        const grouped = new Map();\n        \n        for (const plan of formattedPlans) {\n            const key = plan.accountId;\n            console.log(`  Processing plan for account: ${key} (${plan.accountName})`);\n            \n            if (!grouped.has(key)) {\n                grouped.set(key, []);\n            }\n            \n            // Add this plan to the array for this account\n            grouped.get(key).push(plan);\n            console.log(`    → Added plan to account ${key}. Total plans for this account: ${grouped.get(key).length}`);\n        }\n        \n        console.log(`GROUPING COMPLETE: ${grouped.size} unique accounts`);\n        \n        // Convert to array format but keep all individual plans\n        const result = [];\n        for (const [accountId, plans] of grouped) {\n            // For each account, add all its plans to the result\n            result.push(...plans);\n            console.log(`Account ${accountId}: Added ${plans.length} plans to result`);\n        }\n        \n        console.log(`Final result: ${result.length} plans total`);\n        return result;\n    }\n}","size_bytes":139959},"js/PortfolioRenderer.js":{"content":"// Portfolio Renderer - Pure view for rendering portfolio tab\nclass PortfolioRenderer {\n\n    static renderMyPortfolio(accounts, actionPlans, comments) {\n        const container = document.getElementById('accountsList');\n        if (!container) return;\n\n        // Update dashboard card values\n        this.updateDashboardCards(accounts, actionPlans);\n\n        // Get all accounts\n        const allAccounts = Array.from(accounts.values());\n\n        // Filter accounts with recent high priority Risk or Opportunities signals\n        const accountsWithRiskOrOpportunitySignals = allAccounts\n            .filter(account => account.signals.some(signal => {\n                const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n                const normalizedPolarity = FormatUtils.normalizePolarityKey(polarity);\n                return signal.priority === 'High' && (normalizedPolarity === 'risk' || normalizedPolarity === 'opportunities');\n            }))\n            .map(account => {\n                // Find the most recent high priority Risk/Opportunities signal for sorting\n                const qualifyingSignals = account.signals.filter(signal => {\n                    const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n                    const normalizedPolarity = FormatUtils.normalizePolarityKey(polarity);\n                    return signal.priority === 'High' && (normalizedPolarity === 'risk' || normalizedPolarity === 'opportunities');\n                });\n                \n                // Sort qualifying signals by polarity priority (Risk > Opportunities) then by call_date DESC\n                const sortedQualifyingSignals = qualifyingSignals.sort((a, b) => {\n                    const polarityA = a.signal_polarity || a['Signal Polarity'] || '';\n                    const polarityB = b.signal_polarity || b['Signal Polarity'] || '';\n                    const normalizedPolarityA = FormatUtils.normalizePolarityKey(polarityA);\n                    const normalizedPolarityB = FormatUtils.normalizePolarityKey(polarityB);\n                    const polarityOrder = { 'risk': 2, 'opportunities': 1, 'enrichment': 0 };\n                    const polarityScoreA = polarityOrder[normalizedPolarityA] || 0;\n                    const polarityScoreB = polarityOrder[normalizedPolarityB] || 0;\n                    \n                    if (polarityScoreA !== polarityScoreB) {\n                        return polarityScoreB - polarityScoreA; // Risk before Opportunities\n                    }\n                    \n                    // Same polarity, sort by call_date DESC\n                    const dateA = new Date(a.call_date || a.created_date);\n                    const dateB = new Date(b.call_date || b.created_date);\n                    return dateB - dateA;\n                });\n                \n                const mostRecentQualifyingDate = sortedQualifyingSignals.length > 0 \n                    ? new Date(sortedQualifyingSignals[0].call_date || sortedQualifyingSignals[0].created_date).getTime()\n                    : 0;\n                const topSignalPolarity = sortedQualifyingSignals.length > 0 \n                    ? FormatUtils.normalizePolarityKey(sortedQualifyingSignals[0].signal_polarity || sortedQualifyingSignals[0]['Signal Polarity'] || '')\n                    : '';\n                    \n                return { ...account, mostRecentQualifyingDate, topSignalPolarity };\n            })\n            .sort((a, b) => {\n                const polarityOrder = { 'risk': 2, 'opportunities': 1, 'enrichment': 0 };\n                const polarityScoreA = polarityOrder[a.topSignalPolarity] || 0;\n                const polarityScoreB = polarityOrder[b.topSignalPolarity] || 0;\n                \n                // First sort by signal polarity (Risk before Opportunities)\n                if (polarityScoreA !== polarityScoreB) {\n                    return polarityScoreB - polarityScoreA;\n                }\n                \n                // Same polarity, sort by most recent qualifying signal date (descending)\n                return b.mostRecentQualifyingDate - a.mostRecentQualifyingDate;\n            });\n\n        // Sort all accounts alphabetically\n        const sortedAllAccounts = allAccounts.sort((a, b) => {\n            return a.name.localeCompare(b.name);\n        });\n\n        let html = '';\n\n        // Render \"Accounts with a recent Risk or Opportunities Identified\" section\n        if (accountsWithRiskOrOpportunitySignals.length > 0) {\n            html += `\n                <div class=\"portfolio-section\">\n                    <h3 class=\"portfolio-section-header\">Accounts with Risk or Opportunities Identified</h3>\n                    <div class=\"portfolio-section-content\">\n                        ${accountsWithRiskOrOpportunitySignals.map(account => this.renderAccountCard(account, actionPlans, comments, ['Risk', 'Opportunities'])).join('')}\n                    </div>\n                </div>\n            `;\n        }\n\n        // Render \"All Accounts\" section\n        html += `\n            <div class=\"portfolio-section\">\n                <h3 class=\"portfolio-section-header\">All Accounts</h3>\n                <div class=\"portfolio-section-content\">\n                    ${sortedAllAccounts.map(account => this.renderAccountCard(account, actionPlans, comments)).join('')}\n                </div>\n            </div>\n        `;\n\n        container.innerHTML = html;\n    }\n\n    static updateDashboardCards(accounts, actionPlans) {\n        const allSignals = Array.from(accounts.values()).flatMap(account => account.signals);\n        const accountsWithSignals = Array.from(accounts.values()).filter(account => account.signals.length > 0);\n\n        // Count recommended actions by signal polarity\n        const recommendedActionsWithPolarity = allSignals.filter(signal => \n            signal.recommended_action && \n            signal.recommended_action.trim() && \n            signal.recommended_action !== 'No actions specified' &&\n            signal.action_id &&\n            signal.action_id.trim()\n        );\n\n        // Count Risk polarity actions\n        const riskActionsCount = recommendedActionsWithPolarity.filter(signal => {\n            const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n            return polarity.toLowerCase() === 'risk';\n        }).length;\n\n        // Count Opportunities polarity actions  \n        const opportunityActionsCount = recommendedActionsWithPolarity.filter(signal => {\n            const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n            return polarity.toLowerCase() === 'opportunities';\n        }).length;\n\n        // Update Risks count\n        const requiresAttentionElement = document.getElementById('requiresAttentionCount');\n        if (requiresAttentionElement) {\n            requiresAttentionElement.textContent = riskActionsCount;\n        }\n\n        // Update Opportunities count\n        const highPriorityElement = document.getElementById('highPriorityDashboard');\n        if (highPriorityElement) {\n            highPriorityElement.textContent = opportunityActionsCount;\n        }\n\n        // Update Active Accounts count\n        const activeAccountsElement = document.getElementById('activeAccountsCount');\n        if (activeAccountsElement) {\n            activeAccountsElement.textContent = accountsWithSignals.length;\n        }\n    }\n\n    static renderAccountCommentsSection(accountId, comments) {\n        const accountComments = comments.get ? comments.get(accountId) || [] : comments[accountId] || [];\n        \n        return `\n            <div class=\"account-comments-section\">\n                <div class=\"comments-header\">\n                    <h4 class=\"comments-title\">Account Comments</h4>\n                    <span class=\"comments-count\">${accountComments.length} comment${accountComments.length !== 1 ? 's' : ''}</span>\n                </div>\n                ${accountComments.length > 0 ? `\n                <div class=\"comments-list\">\n                    ${accountComments.map(comment => `\n                        <div class=\"account-comment\">\n                            <div class=\"comment-header\">\n                                <span class=\"comment-author\">${SecurityUtils.sanitizeHTML(comment.author)}</span>\n                                <span class=\"comment-time\">${FormatUtils.formatCommentTime(comment.timestamp)}</span>\n                            </div>\n                            <div class=\"comment-text\">${SecurityUtils.sanitizeHTML(comment.text)}</div>\n                        </div>\n                    `).join('')}\n                </div>\n                ` : ''}\n                <div class=\"add-comment-section\">\n                    <input type=\"text\" placeholder=\"Add a comment about this account...\" class=\"account-comment-input\" id=\"accountCommentInput-${accountId}\">\n                    <button class=\"btn btn-primary\" data-action=\"add-account-comment\" data-account-id=\"${accountId}\">Add Comment</button>\n                </div>\n            </div>\n        `;\n    }\n\n    static updateSingleAccount(accountId, accounts, actionPlans, comments) {\n        // Find the account\n        const account = accounts.get(accountId);\n        if (!account) return;\n\n        // Find the existing account card in the DOM\n        const container = document.getElementById('accountsList');\n        if (!container) return;\n\n        // Generate the updated account card HTML\n        const updatedAccountHTML = this.renderAccountCard(account, actionPlans, comments);\n\n        // Create a temporary container to parse the HTML\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = updatedAccountHTML;\n        const newAccountCard = tempDiv.firstElementChild;\n\n        // Find the existing account card and replace it\n        const existingCards = container.querySelectorAll('.portfolio-account-card');\n        for (let existingCard of existingCards) {\n            const accountName = existingCard.querySelector('.account-name');\n            if (accountName && accountName.textContent === account.name) {\n                // Preserve the expanded state\n                const signalsContainer = existingCard.querySelector(`#signals-${accountId}`);\n                const wasExpanded = signalsContainer && signalsContainer.classList.contains('expanded');\n                \n                // Replace the card\n                existingCard.parentNode.replaceChild(newAccountCard, existingCard);\n                \n                // Restore expanded state if it was expanded\n                if (wasExpanded) {\n                    const newSignalsContainer = newAccountCard.querySelector(`#signals-${accountId}`);\n                    const newChevron = newAccountCard.querySelector(`#chevron-${accountId}`);\n                    if (newSignalsContainer && newChevron) {\n                        newSignalsContainer.classList.add('expanded');\n                        newChevron.classList.add('rotated');\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    static renderAccountCard(account, actionPlans, comments, filterPolarities = null) {\n        // Count distinct action_id values by signal polarity (each account has 0-3 AI Recommendations)\n        const uniqueActionIds = new Set();\n        const riskActionIds = new Set();\n        const opportunityActionIds = new Set();\n        \n        // Extract unique action_ids and categorize by polarity\n        account.signals.forEach(signal => {\n            if (signal.action_id && signal.action_id.trim()) {\n                uniqueActionIds.add(signal.action_id);\n                const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n                const normalizedPolarity = FormatUtils.normalizePolarityKey(polarity);\n                \n                if (normalizedPolarity === 'risk') {\n                    riskActionIds.add(signal.action_id);\n                } else if (normalizedPolarity === 'opportunities') {\n                    opportunityActionIds.add(signal.action_id);\n                }\n            }\n        });\n        \n        const riskActions = riskActionIds.size;\n        const opportunityActions = opportunityActionIds.size;\n        const totalSignals = account.signals.length;\n\n        // Sort signals by Priority (High > Medium > Low), then by call_date DESC within each priority\n        const sortedSignals = account.signals.sort((a, b) => {\n            // Define priority order\n            const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };\n            \n            // First sort by priority\n            const priorityA = priorityOrder[a.priority] || 0;\n            const priorityB = priorityOrder[b.priority] || 0;\n            \n            if (priorityA !== priorityB) {\n                return priorityB - priorityA; // Higher priority first\n            }\n            \n            // If same priority, sort by call_date DESC (fallback to created_date)\n            const dateA = new Date(a.call_date || a.created_date);\n            const dateB = new Date(b.call_date || b.created_date);\n            return dateB - dateA;\n        });\n        \n        // Initialize pagination state if not exists\n        if (!account.signalsPagination) {\n            account.signalsPagination = { currentPage: 0, pageSize: 3 };\n        }\n        \n        const pageSize = account.signalsPagination.pageSize;\n        const currentPage = account.signalsPagination.currentPage;\n        const startIndex = 0;\n        const endIndex = (currentPage + 1) * pageSize;\n        const visibleSignals = sortedSignals.slice(startIndex, endIndex);\n        const hasMoreSignals = endIndex < account.signals.length;\n\n        // Ensure account has required properties\n        account.health = account.health || this.getHealthFromRiskCategory(account.at_risk_cat);\n        account.industry = account.industry || 'Technology';\n        account.aiRecommendation = account.aiRecommendation || this.generateAIRecommendationForAccount(account);\n        // console.log('airecco: ', account.aiRecommendation);\n\n        return `\n            <div class=\"portfolio-account-card\">\n                <div class=\"account-header-row\" data-action=\"toggle-account-signals\" data-account-id=\"${account.id}\">\n                    <div class=\"account-title-section\">\n                        <i class=\"fas fa-chevron-right account-chevron\" id=\"chevron-${account.id}\"></i>\n                        <div class=\"account-warning-icon\">\n                            <i class=\"fas fa-exclamation-triangle ${account.health === 'critical' ? 'critical-warning' : account.health === 'warning' ? 'warning-warning' : 'healthy-warning'}\"></i>\n                        </div>\n                        <div class=\"account-name-info\">\n                            <h3 class=\"account-name\">${SecurityUtils.sanitizeHTML(account.name)}</h3>\n                            <div class=\"account-stats\">${riskActions} Risks, ${opportunityActions} Opportunities</div>\n                        </div>\n                    </div>\n                    <div class=\"account-actions-section\">\n                        ${account.health === 'critical' ? '<span class=\"critical-badge\">critical</span>' : ''}\n                    </div>\n                </div>\n\n                <div class=\"account-details\" id=\"signals-${account.id}\">\n                    <div class=\"account-metrics\">\n                        <!-- Financial Metrics Box -->\n                        <div class=\"financial-metrics-box\">\n                            <div class=\"financial-header\">\n                                <i class=\"fas fa-dollar-sign\"></i>\n                                <span>Account Overview</span>\n                            </div>\n                            <div class=\"financial-content\">\n                                <div class=\"financial-metric\">\n                                    <span class=\"financial-label\">Renewal Baseline$</span>\n                                    <span class=\"financial-value\">${account.bks_renewal_baseline_usd > 0 ? FormatUtils.formatCurrency(account.bks_renewal_baseline_usd) : '$0'}</span>\n                                </div>\n                                <div class=\"financial-metric\">\n                                    <span class=\"financial-label\">GPA</span>\n                                    <span class=\"financial-value\">${account['Account GPA'] ? parseFloat(account['Account GPA']).toFixed(1) : '0.0'}</span>\n                                </div>\n                                <div class=\"financial-metric\">\n                                    <span class=\"financial-label\">% Pacing</span>\n                                    <span class=\"financial-value\">${account['% Pacing'] ? (parseFloat(account['% Pacing']) * 100).toFixed(1) : '0.0'}%</span>\n                                </div>\n                                <div class=\"financial-metric\">\n                                    <span class=\"financial-label\">Next Renewal Date</span>\n                                    <span class=\"financial-value\">${account['Next Renewal Date'] || 'TBD'}</span>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <div class=\"ai-recommendations-section\">\n                        <div class=\"recommendations-header\">\n                            <i class=\"fas fa-exclamation-triangle recommendation-warning-icon\"></i>\n                            <h4 class=\"recommendations-title\">AI Recommendations</h4>\n                        </div>\n\n                        <div class=\"recommendations-list-container\">\n                            ${this.getMergedRecommendationsAndRationale(account, filterPolarities)}\n                        </div>\n                    </div>\n\n                    <div class=\"signals-section\">\n                        <div class=\"signals-header\">\n                            <div class=\"signals-header-left\">\n                                <i class=\"fas fa-bell signals-icon\"></i>\n                                <h4 class=\"signals-title\">Recent Signals (${totalSignals})</h4>\n                            </div>\n                        </div>\n\n                        <div class=\"signals-list-portfolio\" id=\"signals-list-${account.id}\">\n                            ${visibleSignals.map(signal => `\n                                <div class=\"portfolio-signal-row\">\n                                    <div class=\"signal-priority-badge\">\n                                        <span class=\"priority-tag priority-${signal.priority.toLowerCase()}\">${signal.priority}</span>\n                                    </div>\n                                    <div class=\"signal-name-content\">\n                                        <span class=\"signal-name-text\">${SecurityUtils.sanitizeHTML(signal.name)}</span>\n                                    </div>\n                                    <div class=\"signal-meta-actions\">\n                                        <span class=\"signal-date-text\">${FormatUtils.formatDateSimple(signal.call_date || signal.created_date)}</span>\n                                        <a href=\"#\" class=\"view-link\" data-action=\"view-signal\" data-signal-id=\"${signal.id}\" onclick=\"event.stopPropagation();\">View</a>\n                                    </div>\n                                </div>\n                            `).join('')}\n                        </div>\n                        \n                        <div class=\"signals-pagination\">\n                            ${hasMoreSignals ? `<button class=\"btn btn-secondary show-more-btn\" data-action=\"show-more-signals\" data-account-id=\"${account.id}\" onclick=\"event.stopPropagation();\">Show 3 more</button>` : ''}\n                            ${currentPage > 0 ? `<button class=\"btn btn-outline show-less-btn\" data-action=\"show-less-signals\" data-account-id=\"${account.id}\" onclick=\"event.stopPropagation();\">Show Less</button>` : ''}\n                        </div>\n                    </div>\n\n                    ${this.renderAccountCommentsSection(account.id, comments)}\n\n                </div>\n            </div>\n        `;\n    }\n\n    static getHealthFromRiskCategory(riskCategory) {\n        const healthMap = {\n            'Healthy': 'healthy',\n            'At Risk': 'warning',\n            'Trending Risk': 'warning',\n            'Extreme Risk': 'critical'\n        };\n        return healthMap[riskCategory] || 'healthy';\n    }\n\n    static generateAIRecommendationForAccount(account) {\n        const highPrioritySignals = account.signals.filter(s => s.priority === 'High');\n        const allSignals = account.signals;\n\n        // Extract unique recommendations from signals, prioritizing recommended_action field\n        const actionMap = new Map(); // Map to track unique recommended_action with their action_ids\n\n        allSignals.forEach(signal => {\n            // First priority: Use recommended_action field\n            if (signal.recommended_action && signal.recommended_action.trim() && signal.recommended_action !== 'No actions specified') {\n                const action = signal.recommended_action.trim();\n                const actionId = signal.action_id;\n                \n                // console.log('Using recommended_action for signal:', signal.name, action, 'action_id:', actionId);\n                \n                // Store unique actions with their action_ids\n                if (!actionMap.has(action)) {\n                    actionMap.set(action, new Set());\n                }\n                if (actionId) {\n                    actionMap.get(action).add(actionId);\n                }\n                return; // Skip to next signal since we found recommended_action\n            }\n            \n            // Second priority: Use account_action_context or action_context\n            const actionContext = signal.account_action_context || signal.action_context;\n            // console.log('OUTER Processing action context for signal:', actionContext);\n            if (actionContext && actionContext.trim() && actionContext !== 'No actions specified') {\n                // console.log('Processing action context for signal:', signal.name, actionContext);\n\n                // Enhanced parsing for numbered lists, bullet points, and sentences\n                let actions = [];\n\n                // Split by numbered items (1. 2. 3. etc.) - improved regex\n                if (actionContext.match(/\\d+\\.\\s+/)) {\n                    // Use a more robust regex to capture numbered items\n                    const matches = actionContext.match(/\\d+\\.\\s*([^.]*(?:\\.[^0-9][^.]*)*)/g);\n                    if (matches) {\n                        actions = matches.map(match => {\n                            // Remove the number and period at the start\n                            return match.replace(/^\\d+\\.\\s*/, '').trim();\n                        }).filter(action => action.length > 10);\n                    }\n\n                    // If that didn't work, try splitting differently\n                    if (actions.length === 0) {\n                        actions = actionContext.split(/\\d+\\.\\s+/)\n                            .filter(part => part.trim().length > 10)\n                            .map(part => part.trim());\n                    }\n                }\n                // Split by bullet points (• - * etc.)\n                else if (actionContext.match(/[•\\-\\*]\\s+/)) {\n                    actions = actionContext.split(/(?=[•\\-\\*]\\s+)/)\n                        .map(action => action.replace(/^[•\\-\\*]\\s*/, '').trim())\n                        .filter(action => action.length > 10);\n                }\n                // Split by periods or semicolons for sentence-based actions\n                else {\n                    actions = actionContext.split(/[.;]\\s*/)\n                        .map(action => action.trim())\n                        .filter(action => action.length > 10 && !action.match(/^\\d+$/));\n                }\n\n                // console.log('Parsed actions:', actions);\n                // Add these actions to the map without action_ids\n                actions.forEach(action => {\n                    if (!actionMap.has(action)) {\n                        actionMap.set(action, new Set());\n                    }\n                });\n            }\n        });\n\n        // Convert map to array of unique actions, keeping only top 3\n        const uniqueActions = Array.from(actionMap.keys())\n            .filter(action => action.length > 10) // Ensure substantial actions\n            .slice(0, 3); // Take top 3 actions\n\n        // console.log('Final unique actions for account:', account.name, uniqueActions);\n        // console.log('Action IDs mapping:', Array.from(actionMap.entries()));\n\n        // If we have specific actions from context, use them\n        if (uniqueActions.length > 0) {\n            return {\n                priority: highPrioritySignals.length > 0 ? 'immediate' : 'near-term',\n                actions: uniqueActions,\n                actionMap: actionMap  // Include the action map for polarity lookup\n            };\n        }\n\n        // Fallback to default recommendations based on priority and signal category\n        if (highPrioritySignals.length > 0) {\n            // Generate more specific recommendations based on signal categories\n            const categories = [...new Set(highPrioritySignals.map(s => s.category))];\n            const categoryActions = {\n                'Use Case': [\n                    'Conduct business value assessment',\n                    'Review use case implementation',\n                    'Schedule stakeholder alignment call'\n                ],\n                'Architecture': [\n                    'Review technical architecture',\n                    'Optimize data connectors',\n                    'Conduct performance analysis'\n                ],\n                'Relationship': [\n                    'Map stakeholder engagement',\n                    'Schedule executive check-in',\n                    'Strengthen relationship touchpoints'\n                ],\n                'Enablement': [\n                    'Provide governance training',\n                    'Implement best practices',\n                    'Create enablement roadmap'\n                ]\n            };\n\n            const actions = categories.length > 0 && categoryActions[categories[0]]\n                ? categoryActions[categories[0]]\n                : [\n                    'Schedule executive alignment call',\n                    'Review technical implementation',\n                    'Develop adoption roadmap'\n                ];\n\n            return {\n                priority: 'immediate',\n                actions: actions\n            };\n        } else {\n            return {\n                priority: 'near-term',\n                actions: [\n                    'Regular health check',\n                    'Share best practices',\n                    'Monitor usage metrics'\n                ]\n            };\n        }\n    }\n\n    static getAccountActionContextRationale(account) {\n        const allSignals = account.signals;\n\n        // First priority: Collect all unique signal_rationale fields\n        const uniqueSignalRationales = new Set();\n        allSignals.forEach(signal => {\n            if (signal.signal_rationale &&\n                signal.signal_rationale.trim() &&\n                signal.signal_rationale !== 'No rationale specified') {\n                uniqueSignalRationales.add(signal.signal_rationale.trim());\n            }\n        });\n\n        if (uniqueSignalRationales.size > 0) {\n            const rationaleArray = Array.from(uniqueSignalRationales);\n            \n            // If multiple rationales, format as bullet points\n            if (rationaleArray.length > 1) {\n                return rationaleArray.map(rationale => `• ${rationale}`).join('<br>');\n            } else {\n                // Single rationale, format normally\n                return this.formatRationaleText(rationaleArray[0]);\n            }\n        }\n\n        // Second priority: Look for account_action_context_rationale in signals\n        for (const signal of allSignals) {\n            if (signal.account_action_context_rationale &&\n                signal.account_action_context_rationale.trim() &&\n                signal.account_action_context_rationale !== 'No rationale specified') {\n                return this.formatRationaleText(signal.account_action_context_rationale);\n            }\n        }\n\n        // Third priority: Check for signal rationale as a backup\n        for (const signal of allSignals) {\n            if (signal.rationale &&\n                signal.rationale.trim() &&\n                signal.rationale !== 'No rationale provided' &&\n                signal.rationale.length > 50) {\n                return this.formatRationaleText(signal.rationale);\n            }\n        }\n\n        // Fallback to generated rationale if no specific rationale found\n        return this.generateAccountSpecificRationale(account);\n    }\n\n    static formatRationaleText(text) {\n        // Check if text contains comma-separated items that would benefit from bullet formatting\n        if (text.includes(',') && text.length > 200) {\n            // Split on periods to identify sentences\n            const sentences = text.split(/\\.\\s+/).map(s => s.trim()).filter(s => s.length > 0);\n\n            // If we have multiple sentences, format as bullet points\n            if (sentences.length > 2) {\n                const formattedSentences = sentences.map(sentence => {\n                    // Add period back if not already there\n                    const finalSentence = sentence.endsWith('.') ? sentence : sentence + '.';\n                    return `• ${finalSentence}`;\n                }).join('<br>');\n\n                return formattedSentences;\n            }\n        }\n\n        // For shorter text or single sentences, return as-is\n        return text;\n    }\n\n    static isActionAlreadyInPlan(actionId, app) {\n        // Check if this actionId already exists in any action plan\n        if (!app || !app.actionPlans) return false;\n        \n        for (let [planId, planData] of app.actionPlans) {\n            if (planData && planData.actionId === actionId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static getActionPlanInfo(actionId, appInstance) {\n        // First check if we have a stored timestamp for this actionId\n        const actionTimestamps = this.getActionTimestamps();\n        if (actionTimestamps[actionId]) {\n            const timeSinceAdded = this.getRelativeTimestamp(actionTimestamps[actionId]);\n            return {\n                isInPlan: true,\n                timeSinceAdded: timeSinceAdded\n            };\n        }\n        \n        // Check existing action plans for this actionId\n        if (appInstance && appInstance.actionPlans) {\n            for (const [key, plan] of appInstance.actionPlans) {\n                // Check if the plan contains this actionId\n                if (plan && plan.actionId === actionId) {\n                    // Calculate time since added\n                    const timeSinceAdded = this.calculateTimeSinceAdded(plan.createdDate);\n                    return {\n                        isInPlan: true,\n                        timeSinceAdded: timeSinceAdded\n                    };\n                }\n                // Also check action items for associated signals\n                if (plan.actionItems) {\n                    for (const actionItem of plan.actionItems) {\n                        if (actionItem.associatedSignals && actionItem.associatedSignals.includes(actionId)) {\n                            const timeSinceAdded = this.calculateTimeSinceAdded(plan.createdDate);\n                            return {\n                                isInPlan: true,\n                                timeSinceAdded: timeSinceAdded\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            isInPlan: false,\n            timeSinceAdded: null\n        };\n    }\n    \n    static calculateTimeSinceAdded(createdDate) {\n        if (!createdDate) return null;\n        \n        const created = new Date(createdDate);\n        const now = new Date();\n        const diffInMs = now - created;\n        const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n        \n        if (diffInDays === 0) {\n            const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));\n            if (diffInHours === 0) {\n                const diffInMinutes = Math.floor(diffInMs / (1000 * 60));\n                return diffInMinutes === 1 ? '1 minute' : `${diffInMinutes} minutes`;\n            }\n            return diffInHours === 1 ? '1 hour' : `${diffInHours} hours`;\n        } else if (diffInDays < 7) {\n            return diffInDays === 1 ? '1 day' : `${diffInDays} days`;\n        } else if (diffInDays < 30) {\n            const weeks = Math.floor(diffInDays / 7);\n            return weeks === 1 ? '1 week' : `${weeks} weeks`;\n        } else if (diffInDays < 365) {\n            const months = Math.floor(diffInDays / 30);\n            return months === 1 ? '1 month' : `${months} months`;\n        } else {\n            const years = Math.floor(diffInDays / 365);\n            return years === 1 ? '1 year' : `${years} years`;\n        }\n    }\n\n    static getMergedRecommendationsAndRationale(account, filterPolarities = null) {\n        const actionDataMap = new Map();\n        \n        // Filter signals by polarity if specified\n        let signalsToProcess = account.signals;\n        if (filterPolarities && Array.isArray(filterPolarities)) {\n            signalsToProcess = account.signals.filter(signal => {\n                const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n                return filterPolarities.includes(polarity);\n            });\n        }\n        \n        // Create map of recommended_action to data object with priority, date, and action_id\n        signalsToProcess.forEach((signal, index) => {\n            // Extra validation to ensure signal belongs to this account\n            if (signal.account_id !== account.id) {\n                console.error(`ERROR: Signal ${signal.id} has account_id ${signal.account_id} but is in account ${account.id} signals array!`);\n                return; // Skip this signal as it doesn't belong to this account\n            }\n            \n            if (signal.recommended_action && \n                signal.recommended_action.trim() && \n                signal.recommended_action !== 'No actions specified' &&\n                signal.action_id &&\n                signal.action_id.trim()) {\n                \n                const action = signal.recommended_action.trim();\n                const actionId = signal.action_id;\n                const priority = signal.priority || 'Medium';\n                \n                // Get the date from the RecommendedAction object (when the action was created)\n                const signalsStore = window.signalsStore;\n                const recommendedAction = signalsStore?.normalizedData?.recommendedActions?.get(actionId);\n                const date = recommendedAction?.created_at || signal.call_date || signal.created_date || '';\n                \n                // Get Signal Polarity from signal\n                const signalPolarity = signal.signal_polarity || signal['Signal Polarity'] || 'Enrichment';\n                const polarityClass = signalPolarity.toLowerCase();\n                \n                if (!actionDataMap.has(action)) {\n                    const actionData = {\n                        date: date,\n                        actionId: actionId,\n                        accountId: account.id,\n                        priority: priority,\n                        signalPolarity: signalPolarity,\n                        polarityClass: polarityClass,\n                        rationale: signal.signal_rationale || ''\n                    };\n                    actionDataMap.set(action, actionData);\n                }\n            }\n        });\n        \n        // If we have action items, display them in the new list format\n        if (actionDataMap.size > 0) {\n            // Get account-level polarity class for consistent color coding\n            const accountPolarityClass = this.getAccountPolarityClass(account);\n            \n            return Array.from(actionDataMap.entries()).slice(0, 5).map(([action, data]) => {\n                // Check if already in plan and calculate time since added\n                const planInfo = this.getActionPlanInfo(data.actionId, window.app);\n                const isInPlan = planInfo.isInPlan;\n                const timeSinceAdded = planInfo.timeSinceAdded;\n                \n                // Get related calls for this action\n                const relatedCalls = this.getRelatedCallsForAction(data.actionId, account);\n                \n                // Count signals by polarity for this action_id\n                const polarityCounts = { risk: 0, opportunities: 0, enrichment: 0 };\n                account.signals.forEach(signal => {\n                    if (signal.action_id === data.actionId) {\n                        const polarity = signal.signal_polarity || signal['Signal Polarity'] || '';\n                        const normalizedPolarity = FormatUtils.normalizePolarityKey(polarity);\n                        if (normalizedPolarity === 'risk') {\n                            polarityCounts.risk++;\n                        } else if (normalizedPolarity === 'opportunities') {\n                            polarityCounts.opportunities++;\n                        } else {\n                            polarityCounts.enrichment++;\n                        }\n                    }\n                });\n                \n                return `\n                    <div class=\"recommendation-list-item\">\n                        <div class=\"recommendation-content\">\n                            <div class=\"recommendation-text\">\n                                ${SecurityUtils.sanitizeHTML(action)}\n                            </div>\n                            ${data.rationale ? `\n                                <div class=\"recommendation-rationale\">\n                                    <div class=\"polarity-bubbles\">\n                                        <div class=\"polarity-bubble polarity-bubble-risk\" title=\"${polarityCounts.risk} Risk signals\">${polarityCounts.risk}</div>\n                                        <div class=\"polarity-bubble polarity-bubble-opportunities\" title=\"${polarityCounts.opportunities} Opportunities signals\">${polarityCounts.opportunities}</div>\n                                        <div class=\"polarity-bubble polarity-bubble-enrichment\" title=\"${polarityCounts.enrichment} Enrichment signals\">${polarityCounts.enrichment}</div>\n                                    </div>\n                                    <br>\n                                    ${SecurityUtils.sanitizeHTML(data.rationale)}\n                                </div>\n                            ` : ''}\n                            ${relatedCalls.length > 0 ? `\n                                <div class=\"related-calls-section\">\n                                    <span class=\"related-calls-label\">Related Calls:</span>\n                                    <div class=\"related-calls-list\">\n                                        ${relatedCalls.map((call, index) => {\n                                            const callData = JSON.stringify({\n                                                title: call.title,\n                                                date: call.date,\n                                                attendees: call.attendees,\n                                                recap: call.recap,\n                                                url: call.url,\n                                                relatedSignals: call.relatedSignals\n                                            }).replace(/\"/g, '&quot;');\n                                            \n                                            return `<span class=\"call-link\" data-call-info=\"${callData}\">${SecurityUtils.sanitizeHTML(call.title)}</span>${index < relatedCalls.length - 1 ? ', ' : ''}`;\n                                        }).join('')}\n                                    </div>\n                                </div>\n                            ` : ''}\n                        </div>\n                        <div class=\"recommendation-date\">\n                            ${FormatUtils.formatDateSimple(data.date)}\n                        </div>\n                        <div class=\"recommendation-action-button\">\n                            ${isInPlan ? \n                                `<span class=\"btn-added-status\">${timeSinceAdded ? `Added ${timeSinceAdded} ago` : 'Added!'}</span>` : \n                                `<button class=\"btn-add-to-plan\" data-action-id=\"${data.actionId}\" data-action-title=\"${action}\" data-account-id=\"${data.accountId}\" onclick=\"PortfolioRenderer.openAddToPlanDrawer('${data.actionId}', '${action.replace(/'/g, \"\\\\'\")}', '${data.accountId}')\">\n                                    Add to Plan\n                                </button>`\n                            }\n                        </div>\n                    </div>\n                `;\n            }).join('');\n        }\n        \n        // Note: We only show recommendations that have actual action_ids from signals\n        // This ensures that CS plays are available for each recommendation\n        \n        // Only show \"No recommendations\" if truly no recommendations exist\n        return `\n            <div class=\"recommendation-list-item\">\n                <div class=\"no-recommendations-message\">\n                    No AI recommendations available for this account.\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Get account-level polarity color class based on all recommendations\n     * @param {Object} account - The account object containing signals\n     * @returns {string} - Color class ('risk', 'opportunities', or 'enrichment')\n     */\n    static getAccountPolarityClass(account) {\n        if (!account || !account.signals) {\n            return 'enrichment';\n        }\n        \n        const polarities = new Set();\n        \n        // Extract polarities from all signals that have recommended actions and action_ids\n        account.signals.forEach(signal => {\n            if (signal.recommended_action && \n                signal.recommended_action.trim() && \n                signal.recommended_action !== 'No actions specified' &&\n                signal.action_id &&\n                signal.action_id.trim()) {\n                const polarity = signal.signal_polarity || signal['Signal Polarity'] || 'Enrichment';\n                polarities.add(polarity.toLowerCase());\n            }\n        });\n        \n        // Priority logic: Risk > Opportunities > Enrichment\n        if (polarities.has('risk')) {\n            return 'risk';\n        } else if (polarities.has('opportunities') && !polarities.has('risk')) {\n            return 'opportunities';\n        } else {\n            return 'enrichment';\n        }\n    }\n\n    static getUniqueRecommendedActions(account) {\n        const uniqueActions = new Set();\n        \n        // Extract recommended_action from all signals for this account - ONLY if they have action_id\n        account.signals.forEach(signal => {\n            if (signal.recommended_action && \n                signal.recommended_action.trim() && \n                signal.recommended_action !== 'No actions specified' &&\n                signal.action_id &&\n                signal.action_id.trim()) {\n                uniqueActions.add(signal.recommended_action.trim());\n            }\n        });\n        \n        // Convert Set to Array\n        const actionsArray = Array.from(uniqueActions);\n        \n        // Only return specific recommended actions that have action_ids - no fallback\n        return actionsArray;\n    }\n\n\n    /**\n     * Get related calls for a specific action ID\n     * @param {string} actionId - The action ID to find related calls for\n     * @param {Object} account - The account object containing signals\n     * @returns {Array} Array of unique call objects with title, date, attendees, and related signals\n     */\n    static getRelatedCallsForAction(actionId, account) {\n        if (!actionId || !account || !account.signals) {\n            return [];\n        }\n        \n        const callsMap = new Map(); // Use Map to ensure unique calls by title\n        \n        // Find all signals with this actionId\n        account.signals.forEach(signal => {\n            if (signal.action_id === actionId && signal.call_context) {\n                const callContext = signal.call_context;\n                const callTitle = callContext.call_title;\n                \n                // Only include calls that have a title\n                if (callTitle && callTitle.trim()) {\n                    if (!callsMap.has(callTitle)) {\n                        callsMap.set(callTitle, {\n                            title: callTitle,\n                            date: callContext.call_date || callContext.call_scheduled_date || '',\n                            attendees: callContext.call_attendees || '',\n                            recap: callContext.call_recap || '',\n                            url: callContext.call_url || callContext['Call URL'] || '',\n                            relatedSignals: []\n                        });\n                    }\n                    \n                    // Add this signal to the related signals list\n                    callsMap.get(callTitle).relatedSignals.push({\n                        id: signal.signal_id,\n                        name: signal.name,\n                        summary: signal.summary || '',\n                        priority: signal.priority,\n                        polarity: signal.signal_polarity\n                    });\n                }\n            }\n        });\n        \n        return Array.from(callsMap.values());\n    }\n\n    static formatTenure(years) {\n        if (years < 1) {\n            const months = Math.round(years * 12);\n            return `${months}m`;\n        } else {\n            return `${years.toFixed(1)}y`;\n        }\n    }\n\n    static formatCurrencyDetailed(amount) {\n        if (amount >= 1000000) {\n            return `$${(amount / 1000000).toFixed(1)}M`;\n        } else if (amount >= 1000) {\n            return `$${(amount / 1000).toFixed(1)}K`;\n        } else {\n            return `$${amount.toFixed(0)}`;\n        }\n    }\n\n    static formatForecastWithDelta(delta) {\n        const deltaFormatted = this.formatCurrencyDetailed(Math.abs(delta));\n        const sign = delta >= 0 ? '+' : '-';\n        const color = delta >= 0 ? 'positive' : 'negative';\n        \n        return `<span class=\"delta ${color}\">${sign}${deltaFormatted}</span>`;\n    }\n\n    /**\n     * Initialize click functionality for call links\n     * Should be called after rendering the portfolio\n     */\n    static initializeCallTooltips() {\n        // Remove any existing modals first\n        const existingModals = document.querySelectorAll('.call-modal');\n        existingModals.forEach(modal => modal.remove());\n        \n        // Add click event listeners to all call links\n        const callLinks = document.querySelectorAll('.call-link');\n        callLinks.forEach(link => {\n            link.addEventListener('click', (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                this.showCallModal(e);\n            });\n        });\n        \n        // Close modal when clicking outside\n        document.addEventListener('click', (e) => {\n            if (e.target.classList.contains('call-modal-overlay')) {\n                this.hideCallModal();\n            }\n        });\n    }\n    \n    /**\n     * Show call modal on click\n     * @param {Event} event - Click event\n     */\n    static showCallModal(event) {\n        // Hide any existing modal first\n        this.hideCallModal();\n        \n        const callLink = event.target;\n        const callData = JSON.parse(callLink.getAttribute('data-call-info').replace(/&quot;/g, '\"'));\n        \n        // Create modal overlay\n        const modalOverlay = document.createElement('div');\n        modalOverlay.className = 'call-modal-overlay';\n        modalOverlay.id = 'call-modal-overlay';\n        \n        // Create modal content\n        const modal = document.createElement('div');\n        modal.className = 'call-modal';\n        modal.id = 'call-modal';\n        \n        // Build modal content\n        let modalHTML = `\n            <div class=\"call-modal-header\">\n                <div class=\"call-modal-title-section\">\n                    <div class=\"call-modal-title\">${SecurityUtils.sanitizeHTML(callData.title)}</div>\n                    ${callData.url ? `<a href=\"${SecurityUtils.sanitizeHTML(callData.url)}\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"call-modal-link\">\n                        <i class=\"fas fa-external-link-alt\"></i> View Call\n                    </a>` : ''}\n                </div>\n                <button class=\"call-modal-close\" onclick=\"PortfolioRenderer.hideCallModal()\">&times;</button>\n            </div>\n            <div class=\"call-modal-content\">\n        `;\n        \n        if (callData.date) {\n            modalHTML += `<div class=\"call-modal-date\"><strong>Date:</strong> ${FormatUtils.formatDateSimple(callData.date)}</div>`;\n        }\n        \n        if (callData.attendees) {\n            modalHTML += `<div class=\"call-modal-attendees\"><strong>Attendees:</strong> ${SecurityUtils.sanitizeHTML(callData.attendees)}</div>`;\n        }\n        \n        if (callData.recap) {\n            modalHTML += `\n                <div class=\"call-modal-recap\">\n                    <strong>Call Recap:</strong>\n                    <div class=\"call-modal-recap-content\">${SecurityUtils.sanitizeHTML(callData.recap)}</div>\n                </div>\n            `;\n        }\n        \n        if (callData.relatedSignals && callData.relatedSignals.length > 0) {\n            modalHTML += `\n                <div class=\"call-modal-signals\">\n                    <div class=\"call-modal-signals-title\"><strong>Related Signals:</strong></div>\n                    <div class=\"call-modal-signals-list\">\n                        ${callData.relatedSignals.map(signal => {\n                            // Get signal polarity and normalize it - using 'polarity' field from getRelatedCallsForAction\n                            const polarity = signal.polarity || 'Enrichment';\n                            const normalizedPolarity = FormatUtils.normalizePolarityKey(polarity);\n                            const polarityDisplay = normalizedPolarity === 'opportunities' ? 'Opportunity' : \n                                                   normalizedPolarity === 'risk' ? 'Risk' : 'Enrichment';\n                            const polarityClass = normalizedPolarity === 'opportunities' ? 'polarity-opportunities' : \n                                                 normalizedPolarity === 'risk' ? 'polarity-risk' : 'polarity-enrichment';\n                            \n                            return `\n                            <div class=\"call-modal-signal\">\n                                <div class=\"call-modal-signal-header\">\n                                    <span class=\"call-modal-signal-priority ${polarityClass}\">${polarityDisplay}</span>\n                                    <span class=\"call-modal-signal-name\">${SecurityUtils.sanitizeHTML(signal.name)}</span>\n                                </div>\n                                ${signal.summary ? `<div class=\"call-modal-signal-summary\">${SecurityUtils.sanitizeHTML(signal.summary)}</div>` : ''}\n                            </div>\n                            `;\n                        }).join('')}\n                    </div>\n                </div>\n            `;\n        }\n        \n        modalHTML += `</div>`;\n        \n        modal.innerHTML = modalHTML;\n        modalOverlay.appendChild(modal);\n        document.body.appendChild(modalOverlay);\n        \n        // Show modal with animation\n        setTimeout(() => modalOverlay.classList.add('show'), 10);\n    }\n    \n    /**\n     * Hide call modal\n     */\n    static hideCallModal() {\n        const modalOverlay = document.getElementById('call-modal-overlay');\n        if (modalOverlay) {\n            modalOverlay.classList.remove('show');\n            setTimeout(() => modalOverlay.remove(), 200);\n        }\n    }\n\n    static openAddToPlanDrawer(actionId, actionTitle, accountId) {\n        // Store current action data\n        window.currentDrawerData = {\n            actionId: actionId,\n            actionTitle: actionTitle,\n            accountId: accountId\n        };\n        \n        // Show the drawer\n        const drawer = document.getElementById('addToPlanDrawer');\n        const backdrop = document.getElementById('addToPlanDrawerBackdrop');\n        \n        drawer.classList.add('open');\n        backdrop.classList.add('open');\n        \n        // Set the action title\n        document.getElementById('drawerActionTitle').textContent = actionTitle;\n        \n        // Clear previous plan details\n        document.getElementById('drawerPlanDetails').value = '';\n        \n        // Load CS plays specific to this action_id\n        this.loadDrawerCSPlays(actionId);\n        \n        // Add backdrop click to close\n        backdrop.addEventListener('click', () => {\n            this.closeAddToPlanDrawer();\n        });\n    }\n\n    static closeAddToPlanDrawer() {\n        const drawer = document.getElementById('addToPlanDrawer');\n        const backdrop = document.getElementById('addToPlanDrawerBackdrop');\n        \n        drawer.classList.remove('open');\n        backdrop.classList.remove('open');\n        \n        // Clear any errors when closing\n        this.clearDrawerError();\n        \n        window.currentDrawerData = null;\n    }\n    \n    static isAccountExpanded(accountId) {\n        const signalsContainer = document.getElementById(`signals-${accountId}`);\n        return signalsContainer && signalsContainer.classList.contains('expanded');\n    }\n    \n    static expandAccount(accountId) {\n        const signalsContainer = document.getElementById(`signals-${accountId}`);\n        const chevron = document.getElementById(`chevron-${accountId}`);\n        if (signalsContainer) {\n            signalsContainer.classList.add('expanded');\n            if (chevron) {\n                chevron.classList.add('rotated');\n            }\n        }\n    }\n\n    static truncateText(text, maxLength) {\n        if (!text || text.length <= maxLength) return text;\n        return text.substring(0, maxLength).trim() + '...';\n    }\n\n    static loadDrawerCSPlays(actionId) {\n        // Find plays for this action_id from the normalized data model\n        let csPlays = [];\n        \n        // Get the normalized store directly to access recommended actions\n        const store = window.signalsStore;\n        if (!store || !actionId) {\n            console.warn('Cannot load plays: store or actionId not available');\n        } else {\n            // Try to get the recommended action from normalized data\n            let recommendedAction = null;\n            \n            // Check if we have the getRecommendedAction method\n            if (store.getRecommendedAction && typeof store.getRecommendedAction === 'function') {\n                recommendedAction = store.getRecommendedAction(actionId);\n            } else if (store.normalizedData && store.normalizedData.recommendedActions) {\n                // Direct access to normalized data\n                recommendedAction = store.normalizedData.recommendedActions.get(actionId);\n            }\n            \n            // If we found the recommended action, extract its plays\n            if (recommendedAction && recommendedAction.plays && Array.isArray(recommendedAction.plays)) {\n                csPlays = recommendedAction.plays.filter(play => \n                    play && play.name && play.name.trim() && \n                    play.name !== 'N/A' && play.name !== ''\n                ).map(play => ({\n                    title: play.name || play.title || '',\n                    description: play.description || play.full_description || 'No description available',\n                    executingRole: play.executing_role || play.executingRole || 'Adoption Consulting'\n                }));\n            } else {\n                // Fallback: Try to find plays from denormalized signals\n                const state = store.getState ? store.getState() : store.state;\n                const signals = state?.signals || [];\n                \n                if (signals.length > 0) {\n                    const signal = signals.find(s => s.action_id === actionId);\n                    \n                    if (signal && signal.plays && Array.isArray(signal.plays)) {\n                        // Use plays array from denormalized signal\n                        csPlays = signal.plays.filter(play => \n                            play && play.name && play.name.trim() && \n                            play.name !== 'N/A' && play.name !== ''\n                        ).map(play => ({\n                            title: play.name || play.title || '',\n                            description: play.description || play.full_description || 'No description available',\n                            executingRole: play.executing_role || play.executingRole || 'Adoption Consulting'\n                        }));\n                    }\n                }\n            }\n        }\n        \n        const playsContainer = document.getElementById('drawerPlaysContainer');\n        if (!playsContainer) {\n            console.error('drawerPlaysContainer element not found!');\n            return;\n        }\n        \n        // Show message if no plays found, otherwise show checkboxes\n        if (csPlays.length === 0) {\n            playsContainer.innerHTML = '<p class=\"no-plays-message\">No recommended plays for this action.</p>';\n        } else {\n            // Ensure we have a valid array of play objects\n            const validPlays = csPlays.filter(play => play && play.title && play.title.trim().length > 0);\n            \n            if (validPlays.length === 0) {\n                playsContainer.innerHTML = '<p class=\"no-plays-message\">No valid plays found.</p>';\n                return;\n            }\n            \n            const playCheckboxes = validPlays.map((play, index) => {\n                return `\n                    <div class=\"drawer-play-item\">\n                        <input type=\"checkbox\" id=\"drawerPlay${index}\" value=\"${play.title}\" checked>\n                        <label for=\"drawerPlay${index}\" class=\"drawer-play-label\">\n                            <div class=\"play-header\">\n                                <span class=\"play-title\">${play.title}</span>\n                            </div>\n                            <div class=\"play-description\">${this.truncateText(play.description, 250)}</div>\n                            <div class=\"play-owner\">\n                                <span class=\"play-owner-label\">Play Owner:</span>\n                                <span class=\"play-owner-value\">${play.executingRole || 'Not specified'}</span>\n                            </div>\n                        </label>\n                    </div>\n                `;\n            }).join('');\n            \n            playsContainer.innerHTML = playCheckboxes;\n        }\n    }\n\n    static async createPlanFromDrawer() {\n        if (!window.currentDrawerData) return;\n        \n        // Clear any previous errors\n        this.clearDrawerError();\n        \n        const actionId = window.currentDrawerData.actionId;\n        const actionTitle = window.currentDrawerData.actionTitle;\n        const accountId = window.currentDrawerData.accountId;\n        const planDetails = document.getElementById('drawerPlanDetails').value;\n        \n        // Get selected plays\n        const selectedPlays = Array.from(document.querySelectorAll('#drawerPlaysContainer input[type=\"checkbox\"]:checked'))\n            .map(checkbox => checkbox.value);\n        \n        // Get current user info for assignee\n        let userName = 'Current User';\n        let userId = 621623466; // Default numeric ID\n        \n        try {\n            const user = await domo.get(`/domo/environment/v1/`);\n            if (user && typeof user === 'object') {\n                userId = parseInt(user.userId) || parseInt(user.id) || userId;\n                userName = user.userName || user.name || user.displayName || userName;\n            }\n        } catch (error) {\n            console.warn('Could not get user info, using defaults:', error);\n        }\n        \n        // Get signal polarity from the signal with this actionId\n        let signalPolarity = 'Enrichment'; // Default value\n        const store = window.signalsStore;\n        if (store) {\n            const state = store.getState ? store.getState() : store.state;\n            const signals = state?.signals || [];\n            const signalWithAction = signals.find(s => s.action_id === actionId);\n            if (signalWithAction) {\n                signalPolarity = signalWithAction.signal_polarity || signalWithAction['Signal Polarity'] || 'Enrichment';\n            }\n        }\n        \n        // Set due date to TODAY + 7 days\n        const today = new Date();\n        const dueDate = new Date(today.getTime() + (7 * 24 * 60 * 60 * 1000));\n        const dueDateString = dueDate.toISOString().split('T')[0]; // Format as YYYY-MM-DD\n        \n        // Format plan title as \"Action Plan - MM/DD/YYYY\"\n        const planDate = today.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' });\n        const planTitle = `Action Plan - ${planDate}`;\n        \n        // Create the plan data structure matching exact database model\n        const planData = {\n            accountId: accountId,\n            actionId: actionId,\n            title: actionTitle,\n            description: planDetails,\n            plays: selectedPlays,\n            status: 'pending',\n            priority: 'Medium', // Capitalized\n            dueDate: dueDateString, // YYYY-MM-DD format\n            assignee: userId, // Numeric ID\n            createdDate: new Date().toISOString(),\n            planTitle: planTitle,\n            createdBy: userName,\n            createdByUserId: userId,\n            signalPolarity: signalPolarity // NEW FIELD\n        };\n        \n        try {\n            // 🎯 OPTIMISTIC UI: Update specific action button immediately\n            this.updateSpecificActionButton(actionId, 'added');\n            \n            // Store plan creation timestamp for this specific action\n            this.storePlanCreationTimestamp(actionId);\n            \n            // 🔄 USE PROPER FLUX ARCHITECTURE: ActionPlansService for real persistence\n            const result = await ActionPlansService.createActionPlan(\n                actionId,\n                accountId,\n                actionTitle,\n                planDetails,\n                selectedPlays, // Pass plays as-is (strings or objects)\n                userId,\n                userName,\n                planTitle,\n                dueDateString,\n                'Medium', // Priority\n                signalPolarity // Pass signal polarity\n            );\n            \n            if (result) {\n                // console.log('Plan created successfully from drawer:', result.plan);\n                \n                // ActionPlansService already handles state updates through Flux\n                // No need for manual state management here\n                \n                // Store expanded account state before closing drawer\n                const wasAccountExpanded = this.isAccountExpanded(accountId);\n                \n                // Close drawer\n                this.closeAddToPlanDrawer();\n                \n                // Show success notification first\n                if (window.app && window.app.notificationService) {\n                    window.app.notificationService.showNotification('🎉 Action plan created successfully!', 'success');\n                }\n                \n                // Refresh the portfolio view to show updated state\n                if (window.app && window.app.renderCurrentTab) {\n                    window.app.renderCurrentTab();\n                    \n                    // Restore expanded account state after render is complete\n                    if (wasAccountExpanded) {\n                        setTimeout(() => {\n                            this.expandAccount(accountId);\n                        }, 150);\n                    }\n                }\n            } else {\n                console.error('Failed to create plan from drawer:', result ? result.error : 'Unknown error');\n                \n                // 🔄 REVERT OPTIMISTIC UI: Reset button state and clear timestamp on error\n                this.updateSpecificActionButton(actionId, 'default');\n                this.clearPlanCreationTimestamp(actionId); // Clean up optimistic timestamp\n                \n                this.showDrawerError('Failed to create action plan. Please check your connection and try again.');\n            }\n        } catch (error) {\n            console.error('Error creating plan from drawer:', error);\n            \n            // 🔄 REVERT OPTIMISTIC UI: Reset button state and clear timestamp on error\n            this.updateSpecificActionButton(actionId, 'default');\n            this.clearPlanCreationTimestamp(actionId); // Clean up optimistic timestamp\n            \n            // Handle specific error types for better user experience\n            if (error.message && error.message.includes('Failed to fetch')) {\n                this.showDrawerError('Unable to connect to the server. Please check your internet connection and try again.');\n            } else if (error.message && error.message.includes('404')) {\n                this.showDrawerError('Action Plan service endpoint not found. Please contact your administrator.');\n            } else {\n                this.showDrawerError('An unexpected error occurred while creating the action plan. Please try again.');\n            }\n        }\n    }\n\n    static showDrawerError(message) {\n        const errorElement = document.getElementById('planDrawerError');\n        if (errorElement) {\n            errorElement.textContent = message;\n            errorElement.style.display = 'block';\n        }\n    }\n\n    static clearDrawerError() {\n        const errorElement = document.getElementById('planDrawerError');\n        if (errorElement) {\n            errorElement.style.display = 'none';\n            errorElement.textContent = '';\n        }\n    }\n\n    static hasExistingPlan(accountId, app) {\n        // Check Map-based plans first\n        if (app.actionPlans && app.actionPlans.has && app.actionPlans.has(accountId)) {\n            return true;\n        }\n        \n        // Check Array-based plans\n        if (Array.isArray(app.actionPlans)) {\n            return app.actionPlans.some(plan => plan.accountId === accountId);\n        }\n        \n        // Check DataService plans by account if available\n        if (window.DataService && window.DataService.actionPlansByAccount) {\n            const accountPlans = window.DataService.actionPlansByAccount.get(accountId);\n            return accountPlans && accountPlans.length > 0;\n        }\n        \n        // Check if any action plan exists for signals belonging to this account\n        const account = app.accounts.get(accountId);\n        if (account && account.signals) {\n            return account.signals.some(signal => {\n                if (app.actionPlans && app.actionPlans.has) {\n                    return app.actionPlans.has(signal.id);\n                }\n                if (Array.isArray(app.actionPlans)) {\n                    return app.actionPlans.some(plan => plan.signalId === signal.id);\n                }\n                return false;\n            });\n        }\n        \n        return false;\n    }\n\n    static generateAccountSpecificRationale(account) {\n        const highPrioritySignals = account.signals.filter(s => s.priority === 'High');\n        const totalSignals = account.signals.length;\n        const industry = account.industry || 'Industry';\n        const health = account.health;\n\n        if (highPrioritySignals.length > 1) {\n            return `${account.name} has ${highPrioritySignals.length} high-priority signals indicating potential risks to renewal. As a ${industry.toLowerCase()} company with ${health} health status, immediate executive alignment is critical to address implementation gaps and ensure platform adoption success. Quick action now will prevent escalation and maintain the strategic partnership.`;\n        } else if (highPrioritySignals.length === 1) {\n            const signal = highPrioritySignals[0];\n            const signalType = signal.category.toLowerCase();\n\n            if (signalType.includes('relationship')) {\n                return `The relationship signal for ${account.name} suggests stakeholder gaps that could impact renewal decisions. In the ${industry.toLowerCase()} sector, maintaining strong executive relationships is essential for platform expansion. Addressing this proactively will strengthen partnership and unlock growth opportunities.`;\n            } else if (signalType.includes('use case')) {\n                return `${account.name}'s use case signal indicates untapped value potential. For ${industry.toLowerCase()} organizations, demonstrating clear ROI through expanded use cases drives platform stickiness. Acting on this opportunity will increase consumption and justify continued investment.`;\n            } else if (signalType.includes('architecture')) {\n                return `Technical architecture concerns at ${account.name} could impact data reliability and user experience. ${industry} companies rely heavily on data accuracy for decision-making. Resolving these technical challenges will improve user satisfaction and prevent churn.`;\n            } else {\n                return `${account.name}'s signal requires immediate attention to maintain account health. Given their ${industry.toLowerCase()} focus and current ${health} status, these recommended actions will address key concerns and strengthen the customer relationship for long-term success.`;\n            }\n        } else {\n            return `While ${account.name} shows ${health} overall health, proactive engagement in the ${industry.toLowerCase()} sector is key to identifying expansion opportunities and preventing any emerging risks. These actions will strengthen the partnership and drive continued growth.`;\n        }\n    }\n\n    // 🎯 OPTIMISTIC UI & TIMESTAMP TRACKING METHODS\n\n    /**\n     * Update specific action button by actionId\n     * @param {string} actionId - Action ID\n     * @param {string} state - Button state ('added', 'default')\n     */\n    static updateSpecificActionButton(actionId, state) {\n        // Find the specific button for this actionId\n        const button = document.querySelector(`[data-action-id=\"${actionId}\"]`);\n        \n        if (button) {\n            if (state === 'added') {\n                // Get relative timestamp for display\n                const timestamp = this.getActionTimestamps()[actionId];\n                const relativeTime = this.getRelativeTimestamp(timestamp);\n                \n                button.classList.remove('btn-add-to-plan');\n                button.classList.add('btn-added-status');\n                button.textContent = relativeTime !== 'Add to Plan' ? relativeTime : 'Added!';\n                button.disabled = true;\n                \n                // Remove the onclick handler to prevent accidental clicks\n                button.removeAttribute('onclick');\n            } else {\n                button.classList.remove('btn-added-status');\n                button.classList.add('btn-add-to-plan');\n                button.textContent = 'Add to Plan';\n                button.disabled = false;\n            }\n        }\n    }\n\n    /**\n     * Store action plan creation timestamp for a specific actionId\n     * @param {string} actionId - Action ID\n     */\n    static storePlanCreationTimestamp(actionId) {\n        const timestamp = Date.now();\n        const actionTimestamps = this.getActionTimestamps();\n        actionTimestamps[actionId] = timestamp;\n        \n        try {\n            localStorage.setItem('signalsai_action_timestamps', JSON.stringify(actionTimestamps));\n        } catch (error) {\n            console.warn('Could not store action timestamp:', error);\n        }\n    }\n\n    /**\n     * Get all action timestamps from localStorage\n     * @returns {Object} Object with actionId -> timestamp mappings\n     */\n    static getActionTimestamps() {\n        try {\n            const stored = localStorage.getItem('signalsai_action_timestamps');\n            return stored ? JSON.parse(stored) : {};\n        } catch (error) {\n            console.warn('Could not load action timestamps:', error);\n            return {};\n        }\n    }\n\n    /**\n     * Clear action plan creation timestamp for a specific actionId\n     * @param {string} actionId - Action ID\n     */\n    static clearPlanCreationTimestamp(actionId) {\n        if (!actionId) {\n            console.warn('⚠️ Cannot clear action timestamp: actionId is null or undefined');\n            return;\n        }\n        \n        try {\n            const actionTimestamps = this.getActionTimestamps();\n            if (actionTimestamps[actionId]) {\n                delete actionTimestamps[actionId];\n                localStorage.setItem('signalsai_action_timestamps', JSON.stringify(actionTimestamps));\n                console.log(`🧹 Cleared action timestamp for action ${actionId}`);\n            } else {\n                console.log(`ℹ️ No timestamp to clear for action ${actionId}`);\n            }\n        } catch (error) {\n            console.warn('Could not clear action timestamp:', error);\n        }\n    }\n\n    /**\n     * Update the \"Add to Plan\" button state with optimistic UI (legacy method for account-level updates)\n     * @param {string} accountId - Account ID\n     * @param {string} state - Button state ('added-today', 'added', 'default')\n     */\n    static updateAddToPlanButtonState(accountId, state) {\n        const containers = document.querySelectorAll(`[data-account-id=\"${accountId}\"] .recommendation-action-button`);\n        \n        containers.forEach(container => {\n            const button = container.querySelector('.btn-add-to-plan');\n            if (!button) return;\n            \n            if (state === 'added-today') {\n                button.classList.remove('btn-add-to-plan');\n                button.classList.add('btn-added-status');\n                button.textContent = 'Added Today';\n                button.disabled = true;\n            } else if (state === 'added') {\n                const timestamp = this.getPlanCreationTimestamp(accountId);\n                const relativeTime = this.getRelativeTimestamp(timestamp);\n                button.classList.remove('btn-add-to-plan');\n                button.classList.add('btn-added-status');\n                button.textContent = relativeTime;\n                button.disabled = true;\n            } else {\n                button.classList.remove('btn-added-status');\n                button.classList.add('btn-add-to-plan');\n                button.textContent = 'Add to Plan';\n                button.disabled = false;\n            }\n        });\n    }\n\n    /**\n     * Store plan creation timestamp for an account\n     * @param {string} accountId - Account ID\n     */\n    static storePlanCreationTimestamp(accountId) {\n        const timestamp = Date.now();\n        const planTimestamps = this.getPlanTimestamps();\n        planTimestamps[accountId] = timestamp;\n        \n        try {\n            localStorage.setItem('signalsai_plan_timestamps', JSON.stringify(planTimestamps));\n        } catch (error) {\n            console.warn('Could not store plan timestamp:', error);\n        }\n    }\n\n    /**\n     * Get plan creation timestamp for an account\n     * @param {string} accountId - Account ID\n     * @returns {number|null} Timestamp or null if not found\n     */\n    static getPlanCreationTimestamp(accountId) {\n        const planTimestamps = this.getPlanTimestamps();\n        return planTimestamps[accountId] || null;\n    }\n\n    /**\n     * Get all plan timestamps from localStorage\n     * @returns {Object} Object with accountId -> timestamp mappings\n     */\n    static getPlanTimestamps() {\n        try {\n            const stored = localStorage.getItem('signalsai_plan_timestamps');\n            return stored ? JSON.parse(stored) : {};\n        } catch (error) {\n            console.warn('Could not load plan timestamps:', error);\n            return {};\n        }\n    }\n\n    /**\n     * Clear plan creation timestamp for an account (for cleanup on failures)\n     * @param {string} accountId - Account ID\n     */\n    static clearPlanCreationTimestamp(accountId) {\n        if (!accountId) {\n            console.warn('⚠️ Cannot clear plan timestamp: accountId is null or undefined');\n            return;\n        }\n        \n        try {\n            const planTimestamps = this.getPlanTimestamps();\n            if (planTimestamps[accountId]) {\n                delete planTimestamps[accountId];\n                localStorage.setItem('signalsai_plan_timestamps', JSON.stringify(planTimestamps));\n                console.log(`🧹 Cleared plan timestamp for account ${accountId}`);\n            } else {\n                console.log(`ℹ️ No timestamp to clear for account ${accountId}`);\n            }\n        } catch (error) {\n            console.warn('Could not clear plan timestamp:', error);\n        }\n    }\n\n    /**\n     * Convert timestamp to relative time display (always rounds up)\n     * @param {number} timestamp - Unix timestamp\n     * @returns {string} Relative time string\n     */\n    static getRelativeTimestamp(timestamp) {\n        if (!timestamp) return 'Add to Plan';\n        \n        const now = Date.now();\n        const diffMs = now - timestamp;\n        \n        // Calculate time units (always round up)\n        const diffMinutes = Math.ceil(diffMs / (1000 * 60));\n        const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));\n        const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n        const diffWeeks = Math.ceil(diffDays / 7);\n        const diffMonths = Math.ceil(diffDays / 30);\n        \n        if (diffMinutes < 60) {\n            return diffMinutes === 1 ? 'Added 1 minute ago' : `Added ${diffMinutes} minutes ago`;\n        } else if (diffHours < 24) {\n            return diffHours === 1 ? 'Added 1 hour ago' : `Added ${diffHours} hours ago`;\n        } else if (diffDays < 7) {\n            return diffDays === 1 ? 'Added 1 day ago' : `Added ${diffDays} days ago`;\n        } else if (diffWeeks < 4) {\n            return diffWeeks === 1 ? 'Added 1 week ago' : `Added ${diffWeeks} weeks ago`;\n        } else {\n            return diffMonths === 1 ? 'Added 1 month ago' : `Added ${diffMonths} months ago`;\n        }\n    }\n\n    /**\n     * Initialize button states based on stored timestamps\n     * Call this when rendering the portfolio\n     * @param {Object} app - App state\n     */\n    static initializePlanButtonStates(app) {\n        const planTimestamps = this.getPlanTimestamps();\n        \n        Object.keys(planTimestamps).forEach(accountId => {\n            if (this.hasExistingPlan(accountId, app)) {\n                this.updateAddToPlanButtonState(accountId, 'added');\n            }\n        });\n    }\n}","size_bytes":79897},"js/SignalRenderer.js":{"content":"// Signal Renderer - Pure view for rendering signal feed\nclass SignalRenderer {\n    \n    static virtualScrollManager = null;\n    static cachedSignals = [];\n    static lastRenderTime = 0;\n\n    static renderSignalFeed(signals, viewState, comments, interactions, actionPlans) {\n        const container = document.getElementById('signalsList');\n        if (!container) return;\n\n        // Sort signals by priority and date\n        const sortedSignals = [...signals].sort((a, b) => {\n            // 1. Priority - high, medium, low\n            const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };\n            const priorityA = priorityOrder[a.priority] || 0;\n            const priorityB = priorityOrder[b.priority] || 0;\n\n            if (priorityA !== priorityB) {\n                return priorityB - priorityA;\n            }\n\n            // 2. Signal Polarity - Risk, Opportunities, Enrichment\n            const polarityOrder = { 'risk': 3, 'opportunities': 2, 'enrichment': 1 };\n            const polarityA = a.signal_polarity || a['Signal Polarity'] || 'Enrichment';\n            const polarityB = b.signal_polarity || b['Signal Polarity'] || 'Enrichment';\n            const normalizedPolarityA = FormatUtils.normalizePolarityKey(polarityA);\n            const normalizedPolarityB = FormatUtils.normalizePolarityKey(polarityB);\n            const polarityScoreA = polarityOrder[normalizedPolarityA] || 0;\n            const polarityScoreB = polarityOrder[normalizedPolarityB] || 0;\n\n            if (polarityScoreA !== polarityScoreB) {\n                return polarityScoreB - polarityScoreA;\n            }\n\n            // 3. call_date DESC\n            const dateA = new Date(a.call_date);\n            const dateB = new Date(b.call_date);\n            return dateB - dateA;\n        });\n\n        // Check FIRST if we should use virtual scrolling to avoid pre-rendering\n        const shouldUseVirtualScroll = sortedSignals.length > 100;\n        \n        if (shouldUseVirtualScroll) {\n            // Use virtual scrolling for large datasets\n            this.renderWithVirtualScroll(sortedSignals, viewState, comments, interactions, actionPlans);\n        } else {\n            // Only build HTML for small datasets\n            const newSignals = sortedSignals.filter(signal => !this.hasUserInteraction(signal, viewState, interactions, actionPlans));\n            const viewedSignals = sortedSignals.filter(signal => this.hasUserInteraction(signal, viewState, interactions, actionPlans));\n\n            let html = '';\n\n            // Add new signals section header\n            html += this.renderNewSignalsHeader(newSignals.length);\n\n            newSignals.forEach(signal => {\n                html += this.renderSignalCard(signal, comments, true);\n            });\n\n            if (newSignals.length > 0 && viewedSignals.length > 0) {\n                html += this.renderSeparator();\n            }\n\n            viewedSignals.forEach(signal => {\n                html += this.renderSignalCard(signal, comments, false);\n            });\n\n            container.innerHTML = html;\n            this.attachEventListeners(container);\n        }\n        \n        // Cache the signals for fast tab switching\n        this.cachedSignals = sortedSignals;\n        this.lastRenderTime = Date.now();\n    }\n    \n    /**\n     * Render signals using virtual scrolling for performance\n     */\n    static renderWithVirtualScroll(signals, viewState, comments, interactions, actionPlans) {\n        const container = document.getElementById('signalsList');\n        if (!container) return;\n        \n        // Initialize virtual scroll manager if not exists\n        if (!this.virtualScrollManager) {\n            this.virtualScrollManager = new VirtualScrollManager({\n                itemHeight: 250, // Estimated height for signal cards\n                bufferSize: 3,\n                pageSize: 30,\n                renderCallback: (signal, index) => {\n                    const isNew = !this.hasUserInteraction(signal, viewState, interactions, actionPlans);\n                    return this.renderSignalCard(signal, comments, isNew);\n                },\n                loadMoreCallback: async () => {\n                    // Load next page of signals\n                    const result = await SignalsRepository.loadNextPage();\n                    if (result.hasMore) {\n                        // Get updated signals from store\n                        const updatedSignals = SignalsStore.getAllSignals();\n                        this.virtualScrollManager.setItems(updatedSignals, true);\n                    }\n                    return result.hasMore;\n                }\n            });\n        }\n        \n        // Initialize with signals\n        this.virtualScrollManager.initialize('signalsList', signals);\n        \n        console.log(`🚀 Virtual scrolling enabled for ${signals.length} signals`);\n    }\n\n    static renderSignalCard(signal, comments, isNew) {\n        // Safety check for signal data\n        if (!signal || !signal.id) {\n            console.error('Invalid signal data:', signal);\n            return '';\n        }\n\n        const feedbackClass = signal.currentUserFeedback ? `signal-${signal.currentUserFeedback}` : '';\n        const feedbackStyle = this.getFeedbackStyle(signal);\n        const likeButtonHtml = this.getLikeButtonHtml(signal);\n        const notAccurateButtonHtml = this.getNotAccurateButtonHtml(signal);\n        const priority = signal.priority || 'Low';\n        const cardClass = isNew ? 'signal-new' : 'signal-viewed';\n        const priorityClass = priority.toLowerCase();\n\n        // Ensure required fields have fallback values and sanitize user content\n        const accountName = SecurityUtils.sanitizeHTML(signal.account_name || 'Unknown Account');\n        const signalName = SecurityUtils.sanitizeHTML(signal.name || 'Unnamed Signal');\n        const summary = SecurityUtils.sanitizeHTML(signal.summary || 'No summary available');\n        const rationale = SecurityUtils.sanitizeHTML(signal.rationale || 'No rationale provided');\n        const category = SecurityUtils.sanitizeHTML(signal.category || 'General');\n        \n        // Get Signal Polarity for pill display\n        const signalPolarity = signal.signal_polarity || signal['Signal Polarity'] || 'Enrichment';\n        const polarityClass = FormatUtils.normalizePolarityKey(signalPolarity);\n\n        return `\n            <div class=\"signal-card ${cardClass} ${priorityClass}-priority ${feedbackClass}\" data-signal-id=\"${signal.id}\" style=\"${feedbackStyle}\">\n                <div class=\"signal-header\">\n                    <div class=\"signal-info\">\n                        <div class=\"signal-title\">${accountName}</div>\n                        <div class=\"signal-meta\">\n                            <span><i class=\"${signal.source_icon || 'fas fa-info-circle'}\"></i> ${signalName}</span>\n                            <span class=\"category-badge\">${category}</span>\n                            <span class=\"priority-badge priority-${priorityClass}\">${priority}</span>\n                            <span class=\"polarity-badge polarity-${polarityClass}\">${FormatUtils.normalizePolarityLabel(signalPolarity)}</span>\n                            <span>${FormatUtils.formatDate(signal.created_at || signal.created_date)}</span>\n                            ${isNew ? '<span class=\"new-badge\">NEW</span>' : ''}\n                        </div>\n                    </div>\n                    <button class=\"signal-close-btn\" data-action=\"remove-signal\" data-signal-id=\"${signal.id}\">\n                        <i class=\"fas fa-times\"></i>\n                    </button>\n                </div>\n                <div class=\"signal-summary\">\n                    <div class=\"summary-text\">${summary}</div>\n                    <div class=\"rationale-text\">\n                        <strong>Here's what we noticed:</strong> ${rationale}\n                    </div>\n                </div>\n                <div class=\"signal-footer\">\n                    <span class=\"confidence\">Confidence: ${Math.round(signal.confidence * 100)}%</span>\n                    <div class=\"signal-actions\">\n                        ${likeButtonHtml}\n                        ${notAccurateButtonHtml}\n                    </div>\n                </div>\n                ${this.renderInlineCommentsSection(signal.id, comments)}\n            </div>\n        `;\n    }\n\n    static renderSeparator() {\n        return `\n            <div class=\"signal-separator\">\n                <div class=\"separator-line\"></div>\n                <div class=\"separator-text\">\n                    <i class=\"fas fa-eye\"></i>\n                    Previously Viewed Signals\n                </div>\n                <div class=\"separator-line\"></div>\n            </div>\n        `;\n    }\n\n    static renderNewSignalsHeader(count) {\n        if (count === 0) return '';\n        \n        return `\n            <div class=\"signals-section-header new-signals\">\n                <div class=\"section-header-content\">\n                    <i class=\"fas fa-bell\"></i>\n                    <h3>New Signals (${count})</h3>\n                    <span class=\"section-subtitle\">Scroll through signals to mark them as viewed</span>\n                </div>\n            </div>\n        `;\n    }\n\n    static renderInlineCommentsSection(signalId, comments) {\n        const signalComments = comments.get(signalId) || [];\n        \n        // Only show comments section if there are comments or to allow adding new ones\n        return `\n            <div class=\"linkedin-comments-section\">\n                <div class=\"comments-header\">\n                    <span class=\"comments-count\">${signalComments.length} comment${signalComments.length !== 1 ? 's' : ''}</span>\n                </div>\n                ${signalComments.length > 0 ? `\n                <div class=\"comments-list-linkedin\">\n                    ${signalComments.map(comment => `\n                        <div class=\"comment-linkedin\">\n                            <div class=\"comment-avatar\">\n                                <span class=\"avatar-initials\">${FormatUtils.getInitials(comment.author)}</span>\n                            </div>\n                            <div class=\"comment-content\">\n                                <div class=\"comment-header\">\n                                    <span class=\"comment-author\">${SecurityUtils.sanitizeHTML(comment.author)}</span>\n                                    <span class=\"comment-time\">${FormatUtils.formatCommentTime(comment.timestamp)}</span>\n                                </div>\n                                <div class=\"comment-text\" id=\"comment-text-${comment.id}\">${SecurityUtils.sanitizeHTML(comment.text)}</div>\n                                <div class=\"comment-actions\">\n                                    <button class=\"comment-action-btn\" data-action=\"edit-comment\" data-comment-id=\"${comment.id}\" data-signal-id=\"${signalId}\">\n                                        <i class=\"fas fa-edit\"></i> Edit\n                                    </button>\n                                    <button class=\"comment-action-btn delete-btn\" data-action=\"delete-comment\" data-comment-id=\"${comment.id}\" data-signal-id=\"${signalId}\">\n                                        <i class=\"fas fa-trash\"></i> Delete\n                                    </button>\n                                </div>\n                            </div>\n                        </div>\n                    `).join('')}\n                </div>\n                ` : ''}\n                <div class=\"add-comment-linkedin\">\n                    <div class=\"comment-input-avatar\">\n                        <span class=\"avatar-initials\">JS</span>\n                    </div>\n                    <div class=\"comment-input-container\">\n                        <input type=\"text\" id=\"inlineCommentText-${signalId}\" placeholder=\"Write a comment...\" class=\"comment-input-linkedin\">\n                        <button class=\"comment-submit-btn\" data-action=\"add-comment\" data-signal-id=\"${signalId}\">Comment</button>\n                    </div>\n                </div>\n            </div>\n        `;\n    }\n\n    static getFeedbackStyle(signal) {\n        if (signal.currentUserFeedback === 'like') {\n            return 'background-color: #d4f6d4; border-left: 4px solid #28a745; border: 1px solid #c3e6cb;';\n        } else if (signal.currentUserFeedback === 'not-accurate') {\n            return 'background-color: #f8d7da; border-left: 4px solid #dc3545; border: 1px solid #f5c6cb;';\n        }\n        return '';\n    }\n\n    static getLikeButtonHtml(signal) {\n        const likeCount = signal.likeCount || 0;\n        const isLiked = signal.currentUserFeedback === 'like';\n        \n        if (isLiked) {\n            return `<button class=\"btn btn-secondary liked-btn\" data-action=\"like\" data-signal-id=\"${signal.id}\">\n                <i class=\"fas fa-check\"></i> Liked! ${likeCount > 0 ? `(${likeCount})` : ''}\n            </button>`;\n        } else {\n            return `<button class=\"btn btn-secondary\" data-action=\"like\" data-signal-id=\"${signal.id}\">\n                <i class=\"fas fa-thumbs-up\"></i> Like ${likeCount > 0 ? `(${likeCount})` : ''}\n            </button>`;\n        }\n    }\n\n    static getNotAccurateButtonHtml(signal) {\n        const notAccurateCount = signal.notAccurateCount || 0;\n        const isNotAccurate = signal.currentUserFeedback === 'not-accurate';\n        \n        if (isNotAccurate) {\n            return `<button class=\"btn btn-secondary not-accurate-btn\" data-action=\"not-accurate\" data-signal-id=\"${signal.id}\">\n                <i class=\"fas fa-thumbs-down\"></i> Not Accurate ${notAccurateCount > 0 ? `(${notAccurateCount})` : ''}\n            </button>`;\n        } else {\n            return `<button class=\"btn btn-secondary\" data-action=\"not-accurate\" data-signal-id=\"${signal.id}\">\n                <i class=\"fas fa-thumbs-down\"></i> Not Accurate ${notAccurateCount > 0 ? `(${notAccurateCount})` : ''}\n            </button>`;\n        }\n    }\n\n    static getActionButtonHtml(signal, app) {\n        // Check if there are any action plans for this account\n        let hasActionPlan = false;\n        \n        // Check both Map-based and Array-based action plans\n        if (app.actionPlans instanceof Map) {\n            // Check if any plan exists for this account (now that keys are plan IDs)\n            hasActionPlan = Array.from(app.actionPlans.values()).some(plan => plan.accountId === signal.account_id);\n        } else if (Array.isArray(app.actionPlans)) {\n            hasActionPlan = app.actionPlans.some(plan => plan.accountId === signal.account_id);\n        }\n\n        // Also check if DataService has plans by account\n        if (!hasActionPlan && window.DataService && window.DataService.actionPlansByAccount) {\n            hasActionPlan = window.DataService.actionPlansByAccount.has(signal.account_id);\n        }\n\n        if (hasActionPlan) {\n            return `\n                <button class=\"btn btn-primary btn-sm action-btn\" onclick=\"app.selectActionPlanToEdit('${signal.account_id}')\">\n                    <i class=\"fas fa-edit\"></i> Edit Plan\n                </button>\n            `;\n        } else {\n            return `\n                <button class=\"btn btn-secondary btn-sm action-btn\" onclick=\"app.createActionPlanForAccount('${signal.account_id}')\">\n                    <i class=\"fas fa-plus\"></i> Create Plan\n                </button>\n            `;\n        }\n    }\n\n    static hasUserInteraction(signal, viewState, interactions, actionPlans) {\n        // Check if user has any interaction with this signal:\n        // 1. Viewed the signal\n        if (viewState.viewedSignals && viewState.viewedSignals.has(signal.id)) {\n            return true;\n        }\n        \n        // 2. Liked or marked as not accurate\n        if (signal.currentUserFeedback) {\n            return true;\n        }\n        \n        // 3. Created an action plan for this account\n        if (actionPlans instanceof Map) {\n            // Check if any plan exists for this account\n            const hasActionPlan = Array.from(actionPlans.values()).some(plan => plan.accountId === signal.account_id);\n            if (hasActionPlan) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n    static attachEventListeners(container) {\n        // Remove any existing listeners to prevent duplication\n        if (container._signalListenersAttached) {\n            return; // Already attached, no need to re-attach\n        }\n        container._signalListenersAttached = true;\n        \n        // Set up intersection observer for auto-viewing signals on scroll\n        this.setupScrollBasedViewing(container);\n\n        // Use event delegation for all clicks on the container\n        container.addEventListener('click', (e) => {\n            // Handle signal card clicks (but not on interactive elements)\n            const signalCard = e.target.closest('.signal-card');\n            if (signalCard && \n                !e.target.closest('.linkedin-comments-section') &&\n                !e.target.closest('.add-comment-form') &&\n                !e.target.closest('.signal-actions') &&\n                !e.target.classList.contains('add-comment-btn') &&\n                !e.target.classList.contains('comment-input-linkedin') &&\n                !e.target.classList.contains('comment-submit-btn') &&\n                !e.target.closest('[data-action]')) {\n                const signalId = signalCard.getAttribute('data-signal-id');\n                dispatcher.dispatch(Actions.markSignalAsViewed(signalId));\n                dispatcher.dispatch(Actions.openSignalDetails(signalId));\n                return;\n            }\n            \n            // Handle action buttons using data attributes\n            const target = e.target.closest('[data-action]');\n            if (!target) return;\n            \n            e.stopPropagation();\n            e.preventDefault();\n            \n            const action = target.getAttribute('data-action');\n            const signalId = target.getAttribute('data-signal-id');\n            const commentId = target.getAttribute('data-comment-id');\n            \n            switch (action) {\n                case 'like':\n                    const userId = signalsStore.getState().userInfo?.userId || 'user-1';\n                    dispatcher.dispatch(Actions.requestFeedback(signalId, 'like', userId));\n                    break;\n                case 'not-accurate':\n                    const userId2 = signalsStore.getState().userInfo?.userId || 'user-1';\n                    dispatcher.dispatch(Actions.requestFeedback(signalId, 'not-accurate', userId2));\n                    break;\n                case 'remove-signal':\n                    dispatcher.dispatch(Actions.removeSignalFromFeed(signalId));\n                    break;\n                case 'add-comment':\n                    const inputElement = document.getElementById(`inlineCommentText-${signalId}`);\n                    if (inputElement && inputElement.value.trim()) {\n                        const state = signalsStore.getState();\n                        const signal = state.signalsById.get(signalId);\n                        const accountId = signal?.account_id || signal?.account_name || 'unknown';\n                        const userId3 = state.userInfo?.userId || 'user-1';\n                        dispatcher.dispatch(Actions.requestComment(signalId, accountId, inputElement.value.trim(), userId3));\n                        inputElement.value = '';\n                    }\n                    break;\n                case 'edit-comment':\n                    const commentElement = document.getElementById(`comment-text-${commentId}`);\n                    if (commentElement) {\n                        const currentText = commentElement.textContent;\n                        const newText = prompt('Edit comment:', currentText);\n                        if (newText !== null && newText.trim() !== currentText) {\n                            dispatcher.dispatch(Actions.updateComment(commentId, newText.trim()));\n                        }\n                    }\n                    break;\n                case 'delete-comment':\n                    dispatcher.dispatch(Actions.deleteComment(commentId, signalId));\n                    break;\n            }\n        });\n\n        // Comment input handling using event delegation\n        container.addEventListener('click', (e) => {\n            if (e.target.classList.contains('comment-input-linkedin')) {\n                e.stopPropagation();\n            }\n        });\n        \n        container.addEventListener('focus', (e) => {\n            if (e.target.classList.contains('comment-input-linkedin')) {\n                e.stopPropagation();\n            }\n        }, true);\n        \n        container.addEventListener('keydown', (e) => {\n            if (e.target.classList.contains('comment-input-linkedin')) {\n                e.stopPropagation();\n                if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault();\n                    const signalId = e.target.closest('.signal-card').getAttribute('data-signal-id');\n                    if (e.target.value.trim()) {\n                        dispatcher.dispatch(Actions.addComment(signalId, e.target.value.trim()));\n                        e.target.value = '';\n                    }\n                }\n            }\n        });\n    }\n\n    static setupScrollBasedViewing(container) {\n        // Create intersection observer to detect when signals come into view\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting) {\n                    const signalCard = entry.target;\n                    const signalId = signalCard.getAttribute('data-signal-id');\n                    \n                    // Only mark new signals as viewed (not already viewed ones)\n                    if (signalCard.classList.contains('signal-new')) {\n                        // Add a small delay to ensure the user actually scrolled through it\n                        setTimeout(() => {\n                            if (entry.isIntersecting) { // Check if still in view after delay\n                                // Mark as viewed through Flux action\n                                dispatcher.dispatch(Actions.markSignalAsViewed(signalId));\n                            }\n                        }, 1500); // 1.5 second delay\n                    }\n                }\n            });\n        }, {\n            // Trigger when 50% of the signal card is visible\n            threshold: 0.5,\n            // Add some margin to trigger slightly before/after the element is fully visible\n            rootMargin: '0px 0px -20% 0px'\n        });\n\n        // Observe all signal cards\n        container.querySelectorAll('.signal-card.signal-new').forEach(card => {\n            observer.observe(card);\n        });\n\n        // Store the observer globally so we can disconnect it later\n        if (window.signalScrollObserver) {\n            window.signalScrollObserver.disconnect();\n        }\n        window.signalScrollObserver = observer;\n    }\n}","size_bytes":23150},"js/services/NotificationService.js":{"content":"// NotificationService - Handle UI notifications\nclass NotificationService {\n    \n    /**\n     * Show success notification\n     * @param {string} message - Success message to display\n     */\n    static showSuccess(message) {\n        this.showNotification(message, 'success');\n    }\n    \n    /**\n     * Show error notification\n     * @param {string} message - Error message to display\n     */\n    static showError(message) {\n        this.showNotification(message, 'error');\n    }\n    \n    /**\n     * Show info notification\n     * @param {string} message - Info message to display\n     */\n    static showInfo(message) {\n        this.showNotification(message, 'info');\n    }\n    \n    /**\n     * Show warning notification\n     * @param {string} message - Warning message to display\n     */\n    static showWarning(message) {\n        this.showNotification(message, 'warning');\n    }\n    \n    /**\n     * Show notification with specified type\n     * @param {string} message - Message to display\n     * @param {string} type - Type of notification (success, error, info, warning)\n     */\n    static showNotification(message, type = 'info') {\n        // Remove any existing notifications\n        const existingNotification = document.querySelector('.notification-toast');\n        if (existingNotification) {\n            existingNotification.remove();\n        }\n        \n        // Create notification element\n        const notification = document.createElement('div');\n        notification.className = `notification-toast notification-${type}`;\n        notification.innerHTML = `\n            <div class=\"notification-content\">\n                <i class=\"fas ${this.getIconForType(type)}\"></i>\n                <span class=\"notification-message\">${message}</span>\n            </div>\n        `;\n        \n        // Add to page\n        document.body.appendChild(notification);\n        \n        // Trigger animation\n        setTimeout(() => {\n            notification.classList.add('show');\n        }, 10);\n        \n        // Auto-hide after 3 seconds\n        setTimeout(() => {\n            notification.classList.remove('show');\n            setTimeout(() => {\n                notification.remove();\n            }, 300);\n        }, 3000);\n    }\n    \n    /**\n     * Get icon class for notification type\n     * @param {string} type - Notification type\n     * @returns {string} - Icon class\n     */\n    static getIconForType(type) {\n        const icons = {\n            'success': 'fa-check-circle',\n            'error': 'fa-exclamation-circle',\n            'info': 'fa-info-circle',\n            'warning': 'fa-exclamation-triangle'\n        };\n        return icons[type] || 'fa-info-circle';\n    }\n}\n\n// Make globally available\nwindow.NotificationService = NotificationService;","size_bytes":2757},"js/utils/StatusUtils.js":{"content":"/**\n * Centralized status normalization utilities for SignalsAI\n * Handles all status variants (spaces, hyphens, underscores, capitalization)\n */\n\nclass StatusUtils {\n    // ⚡ Canonical status normalization - handles ALL variants\n    static normalizeStatusToCanonical(status) {\n        if (!status) return 'pending';\n        \n        const normalized = status.toString().toLowerCase().trim();\n        \n        // Map all possible status variants to canonical forms\n        const statusMap = {\n            'pending': 'pending',\n            'in progress': 'in_progress', \n            'in_progress': 'in_progress',\n            'in-progress': 'in_progress',\n            'active': 'in_progress',\n            'complete': 'complete',\n            'completed': 'complete',\n            'done': 'complete',\n            'cancelled': 'cancelled',\n            'canceled': 'cancelled',\n            'on hold': 'on_hold',\n            'on_hold': 'on_hold',\n            'on-hold': 'on_hold',\n            'paused': 'on_hold'\n        };\n        \n        return statusMap[normalized] || 'pending';\n    }\n\n    // Convert canonical status to human-readable display label\n    static getStatusDisplayLabel(canonicalStatus) {\n        const displayMap = {\n            'pending': 'Pending',\n            'in_progress': 'In Progress',\n            'complete': 'Complete', \n            'cancelled': 'Cancelled',\n            'on_hold': 'On Hold'\n        };\n        \n        return displayMap[canonicalStatus] || 'Pending';\n    }\n\n    // Convert canonical status to CSS class (for badges)\n    static getStatusCSSClass(canonicalStatus) {\n        // Convert underscores to hyphens for CSS classes\n        return `status-${canonicalStatus.replace('_', '-')}`;\n    }\n\n    // Get all canonical status values (for validation/filtering)\n    static getCanonicalStatuses() {\n        return ['pending', 'in_progress', 'complete', 'cancelled', 'on_hold'];\n    }\n\n    // Validate if a status is canonical\n    static isCanonicalStatus(status) {\n        return this.getCanonicalStatuses().includes(status);\n    }\n}\n\n// Export for use across the application\nwindow.StatusUtils = StatusUtils;","size_bytes":2143},"js/flux/Actions.js":{"content":"// Actions - Centralized action types and creators for Flux architecture\nclass Actions {\n    \n    // Action Types - All possible actions in the application\n    static Types = {\n        // App Lifecycle\n        APP_INITIALIZED: 'APP_INITIALIZED',\n        TAB_CHANGED: 'TAB_CHANGED',\n        \n        // Data Loading\n        DATA_LOAD_REQUESTED: 'DATA_LOAD_REQUESTED',\n        DATA_LOAD_STARTED: 'DATA_LOAD_STARTED',\n        DATA_LOAD_SUCCESS: 'DATA_LOAD_SUCCESS',\n        DATA_LOAD_FAILED: 'DATA_LOAD_FAILED',\n        DATA_PAGE_LOADED: 'DATA_PAGE_LOADED',\n        LOAD_NEXT_PAGE: 'LOAD_NEXT_PAGE',\n        \n        // Signal Management\n        SIGNALS_FILTERED: 'SIGNALS_FILTERED',\n        SIGNAL_VIEWED: 'SIGNAL_VIEWED',\n        SIGNAL_SELECTED: 'SIGNAL_SELECTED',\n        SIGNAL_REMOVED: 'SIGNAL_REMOVED',\n        SIGNAL_DETAILS_OPENED: 'SIGNAL_DETAILS_OPENED',\n        \n        // Feedback Actions (with optimistic flow)\n        FEEDBACK_REQUESTED: 'FEEDBACK_REQUESTED',\n        FEEDBACK_SUCCEEDED: 'FEEDBACK_SUCCEEDED',\n        FEEDBACK_FAILED: 'FEEDBACK_FAILED',\n        FEEDBACK_REMOVED: 'FEEDBACK_REMOVED',\n        \n        // Comments\n        COMMENT_REQUESTED: 'COMMENT_REQUESTED',\n        COMMENT_SUCCEEDED: 'COMMENT_SUCCEEDED',\n        COMMENT_FAILED: 'COMMENT_FAILED',\n        COMMENT_UPDATED: 'COMMENT_UPDATED',\n        COMMENT_DELETED: 'COMMENT_DELETED',\n        \n        // Action Plans\n        ACTION_PLAN_REQUESTED: 'ACTION_PLAN_REQUESTED',\n        ACTION_PLAN_SUCCEEDED: 'ACTION_PLAN_SUCCEEDED',\n        ACTION_PLAN_FAILED: 'ACTION_PLAN_FAILED',\n        ACTION_PLAN_UPDATED: 'ACTION_PLAN_UPDATED',\n        ACTION_PLAN_DELETED: 'ACTION_PLAN_DELETED',\n        \n        // UI State\n        LOADING_SHOWN: 'LOADING_SHOWN',\n        LOADING_HIDDEN: 'LOADING_HIDDEN',\n        MESSAGE_SHOWN: 'MESSAGE_SHOWN',\n        MESSAGE_HIDDEN: 'MESSAGE_HIDDEN',\n        \n        // Modal/Drawer State\n        MODAL_OPENED: 'MODAL_OPENED',\n        MODAL_CLOSED: 'MODAL_CLOSED',\n        DRAWER_OPENED: 'DRAWER_OPENED',\n        DRAWER_CLOSED: 'DRAWER_CLOSED',\n        PLAN_DRAWER_CLOSED: 'PLAN_DRAWER_CLOSED',\n        SIGNAL_DRAWER_CLOSED: 'SIGNAL_DRAWER_CLOSED',\n        \n        // Portfolio Filters\n        PORTFOLIO_FILTERED: 'PORTFOLIO_FILTERED',\n        \n        // Account Management\n        ACCOUNT_EXPANDED: 'ACCOUNT_EXPANDED',\n        ACCOUNT_COLLAPSED: 'ACCOUNT_COLLAPSED',\n        SHOW_MORE_SIGNALS: 'SHOW_MORE_SIGNALS',\n        SHOW_LESS_SIGNALS: 'SHOW_LESS_SIGNALS'\n    };\n    \n    // Action Creators - Functions that create action objects\n    \n    // App Lifecycle Actions\n    static initializeApp(data) {\n        return {\n            type: this.Types.APP_INITIALIZED,\n            payload: { data },\n            timestamp: Date.now()\n        };\n    }\n    \n    static changeTab(tabName) {\n        return {\n            type: this.Types.TAB_CHANGED,\n            payload: { tabName },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Alias for consistency\n    static switchTab(tabName) {\n        return this.changeTab(tabName);\n    }\n    \n    static tabSwitched(tabName) {\n        return this.changeTab(tabName);\n    }\n    \n    // Data Loading Actions\n    static dataLoadRequested() {\n        return {\n            type: this.Types.DATA_LOAD_REQUESTED,\n            timestamp: Date.now()\n        };\n    }\n    \n    static startDataLoad() {\n        return {\n            type: this.Types.DATA_LOAD_STARTED,\n            timestamp: Date.now()\n        };\n    }\n    \n    static dataLoadSuccess(data) {\n        return {\n            type: this.Types.DATA_LOAD_SUCCESS,\n            payload: { data },\n            timestamp: Date.now()\n        };\n    }\n    \n    static dataLoadFailed(error) {\n        return {\n            type: this.Types.DATA_LOAD_FAILED,\n            payload: { error },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Pagination Actions\n    static dataPageLoaded(data) {\n        return {\n            type: this.Types.DATA_PAGE_LOADED,\n            payload: { data },\n            timestamp: Date.now()\n        };\n    }\n    \n    static loadNextPage() {\n        return {\n            type: this.Types.LOAD_NEXT_PAGE,\n            timestamp: Date.now()\n        };\n    }\n    \n    // Signal Actions\n    static filterSignals(filters) {\n        return {\n            type: this.Types.SIGNALS_FILTERED,\n            payload: { filters },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Alias for consistency\n    static applyFilters(filters) {\n        return this.filterSignals(filters);\n    }\n    \n    static viewSignal(signalId) {\n        return {\n            type: this.Types.SIGNAL_VIEWED,\n            payload: { signalId },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Alias for consistency\n    static markSignalAsViewed(signalId) {\n        return this.viewSignal(signalId);\n    }\n    \n    static removeSignalFromFeed(signalId) {\n        return {\n            type: this.Types.SIGNAL_REMOVED,\n            payload: { signalId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static openSignalDetails(signalId) {\n        return {\n            type: this.Types.SIGNAL_DETAILS_OPENED,\n            payload: { signalId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static selectSignal(signal) {\n        return {\n            type: this.Types.SIGNAL_SELECTED,\n            payload: { signal },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Feedback Actions (Optimistic Pattern)\n    static requestFeedback(signalId, feedbackType, userId) {\n        return {\n            type: this.Types.FEEDBACK_REQUESTED,\n            payload: { \n                signalId, \n                feedbackType, \n                userId,\n                operationId: `feedback_${signalId}_${Date.now()}`\n            },\n            timestamp: Date.now()\n        };\n    }\n    \n    static feedbackSucceeded(signalId, feedbackType, operationId) {\n        return {\n            type: this.Types.FEEDBACK_SUCCEEDED,\n            payload: { signalId, feedbackType, operationId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static feedbackFailed(signalId, feedbackType, operationId, error) {\n        return {\n            type: this.Types.FEEDBACK_FAILED,\n            payload: { signalId, feedbackType, operationId, error },\n            timestamp: Date.now()\n        };\n    }\n    \n    static removeFeedback(signalId, userId) {\n        return {\n            type: this.Types.FEEDBACK_REMOVED,\n            payload: { signalId, userId },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Comment Actions\n    static requestComment(signalId, accountId, text, userId) {\n        return {\n            type: this.Types.COMMENT_REQUESTED,\n            payload: { \n                signalId, \n                accountId, \n                text, \n                userId,\n                operationId: `comment_${signalId || accountId}_${Date.now()}`\n            },\n            timestamp: Date.now()\n        };\n    }\n    \n    static commentSucceeded(comment, operationId) {\n        return {\n            type: this.Types.COMMENT_SUCCEEDED,\n            payload: { comment, operationId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static commentFailed(operationId, error) {\n        return {\n            type: this.Types.COMMENT_FAILED,\n            payload: { operationId, error },\n            timestamp: Date.now()\n        };\n    }\n    \n    static updateComment(commentId, text) {\n        return {\n            type: this.Types.COMMENT_UPDATED,\n            payload: { commentId, text },\n            timestamp: Date.now()\n        };\n    }\n    \n    static deleteComment(commentId) {\n        return {\n            type: this.Types.COMMENT_DELETED,\n            payload: { commentId },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Additional Action Plan Actions (using standard naming)\n    static updateActionPlan(planId, updates) {\n        return {\n            type: this.Types.ACTION_PLAN_UPDATED,\n            payload: { planId, updates },\n            timestamp: Date.now()\n        };\n    }\n    \n    static deleteActionPlan(planId) {\n        return {\n            type: this.Types.ACTION_PLAN_DELETED,\n            payload: { planId },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Action Plan Actions\n    static requestActionPlan(signalId, title, description, tasks, userId) {\n        return {\n            type: this.Types.ACTION_PLAN_REQUESTED,\n            payload: { \n                signalId, \n                title, \n                description, \n                tasks, \n                userId,\n                operationId: `plan_${signalId}_${Date.now()}`\n            },\n            timestamp: Date.now()\n        };\n    }\n    \n    static actionPlanSucceeded(plan, operationId) {\n        return {\n            type: this.Types.ACTION_PLAN_SUCCEEDED,\n            payload: { plan, operationId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static actionPlanFailed(operationId, error) {\n        return {\n            type: this.Types.ACTION_PLAN_FAILED,\n            payload: { operationId, error },\n            timestamp: Date.now()\n        };\n    }\n    \n    // UI State Actions\n    static showLoading() {\n        return {\n            type: this.Types.LOADING_SHOWN,\n            timestamp: Date.now()\n        };\n    }\n    \n    static hideLoading() {\n        return {\n            type: this.Types.LOADING_HIDDEN,\n            timestamp: Date.now()\n        };\n    }\n    \n    static showMessage(message, type = 'info') {\n        return {\n            type: this.Types.MESSAGE_SHOWN,\n            payload: { message, type },\n            timestamp: Date.now()\n        };\n    }\n    \n    static hideMessage() {\n        return {\n            type: this.Types.MESSAGE_HIDDEN,\n            timestamp: Date.now()\n        };\n    }\n    \n    // Modal/Drawer Actions\n    static openModal(modalType, data = null) {\n        return {\n            type: this.Types.MODAL_OPENED,\n            payload: { modalType, data },\n            timestamp: Date.now()\n        };\n    }\n    \n    static closeModal() {\n        return {\n            type: this.Types.MODAL_CLOSED,\n            timestamp: Date.now()\n        };\n    }\n    \n    static openDrawer(drawerType, data = null) {\n        return {\n            type: this.Types.DRAWER_OPENED,\n            payload: { drawerType, data },\n            timestamp: Date.now()\n        };\n    }\n    \n    static closeDrawer() {\n        return {\n            type: this.Types.DRAWER_CLOSED,\n            timestamp: Date.now()\n        };\n    }\n    \n    // Specific drawer actions\n    static closePlanDrawer() {\n        return {\n            type: this.Types.PLAN_DRAWER_CLOSED,\n            timestamp: Date.now()\n        };\n    }\n    \n    static closeSignalDrawer() {\n        return {\n            type: this.Types.SIGNAL_DRAWER_CLOSED,\n            timestamp: Date.now()\n        };\n    }\n    \n    // Action Plan Actions\n    static createActionPlan(data = null) {\n        return {\n            type: this.Types.ACTION_PLAN_REQUESTED,\n            payload: { data },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Portfolio Filter Actions\n    static applyPortfolioFilter(filterType) {\n        return {\n            type: this.Types.PORTFOLIO_FILTERED,\n            payload: { filterType },\n            timestamp: Date.now()\n        };\n    }\n    \n    // Account Management Actions\n    static expandAccount(accountId) {\n        return {\n            type: this.Types.ACCOUNT_EXPANDED,\n            payload: { accountId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static collapseAccount(accountId) {\n        return {\n            type: this.Types.ACCOUNT_COLLAPSED,\n            payload: { accountId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static showMoreSignalsForAccount(accountId) {\n        return {\n            type: this.Types.SHOW_MORE_SIGNALS,\n            payload: { accountId },\n            timestamp: Date.now()\n        };\n    }\n    \n    static showLessSignalsForAccount(accountId) {\n        return {\n            type: this.Types.SHOW_LESS_SIGNALS,\n            payload: { accountId },\n            timestamp: Date.now()\n        };\n    }\n}\n\n// Make Actions globally available\nwindow.Actions = Actions;","size_bytes":12281},"js/flux/Dispatcher.js":{"content":"// Dispatcher - Central hub for routing actions to stores\nclass Dispatcher {\n    \n    constructor() {\n        this.stores = new Map();\n        this.isDispatching = false;\n        this.dispatchQueue = [];\n        this.actionHistory = [];\n        this.maxHistorySize = 100; // For debugging\n    }\n    \n    /**\n     * Register a store to receive actions\n     * @param {string} storeId - Unique identifier for the store\n     * @param {Function} storeHandler - Function that handles actions (store.dispatch method)\n     */\n    register(storeId, storeHandler) {\n        if (this.stores.has(storeId)) {\n            console.warn(`Store ${storeId} is already registered`);\n            return;\n        }\n        \n        this.stores.set(storeId, storeHandler);\n        console.log(`✅ Registered store: ${storeId}`);\n    }\n    \n    /**\n     * Unregister a store\n     * @param {string} storeId - Store identifier to unregister\n     */\n    unregister(storeId) {\n        if (this.stores.has(storeId)) {\n            this.stores.delete(storeId);\n            console.log(`❌ Unregistered store: ${storeId}`);\n        }\n    }\n    \n    /**\n     * Dispatch an action to all registered stores\n     * @param {Object} action - The action object to dispatch\n     */\n    dispatch(action) {\n        // Validate action format\n        if (!this.isValidAction(action)) {\n            console.error('Invalid action format:', action);\n            return;\n        }\n        \n        // Prevent nested dispatching (common Flux rule)\n        if (this.isDispatching) {\n            this.dispatchQueue.push(action);\n            return;\n        }\n        \n        this.isDispatching = true;\n        \n        try {\n            // Add to history for debugging\n            this.addToHistory(action);\n            \n            // Log action for debugging\n            console.log(`🎯 Dispatching action: ${action.type}`, action.payload || '');\n            \n            // Send action to all registered stores\n            this.stores.forEach((storeHandler, storeId) => {\n                try {\n                    storeHandler(action);\n                } catch (error) {\n                    console.error(`Error in store ${storeId} handling action ${action.type}:`, error);\n                }\n            });\n            \n        } catch (error) {\n            console.error('Error during dispatch:', error);\n        } finally {\n            this.isDispatching = false;\n            \n            // Process any queued actions\n            if (this.dispatchQueue.length > 0) {\n                const nextAction = this.dispatchQueue.shift();\n                // Use setTimeout to break the call stack\n                setTimeout(() => this.dispatch(nextAction), 0);\n            }\n        }\n    }\n    \n    /**\n     * Validate that an action has the required structure\n     * @param {Object} action - Action to validate\n     * @returns {boolean} - Whether the action is valid\n     */\n    isValidAction(action) {\n        return action && \n               typeof action === 'object' && \n               typeof action.type === 'string' && \n               action.type.length > 0;\n    }\n    \n    /**\n     * Add action to history for debugging\n     * @param {Object} action - Action to add to history\n     */\n    addToHistory(action) {\n        this.actionHistory.push({\n            ...action,\n            dispatchedAt: new Date().toISOString()\n        });\n        \n        // Keep history size manageable\n        if (this.actionHistory.length > this.maxHistorySize) {\n            this.actionHistory.shift();\n        }\n    }\n    \n    /**\n     * Get action history for debugging\n     * @returns {Array} - Array of dispatched actions\n     */\n    getActionHistory() {\n        return [...this.actionHistory];\n    }\n    \n    /**\n     * Clear action history\n     */\n    clearActionHistory() {\n        this.actionHistory = [];\n    }\n    \n    /**\n     * Get list of registered stores\n     * @returns {Array} - Array of store IDs\n     */\n    getRegisteredStores() {\n        return Array.from(this.stores.keys());\n    }\n    \n    /**\n     * Check if currently dispatching\n     * @returns {boolean} - Whether dispatch is in progress\n     */\n    isCurrentlyDispatching() {\n        return this.isDispatching;\n    }\n}\n\n// Create singleton instance\nconst dispatcher = new Dispatcher();\n\n// Make available globally\nwindow.Dispatcher = Dispatcher;\nwindow.dispatcher = dispatcher;","size_bytes":4397},"js/flux/FluxTest.js":{"content":"// FluxTest - Simple test to verify Flux infrastructure is working\nclass FluxTest {\n    \n    static runBasicTests() {\n        console.log('🧪 Starting Flux infrastructure tests...');\n        \n        try {\n            // Test 1: Verify globals are available\n            console.log('Test 1: Checking global availability...');\n            if (typeof dispatcher === 'undefined') {\n                throw new Error('Dispatcher not available globally');\n            }\n            if (typeof Actions === 'undefined') {\n                throw new Error('Actions not available globally');\n            }\n            if (typeof signalsStore === 'undefined') {\n                throw new Error('SignalsStore not available globally');\n            }\n            console.log('✅ Test 1 passed: All globals available');\n            \n            // Test 2: Test action creation\n            console.log('Test 2: Testing action creators...');\n            const testAction = Actions.showMessage('Test message', 'info');\n            if (!testAction || !testAction.type || !testAction.payload) {\n                throw new Error('Action creator failed');\n            }\n            console.log('✅ Test 2 passed: Action creators working');\n            \n            // Test 3: Test store subscription\n            console.log('Test 3: Testing store subscriptions...');\n            let subscriptionCalled = false;\n            const unsubscribe = signalsStore.subscribe('test', () => {\n                subscriptionCalled = true;\n            });\n            signalsStore.emitChange('test');\n            if (!subscriptionCalled) {\n                throw new Error('Store subscription failed');\n            }\n            unsubscribe();\n            console.log('✅ Test 3 passed: Store subscriptions working');\n            \n            // Test 4: Test basic dispatch\n            console.log('Test 4: Testing action dispatch...');\n            dispatcher.dispatch(Actions.showMessage('Test dispatch', 'info'));\n            console.log('✅ Test 4 passed: Action dispatch working');\n            \n            // Test 5: Verify store state structure\n            console.log('Test 5: Testing store state structure...');\n            const state = signalsStore.getState();\n            if (!state || typeof state !== 'object') {\n                throw new Error('Store state is invalid');\n            }\n            if (!state.signals || !state.comments || !state.interactions) {\n                throw new Error('Store state missing required properties');\n            }\n            console.log('✅ Test 5 passed: Store state structure correct');\n            \n            console.log('🎉 All Flux infrastructure tests passed!');\n            return true;\n            \n        } catch (error) {\n            console.error('❌ Flux test failed:', error.message);\n            return false;\n        }\n    }\n    \n    static verifyServices() {\n        console.log('🧪 Verifying Flux services...');\n        \n        try {\n            // Check service availability\n            if (typeof FeedbackService === 'undefined') {\n                throw new Error('FeedbackService not available');\n            }\n            if (typeof CommentsService === 'undefined') {\n                throw new Error('CommentsService not available');\n            }\n            if (typeof ActionPlansService === 'undefined') {\n                throw new Error('ActionPlansService not available');\n            }\n            if (typeof SignalsRepository === 'undefined') {\n                throw new Error('SignalsRepository not available');\n            }\n            \n            console.log('✅ All Flux services available');\n            return true;\n            \n        } catch (error) {\n            console.error('❌ Service verification failed:', error.message);\n            return false;\n        }\n    }\n}\n\n// Make globally available for testing\nwindow.FluxTest = FluxTest;\n\n// Auto-run tests when loaded (only in development)\nif (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {\n    // Run tests after a short delay to ensure all scripts are loaded\n    setTimeout(() => {\n        FluxTest.runBasicTests();\n        FluxTest.verifyServices();\n    }, 1000);\n}","size_bytes":4231},"js/flux/SignalsStore.js":{"content":"// SignalsStore - Normalized Relational Model with Backward Compatibility\nclass SignalsStore extends Store {\n    \n    constructor() {\n        super('SignalsStore');\n        \n        // Initialize normalized entity stores\n        this.normalizedData = {\n            accounts: new Map(),\n            signals: new Map(),\n            recommendedActions: new Map(),\n            interactions: new Map(),\n            comments: new Map(),\n            actionPlans: new Map()\n        };\n        \n        // Initialize relationship indexes\n        this.indexes = {\n            signalsByAccount: new Map(),\n            signalsByAction: new Map(),\n            actionsByAccount: new Map(),\n            interactionsBySignal: new Map(),\n            commentsBySignal: new Map(),\n            commentsByAccount: new Map(),\n            plansByAccount: new Map(),\n            plansByAction: new Map()\n        };\n        \n        // Initialize state structure (for backward compatibility)\n        this.setInitialState({\n            // Core data (denormalized for backward compatibility)\n            signals: [],\n            accounts: new Map(),\n            comments: new Map(),\n            interactions: new Map(),\n            actionPlans: new Map(),\n            userInfo: {},\n            \n            // Pagination state\n            pagination: {\n                currentPage: 0,\n                pageSize: 200,\n                totalSignals: 0,\n                loadedSignals: 0,\n                hasMore: false,\n                isLoading: false\n            },\n            \n            // Cache for fast tab switching\n            viewCache: {\n                signalFeed: null,\n                portfolio: null,\n                whitespace: null,\n                lastUpdate: 0\n            },\n            \n            // Indexes for performance\n            signalsById: new Map(),\n            signalsByAccount: new Map(),\n            interactionsByUser: new Map(),\n            actionPlansByAccount: new Map(),\n            \n            // UI state\n            currentTab: 'signal-feed',\n            selectedSignal: null,\n            filteredSignals: [],\n            loading: false,\n            message: null,\n            \n            // View state with filters\n            viewState: {\n                filters: {\n                    signalType: 'all',\n                    category: 'all',\n                    searchText: '',\n                    priority: 'all',\n                    polarity: 'all',\n                    riskCategory: 'all'\n                },\n                pagination: {\n                    page: 1,\n                    pageSize: 20\n                }\n            },\n            \n            // Modal/Drawer state\n            modal: { isOpen: false, type: null, data: null },\n            drawer: { isOpen: false, type: null, data: null }\n        });\n    }\n    \n    /**\n     * Main dispatch handler - routes actions to reducers\n     */\n    dispatch(action) {\n        const { type, payload } = action;\n        \n        switch (type) {\n            // App Lifecycle\n            case Actions.Types.APP_INITIALIZED:\n                this.handleAppInitialized(payload);\n                break;\n            case Actions.Types.TAB_CHANGED:\n                this.handleTabChanged(payload);\n                break;\n                \n            // Data Loading\n            case Actions.Types.DATA_LOAD_REQUESTED:\n                this.handleDataLoadRequested();\n                break;\n            case Actions.Types.DATA_LOAD_STARTED:\n                this.handleDataLoadStarted();\n                break;\n            case Actions.Types.DATA_LOAD_SUCCESS:\n                this.handleDataLoadSuccess(payload);\n                break;\n            case Actions.Types.DATA_LOAD_FAILED:\n                this.handleDataLoadFailed(payload);\n                break;\n            case Actions.Types.DATA_PAGE_LOADED:\n                this.handleDataPageLoaded(payload);\n                break;\n            case Actions.Types.LOAD_NEXT_PAGE:\n                this.handleLoadNextPage();\n                break;\n                \n            // Signal Management\n            case Actions.Types.SIGNALS_FILTERED:\n                this.handleSignalsFiltered(payload);\n                break;\n            case Actions.Types.SIGNAL_VIEWED:\n                this.handleSignalViewed(payload);\n                break;\n            case Actions.Types.SIGNAL_SELECTED:\n                this.handleSignalSelected(payload);\n                break;\n            case Actions.Types.SIGNAL_REMOVED:\n                this.handleSignalRemoved(payload);\n                break;\n            case Actions.Types.SIGNAL_DETAILS_OPENED:\n                this.handleSignalDetailsOpened(payload);\n                break;\n                \n            // Feedback (Optimistic Updates)\n            case Actions.Types.FEEDBACK_REQUESTED:\n                this.handleFeedbackRequested(payload);\n                break;\n            case Actions.Types.FEEDBACK_SUCCEEDED:\n                this.handleFeedbackSucceeded(payload);\n                break;\n            case Actions.Types.FEEDBACK_FAILED:\n                this.handleFeedbackFailed(payload);\n                break;\n                \n            // Comments\n            case Actions.Types.COMMENT_REQUESTED:\n                this.handleCommentRequested(payload);\n                break;\n            case Actions.Types.COMMENT_SUCCEEDED:\n                this.handleCommentSucceeded(payload);\n                break;\n            case Actions.Types.COMMENT_FAILED:\n                this.handleCommentFailed(payload);\n                break;\n                \n            // Action Plans\n            case Actions.Types.ACTION_PLAN_REQUESTED:\n                this.handleActionPlanRequested(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_SUCCEEDED:\n                this.handleActionPlanSucceeded(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_FAILED:\n                this.handleActionPlanFailed(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_UPDATED:\n                this.handleUpdateActionPlan(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_DELETED:\n                this.handleDeleteActionPlan(payload);\n                break;\n                \n            // UI State\n            case Actions.Types.LOADING_SHOWN:\n                this.handleLoadingShown();\n                break;\n            case Actions.Types.LOADING_HIDDEN:\n                this.handleLoadingHidden();\n                break;\n            case Actions.Types.MESSAGE_SHOWN:\n                this.handleMessageShown(payload);\n                break;\n            case Actions.Types.MESSAGE_HIDDEN:\n                this.handleMessageHidden();\n                break;\n            case Actions.Types.PLAN_DRAWER_CLOSED:\n                this.handlePlanDrawerClosed();\n                break;\n            case Actions.Types.SIGNAL_DRAWER_CLOSED:\n                this.handleSignalDrawerClosed();\n                break;\n            case Actions.Types.PORTFOLIO_FILTERED:\n                this.handlePortfolioFiltered(payload);\n                break;\n                \n            // Account Management\n            case Actions.Types.ACCOUNT_EXPANDED:\n                this.handleAccountExpanded(payload);\n                break;\n            case Actions.Types.ACCOUNT_COLLAPSED:\n                this.handleAccountCollapsed(payload);\n                break;\n            case Actions.Types.SHOW_MORE_SIGNALS:\n                this.handleShowMoreSignals(payload);\n                break;\n            case Actions.Types.SHOW_LESS_SIGNALS:\n                this.handleShowLessSignals(payload);\n                break;\n                \n            // Modal/Drawer\n            case Actions.Types.MODAL_OPENED:\n                this.handleModalOpened(payload);\n                break;\n            case Actions.Types.MODAL_CLOSED:\n                this.handleModalClosed();\n                break;\n            case Actions.Types.DRAWER_OPENED:\n                this.handleDrawerOpened(payload);\n                break;\n            case Actions.Types.DRAWER_CLOSED:\n                this.handleDrawerClosed();\n                break;\n                \n            default:\n                console.log(`Unhandled action type: ${type}`);\n        }\n    }\n    \n    // ========== NORMALIZED DATA HANDLERS ==========\n    \n    /**\n     * Handle data page loaded (pagination)\n     */\n    handleDataPageLoaded(payload) {\n        console.log('📄 SignalsStore: handleDataPageLoaded');\n        const { data } = payload;\n        \n        // Add new signals to normalized data\n        if (data.signals) {\n            data.signals.forEach((signal, id) => {\n                this.normalizedData.signals.set(id, signal);\n            });\n        }\n        \n        // Add new accounts if any\n        if (data.accounts) {\n            data.accounts.forEach((account, id) => {\n                if (!this.normalizedData.accounts.has(id)) {\n                    this.normalizedData.accounts.set(id, account);\n                }\n            });\n        }\n        \n        // Add new recommended actions if any\n        if (data.recommendedActions) {\n            data.recommendedActions.forEach((action, id) => {\n                if (!this.normalizedData.recommendedActions.has(id)) {\n                    this.normalizedData.recommendedActions.set(id, action);\n                }\n            });\n        }\n        \n        // Update pagination state\n        if (data.pagination) {\n            this.state.pagination = { ...this.state.pagination, ...data.pagination };\n        }\n        \n        // Update denormalized signals array for backward compatibility\n        this.state.signals = Array.from(this.normalizedData.signals.values());\n        \n        // Clear cache to force re-render\n        this.state.viewCache.lastUpdate = Date.now();\n        \n        this.emit('data:page-loaded');\n    }\n    \n    /**\n     * Handle load next page request\n     */\n    async handleLoadNextPage() {\n        if (this.state.pagination.isLoading || !this.state.pagination.hasMore) {\n            return;\n        }\n        \n        this.state.pagination.isLoading = true;\n        this.emit('loading:page');\n        \n        try {\n            const result = await SignalsRepository.loadNextPage();\n            this.state.pagination.isLoading = false;\n            \n            if (!result.hasMore) {\n                console.log('✅ All signals loaded');\n            }\n        } catch (error) {\n            console.error('❌ Failed to load next page:', error);\n            this.state.pagination.isLoading = false;\n            this.emit('error:page-load');\n        }\n    }\n    \n    handleDataLoadSuccess(payload) {\n        console.log('📦 SignalsStore: handleDataLoadSuccess with normalized data');\n        \n        const normalizedData = payload.data;\n        \n        // Store normalized entities\n        this.normalizedData = {\n            accounts: normalizedData.accounts || new Map(),\n            signals: normalizedData.signals || new Map(),\n            recommendedActions: normalizedData.recommendedActions || new Map(),\n            interactions: normalizedData.interactions || new Map(),\n            comments: normalizedData.comments || new Map(),\n            actionPlans: normalizedData.actionPlans || new Map()\n        };\n        \n        // Store relationship indexes\n        this.indexes = {\n            signalsByAccount: normalizedData.signalsByAccount || new Map(),\n            signalsByAction: normalizedData.signalsByAction || new Map(),\n            actionsByAccount: normalizedData.actionsByAccount || new Map(),\n            interactionsBySignal: normalizedData.interactionsBySignal || new Map(),\n            commentsBySignal: normalizedData.commentsBySignal || new Map(),\n            commentsByAccount: normalizedData.commentsByAccount || new Map(),\n            plansByAccount: normalizedData.plansByAccount || new Map(),\n            plansByAction: normalizedData.plansByAction || new Map()\n        };\n        \n        // Store user info\n        const userInfo = normalizedData.userInfo || { userId: 'user-1', userName: 'Current User' };\n        \n        // Create denormalized data for backward compatibility\n        const denormalizedSignals = this.getDenormalizedSignals();\n        const denormalizedAccounts = this.getDenormalizedAccounts();\n        \n        this.setState({\n            loading: false,\n            userInfo: userInfo,\n            signals: denormalizedSignals,\n            accounts: denormalizedAccounts,\n            filteredSignals: denormalizedSignals,\n            signalsById: this.createSignalsById(denormalizedSignals),\n            signalsByAccount: this.indexes.signalsByAccount,\n            interactionsByUser: new Map(),\n            actionPlansByAccount: this.indexes.plansByAccount,\n            comments: this.normalizedData.comments,\n            interactions: this.normalizedData.interactions,\n            actionPlans: this.normalizedData.actionPlans\n        });\n        \n        console.log('🔔 SignalsStore: Emitting data:loaded event');\n        this.emitChange('data:loaded');\n    }\n    \n    // ========== DENORMALIZATION HELPERS ==========\n    \n    getDenormalizedSignals() {\n        const signals = Array.from(this.normalizedData.signals.values());\n        return signals.map(signal => this.denormalizeSignal(signal));\n    }\n    \n    denormalizeSignal(signal) {\n        const account = this.normalizedData.accounts.get(signal.account_id);\n        const action = this.normalizedData.recommendedActions.get(signal.action_id);\n        const interactions = this.getSignalInteractions(signal.signal_id);\n        \n        // Check if user has interacted\n        const hasUserInteraction = interactions.some(i => \n            i.interactionType === 'like' || \n            i.interactionType === 'not-accurate' ||\n            i.interactionType === 'signal_viewed'\n        );\n        \n        const userFeedback = interactions.find(i => \n            i.interactionType === 'like' || i.interactionType === 'not-accurate'\n        );\n        \n        return {\n            ...signal,\n            id: signal.signal_id,\n            \n            // Merge account data (for backward compatibility)\n            account_name: account?.account_name || signal.account_name,\n            account_action_context: account?.account_action_context,\n            account_action_context_rationale: account?.account_action_context_rationale,\n            account_metrics: account?.account_metrics,\n            usage_metrics: account?.usage_metrics,\n            financial: account?.financial,\n            ownership: account?.ownership,\n            at_risk_cat: account?.at_risk_cat,\n            account_gpa: account?.account_gpa,\n            health_score: account?.health_score,\n            daily_active_users: account?.daily_active_users,\n            weekly_active_users: account?.weekly_active_users,\n            monthly_active_users: account?.monthly_active_users,\n            total_lifetime_billings: account?.total_lifetime_billings,\n            bks_renewal_baseline_usd: account?.bks_renewal_baseline_usd,\n            \n            // Merge action data\n            recommended_action: action?.recommended_action,\n            signal_rationale: action?.signal_rationale || signal.signal_rationale,\n            plays: action?.plays || [],\n            \n            // UI state\n            isViewed: hasUserInteraction || signal.isViewed,\n            currentUserFeedback: userFeedback?.interactionType,\n            feedback: userFeedback?.interactionType\n        };\n    }\n    \n    getDenormalizedAccounts() {\n        const accountsMap = new Map();\n        \n        this.normalizedData.accounts.forEach((account, accountId) => {\n            const signalIds = this.indexes.signalsByAccount.get(accountId) || new Set();\n            const signals = Array.from(signalIds)\n                .map(id => this.normalizedData.signals.get(id))\n                .filter(s => s)\n                .map(s => this.denormalizeSignal(s));\n            \n            accountsMap.set(accountId, {\n                ...account,\n                id: accountId,\n                name: account.account_name,\n                signals: signals\n            });\n        });\n        \n        return accountsMap;\n    }\n    \n    getSignalInteractions(signalId) {\n        const interactionIds = this.indexes.interactionsBySignal.get(signalId) || new Set();\n        return Array.from(interactionIds)\n            .map(id => this.normalizedData.interactions.get(id))\n            .filter(interaction => interaction !== null);\n    }\n    \n    createSignalsById(signals) {\n        const signalsById = new Map();\n        signals.forEach(signal => {\n            signalsById.set(signal.id, signal);\n        });\n        return signalsById;\n    }\n    \n    // ========== PUBLIC API METHODS ==========\n    \n    getSignals() {\n        // Return denormalized signals for backward compatibility\n        return this.getDenormalizedSignals();\n    }\n    \n    getAccounts() {\n        return this.getDenormalizedAccounts();\n    }\n    \n    getAccount(accountId) {\n        const account = this.normalizedData.accounts.get(accountId);\n        if (!account) return null;\n        \n        const signalIds = this.indexes.signalsByAccount.get(accountId) || new Set();\n        const signals = Array.from(signalIds)\n            .map(id => this.normalizedData.signals.get(id))\n            .filter(s => s)\n            .map(s => this.denormalizeSignal(s));\n        \n        return {\n            ...account,\n            id: accountId,\n            name: account.account_name,\n            signals: signals\n        };\n    }\n    \n    getSignal(signalId) {\n        const signal = this.normalizedData.signals.get(signalId);\n        return signal ? this.denormalizeSignal(signal) : null;\n    }\n    \n    getActionPlans() {\n        const plans = Array.from(this.normalizedData.actionPlans.values());\n        \n        // Enrich with account names\n        return plans.map(plan => {\n            const account = this.normalizedData.accounts.get(plan.accountId);\n            return {\n                ...plan,\n                accountName: account?.account_name || plan.accountId\n            };\n        });\n    }\n    \n    getRecommendedAction(actionId) {\n        return this.normalizedData.recommendedActions.get(actionId);\n    }\n    \n    getRecommendedActions() {\n        return Array.from(this.normalizedData.recommendedActions.values());\n    }\n    \n    getComments(targetId) {\n        // Check both signal and account comments\n        const signalCommentIds = this.indexes.commentsBySignal.get(targetId) || new Set();\n        const accountCommentIds = this.indexes.commentsByAccount.get(targetId) || new Set();\n        \n        const allCommentIds = new Set([...signalCommentIds, ...accountCommentIds]);\n        \n        return Array.from(allCommentIds)\n            .map(id => this.normalizedData.comments.get(id))\n            .filter(comment => comment !== null);\n    }\n    \n    getInteractions(signalId) {\n        return this.getSignalInteractions(signalId);\n    }\n    \n    getUserInfo() {\n        return this.getState().userInfo;\n    }\n    \n    getFilteredSignals() {\n        let signals = this.getDenormalizedSignals();\n        const filters = this.getState().viewState.filters;\n        \n        // Apply filters\n        if (filters.priority !== 'all') {\n            signals = signals.filter(s => s.priority === filters.priority);\n        }\n        if (filters.category !== 'all') {\n            signals = signals.filter(s => s.category === filters.category);\n        }\n        if (filters.polarity !== 'all') {\n            signals = signals.filter(s => s.signal_polarity === filters.polarity);\n        }\n        if (filters.riskCategory !== 'all') {\n            signals = signals.filter(s => s.at_risk_cat === filters.riskCategory);\n        }\n        if (filters.searchText) {\n            const searchLower = filters.searchText.toLowerCase();\n            signals = signals.filter(s => \n                s.name?.toLowerCase().includes(searchLower) ||\n                s.summary?.toLowerCase().includes(searchLower) ||\n                s.account_name?.toLowerCase().includes(searchLower)\n            );\n        }\n        \n        return signals;\n    }\n    \n    // ========== CRUD OPERATIONS ==========\n    \n    createActionPlan(planData) {\n        const plan = {\n            id: planData.id || `plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            status: planData.status || 'pending',\n            assignee: this.getState().userInfo?.userId,\n            createdBy: this.getState().userInfo?.userName,\n            createdByUserId: this.getState().userInfo?.userId,\n            ...planData\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.actionPlans.set(plan.id, plan);\n        \n        // Update indexes\n        if (plan.accountId) {\n            if (!this.indexes.plansByAccount.has(plan.accountId)) {\n                this.indexes.plansByAccount.set(plan.accountId, new Set());\n            }\n            this.indexes.plansByAccount.get(plan.accountId).add(plan.id);\n        }\n        \n        if (plan.actionId) {\n            if (!this.indexes.plansByAction.has(plan.actionId)) {\n                this.indexes.plansByAction.set(plan.actionId, new Set());\n            }\n            this.indexes.plansByAction.get(plan.actionId).add(plan.id);\n        }\n        \n        // Update state for UI\n        const currentState = this.getState();\n        currentState.actionPlans.set(plan.id, plan);\n        this.setState({ \n            actionPlans: currentState.actionPlans,\n            actionPlansByAccount: this.indexes.plansByAccount\n        });\n        \n        this.emitChange('action_plan:created', plan);\n        return plan;\n    }\n    \n    updateActionPlan(planId, updates) {\n        const plan = this.normalizedData.actionPlans.get(planId);\n        if (!plan) return;\n        \n        const updatedPlan = {\n            ...plan,\n            ...updates,\n            updatedAt: new Date().toISOString(),\n            lastUpdatedBy: this.getState().userInfo?.userName,\n            lastUpdatedByUserId: this.getState().userInfo?.userId\n        };\n        \n        this.normalizedData.actionPlans.set(planId, updatedPlan);\n        \n        // Update state\n        const currentState = this.getState();\n        currentState.actionPlans.set(planId, updatedPlan);\n        this.setState({ actionPlans: currentState.actionPlans });\n        \n        this.emitChange('action_plan:updated', updatedPlan);\n        return updatedPlan;\n    }\n    \n    deleteActionPlan(planId) {\n        const plan = this.normalizedData.actionPlans.get(planId);\n        if (!plan) return;\n        \n        // Remove from indexes\n        if (plan.accountId && this.indexes.plansByAccount.has(plan.accountId)) {\n            this.indexes.plansByAccount.get(plan.accountId).delete(planId);\n        }\n        if (plan.actionId && this.indexes.plansByAction.has(plan.actionId)) {\n            this.indexes.plansByAction.get(plan.actionId).delete(planId);\n        }\n        \n        // Delete from normalized store\n        this.normalizedData.actionPlans.delete(planId);\n        \n        // Update state\n        const currentState = this.getState();\n        currentState.actionPlans.delete(planId);\n        this.setState({ actionPlans: currentState.actionPlans });\n        \n        this.emitChange('action_plan:deleted', planId);\n    }\n    \n    // ========== ACTION HANDLERS (keeping existing ones) ==========\n    \n    handleAppInitialized(payload) {\n        this.handleDataLoadSuccess(payload);\n        this.emitChange('app:initialized');\n    }\n    \n    handleTabChanged(payload) {\n        this.setState({\n            currentTab: payload.tabName\n        });\n        this.emitChange('tab:changed', payload.tabName);\n    }\n    \n    handleDataLoadRequested() {\n        this.setState({ loading: true });\n        this.emitChange('data:load-requested');\n    }\n    \n    handleDataLoadStarted() {\n        this.setState({ loading: true });\n        this.emitChange('loading:started');\n    }\n    \n    handleDataLoadFailed(payload) {\n        this.setState({ \n            loading: false,\n            message: { text: 'Failed to load data', type: 'error' }\n        });\n        this.emitChange('data:load_failed', payload.error);\n    }\n    \n    handleSignalRemoved(payload) {\n        const { signalId } = payload;\n        \n        // Remove from normalized store\n        const signal = this.normalizedData.signals.get(signalId);\n        if (signal) {\n            // Update indexes\n            if (signal.account_id && this.indexes.signalsByAccount.has(signal.account_id)) {\n                this.indexes.signalsByAccount.get(signal.account_id).delete(signalId);\n            }\n            if (signal.action_id && this.indexes.signalsByAction.has(signal.action_id)) {\n                this.indexes.signalsByAction.get(signal.action_id).delete(signalId);\n            }\n            \n            // Delete signal\n            this.normalizedData.signals.delete(signalId);\n            \n            // Update denormalized state\n            const denormalizedSignals = this.getDenormalizedSignals();\n            const denormalizedAccounts = this.getDenormalizedAccounts();\n            \n            this.setState({ \n                signals: denormalizedSignals,\n                accounts: denormalizedAccounts,\n                filteredSignals: this.applyFilters(this.getState().viewState.filters)\n            });\n        }\n        \n        this.emitChange('signal-removed', signalId);\n        this.emitChange('accounts-updated');\n    }\n    \n    handleSignalDetailsOpened(payload) {\n        const { signalId } = payload;\n        this.setState({ \n            selectedSignal: signalId,\n            drawer: { isOpen: true, type: 'signal-details', data: { signalId } }\n        });\n        this.emitChange('signal-details-opened', signalId);\n    }\n    \n    handlePlanDrawerClosed() {\n        this.setState({ \n            drawer: { isOpen: false, type: null, data: null }\n        });\n        this.emitChange('plan-drawer-closed');\n    }\n    \n    handleSignalDrawerClosed() {\n        this.setState({ \n            drawer: { isOpen: false, type: null, data: null },\n            selectedSignal: null\n        });\n        this.emitChange('signal-drawer-closed');\n    }\n    \n    handlePortfolioFiltered(payload) {\n        const { filterType } = payload;\n        this.emitChange('portfolio-filtered', filterType);\n    }\n    \n    handleAccountExpanded(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            account.isExpanded = true;\n            this.setState({ accounts });\n            this.emitChange('account-expanded', accountId);\n        }\n    }\n    \n    handleAccountCollapsed(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            account.isExpanded = false;\n            this.setState({ accounts });\n            this.emitChange('account-collapsed', accountId);\n        }\n    }\n    \n    handleShowMoreSignals(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            if (!account.signalsPagination) {\n                account.signalsPagination = { currentPage: 0, pageSize: 3 };\n            }\n            account.signalsPagination.currentPage++;\n            this.setState({ accounts });\n            this.emitChange('accounts-updated');\n        }\n    }\n    \n    handleShowLessSignals(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            if (!account.signalsPagination) {\n                account.signalsPagination = { currentPage: 0, pageSize: 3 };\n            }\n            account.signalsPagination.currentPage = 0;\n            this.setState({ accounts });\n            this.emitChange('accounts-updated');\n        }\n    }\n    \n    handleSignalsFiltered(payload) {\n        const newViewState = {\n            ...this.state.viewState,\n            filters: payload.filters || this.state.viewState.filters\n        };\n        \n        const filteredSignals = this.applyFilters(payload.filters);\n        this.setState({ \n            filteredSignals,\n            viewState: newViewState\n        });\n        this.emitChange('signals:filtered', filteredSignals);\n    }\n    \n    handleSignalViewed(payload) {\n        const interaction = {\n            id: `interaction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: payload.signalId,\n            interactionType: 'signal_viewed',\n            timestamp: new Date().toISOString(),\n            userId: this.getState().userInfo?.userId,\n            userName: this.getState().userInfo?.userName,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.interactions.set(interaction.id, interaction);\n        \n        // Update index\n        if (!this.indexes.interactionsBySignal.has(interaction.signalId)) {\n            this.indexes.interactionsBySignal.set(interaction.signalId, new Set());\n        }\n        this.indexes.interactionsBySignal.get(interaction.signalId).add(interaction.id);\n        \n        // Mark signal as viewed\n        const signal = this.normalizedData.signals.get(payload.signalId);\n        if (signal) {\n            signal.isViewed = true;\n        }\n        \n        this.emitChange('signal:viewed', payload.signalId);\n    }\n    \n    handleSignalSelected(payload) {\n        this.setState({ selectedSignal: payload.signal });\n        this.emitChange('signal:selected', payload.signal);\n    }\n    \n    handleFeedbackRequested(payload) {\n        const { signalId, feedbackType, userId, operationId } = payload;\n        \n        // Create snapshot for rollback\n        this.createSnapshot(operationId);\n        \n        // Add interaction\n        const interaction = {\n            id: `interaction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: signalId,\n            interactionType: feedbackType,\n            timestamp: new Date().toISOString(),\n            userId: userId || this.getState().userInfo?.userId,\n            userName: this.getState().userInfo?.userName,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.interactions.set(interaction.id, interaction);\n        \n        // Update index\n        if (!this.indexes.interactionsBySignal.has(interaction.signalId)) {\n            this.indexes.interactionsBySignal.set(interaction.signalId, new Set());\n        }\n        this.indexes.interactionsBySignal.get(interaction.signalId).add(interaction.id);\n        \n        this.emitChange('feedback:requested', { signalId, feedbackType });\n    }\n    \n    handleFeedbackSucceeded(payload) {\n        const { operationId } = payload;\n        this.commitSnapshot(operationId);\n        this.emitChange('feedback:succeeded', payload);\n    }\n    \n    handleFeedbackFailed(payload) {\n        const { operationId, error } = payload;\n        this.rollback(operationId);\n        this.setState({\n            message: { text: 'Failed to save feedback', type: 'error' }\n        });\n        this.emitChange('feedback:failed', { error });\n    }\n    \n    handleCommentRequested(payload) {\n        const { signalId, accountId, text, userId, operationId } = payload;\n        \n        this.createSnapshot(operationId);\n        \n        const comment = {\n            id: `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: signalId || null,\n            accountId: accountId || null,\n            text: text,\n            author: this.getState().userInfo?.userName,\n            authorId: userId || this.getState().userInfo?.userId,\n            timestamp: new Date().toISOString(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            isOptimistic: true\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.comments.set(comment.id, comment);\n        \n        // Update indexes\n        if (comment.signalId) {\n            if (!this.indexes.commentsBySignal.has(comment.signalId)) {\n                this.indexes.commentsBySignal.set(comment.signalId, new Set());\n            }\n            this.indexes.commentsBySignal.get(comment.signalId).add(comment.id);\n        } else if (comment.accountId) {\n            if (!this.indexes.commentsByAccount.has(comment.accountId)) {\n                this.indexes.commentsByAccount.set(comment.accountId, new Set());\n            }\n            this.indexes.commentsByAccount.get(comment.accountId).add(comment.id);\n        }\n        \n        this.emitChange('comment:requested', comment);\n    }\n    \n    handleCommentSucceeded(payload) {\n        const { comment, operationId } = payload;\n        \n        // Update the optimistic comment\n        const existingComment = this.normalizedData.comments.get(comment.id);\n        if (existingComment) {\n            this.normalizedData.comments.set(comment.id, { ...comment, isOptimistic: false });\n        }\n        \n        this.commitSnapshot(operationId);\n        this.emitChange('comment:succeeded', comment);\n    }\n    \n    handleCommentFailed(payload) {\n        const { operationId, error } = payload;\n        this.rollback(operationId);\n        this.setState({\n            message: { text: 'Failed to save comment', type: 'error' }\n        });\n        this.emitChange('comment:failed', { error });\n    }\n    \n    handleActionPlanRequested(payload) {\n        const { signalId, title, description, tasks, userId, operationId } = payload;\n        \n        this.createSnapshot(operationId);\n        \n        const plan = this.createActionPlan({\n            signalId,\n            title,\n            description,\n            tasks: tasks || [],\n            userId: userId || this.getState().userInfo?.userId,\n            isOptimistic: true\n        });\n        \n        this.emitChange('action_plan:requested', plan);\n    }\n    \n    handleActionPlanSucceeded(payload) {\n        const { plan, operationId } = payload;\n        \n        const existingPlan = this.normalizedData.actionPlans.get(plan.id);\n        if (existingPlan) {\n            this.normalizedData.actionPlans.set(plan.id, { ...plan, isOptimistic: false });\n        }\n        \n        this.commitSnapshot(operationId);\n        this.emitChange('action_plan:succeeded', plan);\n    }\n    \n    handleActionPlanFailed(payload) {\n        const { operationId, error } = payload;\n        this.rollback(operationId);\n        this.setState({\n            message: { text: 'Failed to save action plan', type: 'error' }\n        });\n        this.emitChange('action_plan:failed', { error });\n    }\n    \n    handleUpdateActionPlan(payload) {\n        const { planId, updates } = payload;\n        this.updateActionPlan(planId, updates);\n    }\n    \n    handleDeleteActionPlan(payload) {\n        const { planId } = payload;\n        this.deleteActionPlan(planId);\n    }\n    \n    handleLoadingShown() {\n        this.setState({ loading: true });\n        this.emitChange('loading:shown');\n    }\n    \n    handleLoadingHidden() {\n        this.setState({ loading: false });\n        this.emitChange('loading:hidden');\n    }\n    \n    handleMessageShown(payload) {\n        this.setState({\n            message: { text: payload.message, type: payload.type }\n        });\n        this.emitChange('message:shown', payload);\n    }\n    \n    handleMessageHidden() {\n        this.setState({ message: null });\n        this.emitChange('message:hidden');\n    }\n    \n    handleModalOpened(payload) {\n        this.setState({\n            modal: { \n                isOpen: true, \n                type: payload.modalType, \n                data: payload.data \n            }\n        });\n        this.emitChange('modal:opened', payload);\n    }\n    \n    handleModalClosed() {\n        this.setState({\n            modal: { isOpen: false, type: null, data: null }\n        });\n        this.emitChange('modal:closed');\n    }\n    \n    handleDrawerOpened(payload) {\n        this.setState({\n            drawer: { \n                isOpen: true, \n                type: payload.drawerType, \n                data: payload.data \n            }\n        });\n        this.emitChange('drawer:opened', payload);\n    }\n    \n    handleDrawerClosed() {\n        this.setState({\n            drawer: { isOpen: false, type: null, data: null }\n        });\n        this.emitChange('drawer:closed');\n    }\n    \n    // ========== HELPER METHODS ==========\n    \n    applyFilters(filters) {\n        let signals = this.getDenormalizedSignals();\n        \n        if (!filters) return signals;\n        \n        if (filters.priority && filters.priority !== 'all') {\n            signals = signals.filter(s => s.priority === filters.priority);\n        }\n        if (filters.category && filters.category !== 'all') {\n            signals = signals.filter(s => s.category === filters.category);\n        }\n        if (filters.signalType && filters.signalType !== 'all') {\n            signals = signals.filter(s => s.category === filters.signalType);\n        }\n        if (filters.polarity && filters.polarity !== 'all') {\n            signals = signals.filter(s => s.signal_polarity === filters.polarity);\n        }\n        if (filters.riskCategory && filters.riskCategory !== 'all') {\n            signals = signals.filter(s => s.at_risk_cat === filters.riskCategory);\n        }\n        if (filters.searchText) {\n            const searchLower = filters.searchText.toLowerCase();\n            signals = signals.filter(s => \n                s.name?.toLowerCase().includes(searchLower) ||\n                s.summary?.toLowerCase().includes(searchLower) ||\n                s.account_name?.toLowerCase().includes(searchLower)\n            );\n        }\n        \n        return signals;\n    }\n}\n\n// Create singleton instance\nconst signalsStore = new SignalsStore();\n\n// Make globally available\nwindow.SignalsStore = SignalsStore;\nwindow.signalsStore = signalsStore;","size_bytes":38665},"js/flux/Store.js":{"content":"// Store - Base class for Flux stores with optimistic updates and rollback capability\nclass Store {\n    \n    constructor(storeId) {\n        this.storeId = storeId;\n        this.state = {};\n        this.listeners = new Map();\n        this.snapshots = new Map(); // For optimistic rollback\n        this.isInitialized = false;\n        \n        // Register with dispatcher\n        dispatcher.register(storeId, this.dispatch.bind(this));\n        \n        console.log(`🏪 Store ${storeId} initialized`);\n    }\n    \n    /**\n     * Get current state\n     * @returns {Object} - Current store state\n     */\n    getState() {\n        return this.state;\n    }\n    \n    /**\n     * Set initial state\n     * @param {Object} initialState - Initial state object\n     */\n    setInitialState(initialState) {\n        this.state = { ...initialState };\n        this.isInitialized = true;\n        this.emitChange();\n    }\n    \n    /**\n     * Update state with new data\n     * @param {Object} newState - State updates to apply\n     */\n    setState(newState) {\n        this.state = { ...this.state, ...newState };\n        this.emitChange();\n    }\n    \n    /**\n     * Main dispatch method - routes actions to reducers\n     * @param {Object} action - Action to handle\n     */\n    dispatch(action) {\n        // Override in subclasses to handle specific actions\n        console.log(`Store ${this.storeId} received action: ${action.type}`);\n    }\n    \n    /**\n     * Subscribe to store changes\n     * @param {string} eventType - Type of change to listen for\n     * @param {Function} callback - Function to call when change occurs\n     * @returns {Function} - Unsubscribe function\n     */\n    subscribe(eventType, callback) {\n        if (!this.listeners.has(eventType)) {\n            this.listeners.set(eventType, new Set());\n        }\n        \n        this.listeners.get(eventType).add(callback);\n        \n        // Return unsubscribe function\n        return () => {\n            const eventListeners = this.listeners.get(eventType);\n            if (eventListeners) {\n                eventListeners.delete(callback);\n                if (eventListeners.size === 0) {\n                    this.listeners.delete(eventType);\n                }\n            }\n        };\n    }\n    \n    /**\n     * Emit change event to all listeners\n     * @param {string} eventType - Type of change that occurred\n     * @param {Object} data - Optional data to pass to listeners\n     */\n    emitChange(eventType = 'change', data = null) {\n        const eventListeners = this.listeners.get(eventType);\n        if (eventListeners) {\n            eventListeners.forEach(callback => {\n                try {\n                    callback(this.state, data);\n                } catch (error) {\n                    console.error(`Error in ${eventType} listener:`, error);\n                }\n            });\n        }\n        \n        // Always emit generic 'change' event as well\n        if (eventType !== 'change') {\n            const changeListeners = this.listeners.get('change');\n            if (changeListeners) {\n                changeListeners.forEach(callback => {\n                    try {\n                        callback(this.state, { eventType, data });\n                    } catch (error) {\n                        console.error('Error in change listener:', error);\n                    }\n                });\n            }\n        }\n    }\n    \n    /**\n     * Create snapshot for optimistic updates\n     * @param {string} operationId - Unique ID for this operation\n     */\n    createSnapshot(operationId) {\n        this.snapshots.set(operationId, this.deepCloneState(this.state));\n        console.log(`📸 Created snapshot for operation: ${operationId}`);\n    }\n    \n    /**\n     * Deep clone state that preserves Map and Set objects\n     * @param {any} obj - Object to clone\n     * @returns {any} - Deep cloned object\n     */\n    deepCloneState(obj) {\n        if (obj === null || typeof obj !== 'object') {\n            return obj;\n        }\n        \n        if (obj instanceof Map) {\n            const clonedMap = new Map();\n            for (let [key, value] of obj) {\n                clonedMap.set(key, this.deepCloneState(value));\n            }\n            return clonedMap;\n        }\n        \n        if (obj instanceof Set) {\n            const clonedSet = new Set();\n            for (let value of obj) {\n                clonedSet.add(this.deepCloneState(value));\n            }\n            return clonedSet;\n        }\n        \n        if (obj instanceof Date) {\n            return new Date(obj.getTime());\n        }\n        \n        if (Array.isArray(obj)) {\n            return obj.map(item => this.deepCloneState(item));\n        }\n        \n        // Handle regular objects\n        const clonedObj = {};\n        for (let key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clonedObj[key] = this.deepCloneState(obj[key]);\n            }\n        }\n        return clonedObj;\n    }\n    \n    /**\n     * Commit optimistic changes (remove snapshot)\n     * @param {string} operationId - Operation ID to commit\n     */\n    commitSnapshot(operationId) {\n        if (this.snapshots.has(operationId)) {\n            this.snapshots.delete(operationId);\n            console.log(`✅ Committed operation: ${operationId}`);\n        }\n    }\n    \n    /**\n     * Rollback to snapshot (restore previous state)\n     * @param {string} operationId - Operation ID to rollback\n     */\n    rollback(operationId) {\n        const snapshot = this.snapshots.get(operationId);\n        if (snapshot) {\n            this.state = snapshot;\n            this.snapshots.delete(operationId);\n            this.emitChange('rollback', { operationId });\n            console.log(`🔄 Rolled back operation: ${operationId}`);\n        } else {\n            console.warn(`No snapshot found for operation: ${operationId}`);\n        }\n    }\n    \n    /**\n     * Get all active snapshots (for debugging)\n     * @returns {Array} - Array of snapshot operation IDs\n     */\n    getActiveSnapshots() {\n        return Array.from(this.snapshots.keys());\n    }\n    \n    /**\n     * Clear all snapshots\n     */\n    clearSnapshots() {\n        this.snapshots.clear();\n        console.log(`🧹 Cleared all snapshots for store: ${this.storeId}`);\n    }\n    \n    /**\n     * Destroy store and cleanup\n     */\n    destroy() {\n        // Clear all listeners\n        this.listeners.clear();\n        \n        // Clear all snapshots\n        this.clearSnapshots();\n        \n        // Unregister from dispatcher\n        dispatcher.unregister(this.storeId);\n        \n        console.log(`💥 Destroyed store: ${this.storeId}`);\n    }\n}\n\n// Utility function to create selectors (memoized getters)\nclass Selector {\n    constructor(selector, dependencies = []) {\n        this.selector = selector;\n        this.dependencies = dependencies;\n        this.cache = new Map();\n    }\n    \n    get(state) {\n        // Simple memoization based on state reference\n        const stateKey = JSON.stringify(this.dependencies.map(dep => dep(state)));\n        \n        if (this.cache.has(stateKey)) {\n            return this.cache.get(stateKey);\n        }\n        \n        const result = this.selector(state);\n        this.cache.set(stateKey, result);\n        \n        // Keep cache size manageable\n        if (this.cache.size > 10) {\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        \n        return result;\n    }\n    \n    clearCache() {\n        this.cache.clear();\n    }\n}\n\n// Helper function to create selectors\nfunction createSelector(selector, dependencies = []) {\n    return new Selector(selector, dependencies);\n}\n\n// Make Store and createSelector globally available\nwindow.Store = Store;\nwindow.createSelector = createSelector;","size_bytes":7784},"js/flux/repositories/SignalsRepository.js":{"content":"// SignalsRepository - Handles all data operations with normalized relational model\nclass SignalsRepository {\n    \n    // Pagination configuration\n    static PAGE_SIZE = 200; // Signals per page\n    static currentPage = 0;\n    static totalSignals = 0;\n    static allRawSignals = []; // Cache all raw signals\n    static isInitialLoadComplete = false;\n    \n    /**\n     * Load all application data and normalize into relational structure\n     * @returns {Promise} - Promise that resolves with normalized data\n     */\n    static async loadAllData() {\n        // Dispatch loading started action\n        dispatcher.dispatch(Actions.startDataLoad());\n        \n        try {\n            console.log('🚀 SignalsRepository: Starting data load and normalization...');\n            const startTime = performance.now();\n            \n            // Load raw data from all sources\n            const [\n                rawSignalsResult,\n                interactionsResult, \n                commentsResult,\n                actionPlansResult,\n                userInfoResult\n            ] = await Promise.allSettled([\n                this.loadRawSignals(),\n                this.loadInteractions(),\n                this.loadComments(),\n                this.loadActionPlans(),\n                this.loadUserInfo()\n            ]);\n\n            // Process raw results\n            const rawSignals = this.processResult(rawSignalsResult, 'signals', []);\n            const interactions = this.processResult(interactionsResult, 'interactions', []);\n            const comments = this.processResult(commentsResult, 'comments', []);\n            const actionPlans = this.processResult(actionPlansResult, 'action plans', []);\n            console.log(`🔍 [DEBUG] Loaded ${actionPlans.length} action plans from loadActionPlans:`, actionPlans.map(p => p.id));\n            const userInfo = this.processResult(userInfoResult, 'user info', { userId: 'user-1', userName: 'Current User' });\n\n            // Cache all raw signals for pagination\n            this.allRawSignals = rawSignals;\n            this.totalSignals = rawSignals.length;\n            \n            // For initial load, only process first page of signals\n            const firstPageSignals = rawSignals.slice(0, this.PAGE_SIZE);\n            console.log(`📄 Loading first page: ${firstPageSignals.length} of ${this.totalSignals} total signals`);\n            \n            // NORMALIZE THE DATA INTO RELATIONAL STRUCTURE\n            console.log(`🔍 [DEBUG] About to normalize ${actionPlans.length} action plans`);\n            const normalizedData = this.normalizeData(firstPageSignals, interactions, comments, actionPlans);\n            console.log(`🔍 [DEBUG] After normalization: ${normalizedData.actionPlans.size} action plans in store`);\n            \n            // Store metadata for pagination\n            normalizedData.pagination = {\n                currentPage: 0,\n                pageSize: this.PAGE_SIZE,\n                totalSignals: this.totalSignals,\n                loadedSignals: firstPageSignals.length,\n                hasMore: this.totalSignals > this.PAGE_SIZE\n            };\n            \n            const loadTime = performance.now() - startTime;\n            console.log(`⚡ Data load and normalization completed in ${loadTime.toFixed(2)}ms`);\n            \n            console.log('📊 Normalized data summary:', {\n                accounts: normalizedData.accounts.size,\n                signals: normalizedData.signals.size,\n                recommendedActions: normalizedData.recommendedActions.size,\n                interactions: normalizedData.interactions.size,\n                comments: normalizedData.comments.size,\n                actionPlans: normalizedData.actionPlans.size,\n                userInfo: userInfo.userName\n            });\n            \n            // Add userInfo to normalized data\n            normalizedData.userInfo = userInfo;\n            \n            // Dispatch success action with normalized data\n            dispatcher.dispatch(Actions.dataLoadSuccess(normalizedData));\n            \n            return normalizedData;\n            \n        } catch (error) {\n            console.error('❌ SignalsRepository: Failed to load data:', error);\n            dispatcher.dispatch(Actions.dataLoadFailed(error));\n            throw error;\n        }\n    }\n    \n    /**\n     * Load the next page of signals\n     * @returns {Promise} - Promise that resolves with the next page of normalized signals\n     */\n    static async loadNextPage() {\n        try {\n            this.currentPage++;\n            const startIdx = this.currentPage * this.PAGE_SIZE;\n            const endIdx = startIdx + this.PAGE_SIZE;\n            \n            // Check if we have more signals to load\n            if (startIdx >= this.totalSignals) {\n                console.log('📭 No more signals to load');\n                return { hasMore: false, signals: [] };\n            }\n            \n            // Get next page of signals\n            const nextPageSignals = this.allRawSignals.slice(startIdx, endIdx);\n            console.log(`📄 Loading page ${this.currentPage + 1}: ${nextPageSignals.length} signals (${startIdx}-${Math.min(endIdx, this.totalSignals)} of ${this.totalSignals})`);\n            \n            // Normalize just the new signals\n            const normalizedSignals = new Map();\n            const newAccounts = new Map();\n            const newActions = new Map();\n            \n            // Process new signals\n            nextPageSignals.forEach(rawSignal => {\n                // Extract account if new\n                const accountId = rawSignal.account_id;\n                if (accountId && !signalsStore.getAccount(accountId)) {\n                    const account = this.extractAccountFromSignal(rawSignal);\n                    newAccounts.set(accountId, account);\n                }\n                \n                // Extract action if new\n                const actionId = rawSignal.action_id;\n                if (actionId && !signalsStore.getRecommendedAction(actionId)) {\n                    const action = this.extractRecommendedActionFromSignal(rawSignal);\n                    newActions.set(actionId, action);\n                }\n                \n                // Extract normalized signal\n                const signal = this.extractNormalizedSignal(rawSignal);\n                normalizedSignals.set(signal.signal_id, signal);\n            });\n            \n            // Dispatch action to add new page to store\n            dispatcher.dispatch(Actions.dataPageLoaded({\n                signals: normalizedSignals,\n                accounts: newAccounts,\n                recommendedActions: newActions,\n                pagination: {\n                    currentPage: this.currentPage,\n                    pageSize: this.PAGE_SIZE,\n                    totalSignals: this.totalSignals,\n                    loadedSignals: Math.min(endIdx, this.totalSignals),\n                    hasMore: endIdx < this.totalSignals\n                }\n            }));\n            \n            return {\n                hasMore: endIdx < this.totalSignals,\n                signals: Array.from(normalizedSignals.values()),\n                loadedCount: Math.min(endIdx, this.totalSignals)\n            };\n            \n        } catch (error) {\n            console.error('❌ Failed to load next page:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Reset pagination state\n     */\n    static resetPagination() {\n        this.currentPage = 0;\n        this.totalSignals = 0;\n        this.allRawSignals = [];\n        this.isInitialLoadComplete = false;\n    }\n    \n    /**\n     * Normalize raw data into relational structure\n     */\n    static normalizeData(rawSignals, interactions, comments, actionPlans) {\n        console.log('🔄 Starting data normalization process...');\n        \n        // Initialize normalized stores\n        const accounts = new Map();\n        const signals = new Map();\n        const recommendedActions = new Map();\n        const normalizedInteractions = new Map();\n        const normalizedComments = new Map();\n        const normalizedActionPlans = new Map();\n        \n        // Initialize relationship indexes\n        const signalsByAccount = new Map();\n        const signalsByAction = new Map();\n        const actionsByAccount = new Map();\n        const interactionsBySignal = new Map();\n        const commentsBySignal = new Map();\n        const commentsByAccount = new Map();\n        const plansByAccount = new Map();\n        const plansByAction = new Map();\n        \n        // Step 1: Extract and normalize Accounts\n        console.log('📦 Extracting unique accounts...');\n        rawSignals.forEach(rawSignal => {\n            const accountId = rawSignal.account_id;\n            if (!accountId) return;\n            \n            if (!accounts.has(accountId)) {\n                const account = this.extractAccountFromSignal(rawSignal);\n                accounts.set(accountId, account);\n                signalsByAccount.set(accountId, new Set());\n                actionsByAccount.set(accountId, new Set());\n                plansByAccount.set(accountId, new Set());\n                commentsByAccount.set(accountId, new Set());\n            }\n        });\n        console.log(`✅ Extracted ${accounts.size} unique accounts`);\n        \n        // Step 2: Extract and normalize RecommendedActions\n        console.log('📦 Extracting unique recommended actions...');\n        rawSignals.forEach(rawSignal => {\n            const actionId = rawSignal.action_id;\n            if (!actionId) return;\n            \n            if (!recommendedActions.has(actionId)) {\n                const action = this.extractRecommendedActionFromSignal(rawSignal);\n                recommendedActions.set(actionId, action);\n                signalsByAction.set(actionId, new Set());\n                plansByAction.set(actionId, new Set());\n                \n                // Track action to account relationship\n                if (action.account_id && actionsByAccount.has(action.account_id)) {\n                    actionsByAccount.get(action.account_id).add(actionId);\n                }\n            }\n        });\n        console.log(`✅ Extracted ${recommendedActions.size} unique recommended actions`);\n        \n        // Step 3: Normalize Signals (remove embedded data)\n        console.log('📦 Normalizing signals...');\n        rawSignals.forEach(rawSignal => {\n            const signal = this.extractNormalizedSignal(rawSignal);\n            signals.set(signal.signal_id, signal);\n            \n            // Update relationship indexes\n            if (signal.account_id && signalsByAccount.has(signal.account_id)) {\n                signalsByAccount.get(signal.account_id).add(signal.signal_id);\n            }\n            if (signal.action_id && signalsByAction.has(signal.action_id)) {\n                signalsByAction.get(signal.action_id).add(signal.signal_id);\n            }\n            \n            // Initialize interaction index for this signal\n            interactionsBySignal.set(signal.signal_id, new Set());\n            commentsBySignal.set(signal.signal_id, new Set());\n        });\n        console.log(`✅ Normalized ${signals.size} signals`);\n        \n        // Step 4: Process Interactions\n        console.log('📦 Processing interactions...');\n        interactions.forEach(interaction => {\n            const interactionId = interaction.id || `interaction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            normalizedInteractions.set(interactionId, interaction);\n            \n            // Update index\n            if (interaction.signalId && interactionsBySignal.has(interaction.signalId)) {\n                interactionsBySignal.get(interaction.signalId).add(interactionId);\n            }\n        });\n        console.log(`✅ Processed ${normalizedInteractions.size} interactions`);\n        \n        // Step 5: Process Comments (dual-context)\n        console.log('📦 Processing comments...');\n        comments.forEach(comment => {\n            const commentId = comment.id || `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            \n            // Ensure comment has either signalId or accountId\n            if (comment.signalId) {\n                if (commentsBySignal.has(comment.signalId)) {\n                    commentsBySignal.get(comment.signalId).add(commentId);\n                }\n            } else if (comment.accountId) {\n                if (commentsByAccount.has(comment.accountId)) {\n                    commentsByAccount.get(comment.accountId).add(commentId);\n                }\n            }\n            \n            normalizedComments.set(commentId, comment);\n        });\n        console.log(`✅ Processed ${normalizedComments.size} comments`);\n        \n        // Step 6: Process ActionPlans\n        console.log('📦 Processing action plans...');\n        actionPlans.forEach(plan => {\n            const planId = plan.id || `plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            normalizedActionPlans.set(planId, plan);\n            \n            // Update indexes\n            if (plan.accountId && plansByAccount.has(plan.accountId)) {\n                plansByAccount.get(plan.accountId).add(planId);\n            }\n            if (plan.actionId && plansByAction.has(plan.actionId)) {\n                plansByAction.get(plan.actionId).add(planId);\n            }\n        });\n        console.log(`✅ Processed ${normalizedActionPlans.size} action plans`);\n        \n        // Return normalized data structure\n        return {\n            // Entity stores\n            accounts,\n            signals,\n            recommendedActions,\n            interactions: normalizedInteractions,\n            comments: normalizedComments,\n            actionPlans: normalizedActionPlans,\n            \n            // Relationship indexes\n            signalsByAccount,\n            signalsByAction,\n            actionsByAccount,\n            interactionsBySignal,\n            commentsBySignal,\n            commentsByAccount,\n            plansByAccount,\n            plansByAction\n        };\n    }\n    \n    /**\n     * Extract Account entity from raw signal data\n     */\n    static extractAccountFromSignal(rawSignal) {\n        return {\n            account_id: rawSignal.account_id || rawSignal['account id'],\n            account_name: rawSignal.account_name,\n            account_action_context: rawSignal.account_action_context || rawSignal['Account Action Context'] || '',\n            account_action_context_rationale: rawSignal.account_action_context_rationale || rawSignal['Account Action Context Rationale'] || '',\n            \n            // Account metrics object\n            account_metrics: rawSignal.account_metrics || {\n                relationship: rawSignal['Relationship'] || '',\n                content_creation: rawSignal['Content Creation'] || '',\n                user_engagement: rawSignal['User Engagement'] || '',\n                support: rawSignal['Support'] || '',\n                commercial: rawSignal['Commercial'] || '',\n                education: rawSignal['Education'] || '',\n                platform_utilization: rawSignal['Platform Utilization'] || '',\n                value_realization: rawSignal['Value Realization'] || '',\n                \n                relationship_value: parseFloat(rawSignal['Relationship - Value']) || 0,\n                content_creation_value: parseFloat(rawSignal['Content Creation - Value']) || 0,\n                user_engagement_value: parseFloat(rawSignal['User Engagement - Value']) || 0,\n                support_value: parseFloat(rawSignal['Support - Value']) || 0,\n                commercial_value: parseFloat(rawSignal['Commercial - Value']) || 0,\n                education_value: parseFloat(rawSignal['Education - Value']) || 0,\n                platform_utilization_value: parseFloat(rawSignal['Platform Utilization - Value']) || 0,\n                value_realization_value: parseFloat(rawSignal['Value Realization - Value']) || 0,\n                \n                health_score: parseFloat(rawSignal['Health Score'] || rawSignal.health_score) || 0,\n                at_risk_cat: rawSignal.at_risk_cat || '',\n                account_gpa: rawSignal['Account GPA'] || rawSignal.account_gpa || '',\n                account_gpa_numeric: parseFloat(rawSignal['Account GPA Numeric'] || rawSignal.account_gpa_numeric) || 0,\n                prior_account_gpa_numeric: parseFloat(rawSignal['Prior Account GPA Numeric']) || 0,\n                gpa_trend_180_day: rawSignal['180 Day GPA Trend '] || rawSignal['180 Day GPA Trend'] || '',\n                \n                industry: rawSignal['Industry (Domo)'] || '',\n                customer_tenure_years: parseFloat(rawSignal['Customer Tenure (Years)']) || 0,\n                type_of_next_renewal: rawSignal['Type of Next Renewal'] || '',\n                data_source: rawSignal['Data Source'] || ''\n            },\n            \n            // Usage metrics object\n            usage_metrics: rawSignal.usage_metrics || {\n                total_lifetime_billings: parseFloat(rawSignal['Total Lifetime Billings'] || rawSignal.total_lifetime_billings) || 0,\n                daily_active_users: parseInt(rawSignal['Daily Active Users (DAU)'] || rawSignal.daily_active_users) || 0,\n                weekly_active_users: parseInt(rawSignal['Weekly Active Users (WAU)'] || rawSignal.weekly_active_users) || 0,\n                monthly_active_users: parseInt(rawSignal['Monthly Active Users (MAU)'] || rawSignal.monthly_active_users) || 0,\n                total_data_sets: parseInt(rawSignal['Total Data Sets']) || 0,\n                total_rows: parseInt(rawSignal['Total Rows']) || 0,\n                dataflows: parseInt(rawSignal['Dataflows']) || 0,\n                cards: parseInt(rawSignal['Cards']) || 0,\n                is_consumption: rawSignal['is Consumption'] === 'TRUE' || rawSignal['is Consumption'] === 'true'\n            },\n            \n            // Financial object\n            financial: rawSignal.financial || {\n                next_renewal_date: rawSignal['Next Renewal Date'] || '',\n                bks_status_grouping: rawSignal.bks_status_grouping || '',\n                bks_fq: rawSignal.bks_fq || '',\n                rank: parseInt(rawSignal.rank) || 0,\n                bks_renewal_baseline_usd: parseFloat(rawSignal.bks_renewal_baseline_usd) || 0,\n                bks_forecast_new: parseFloat(rawSignal.bks_forecast_new) || 0,\n                bks_forecast_delta: parseFloat(rawSignal.bks_forecast_delta) || 0,\n                pacing_percentage: parseFloat(rawSignal['% Pacing']) || 0\n            },\n            \n            // Ownership object\n            ownership: rawSignal.ownership || {\n                ae: rawSignal['AE'] || '',\n                csm: rawSignal['CSM'] || '',\n                ae_email: rawSignal['AE Email'] || '',\n                csm_manager: rawSignal['CSM Manager'] || '',\n                rvp: rawSignal['RVP'] || '',\n                avp: rawSignal['AVP'] || '',\n                level_3_leader: rawSignal['level 3 leader'] || '',\n                account_owner: rawSignal['Account Owner'] || ''\n            },\n            \n            // Top-level metrics for quick access\n            at_risk_cat: rawSignal.at_risk_cat || '',\n            account_gpa: rawSignal['Account GPA'] || rawSignal.account_gpa || '',\n            health_score: parseFloat(rawSignal['Health Score'] || rawSignal.health_score) || 0,\n            daily_active_users: parseInt(rawSignal['Daily Active Users (DAU)'] || rawSignal.daily_active_users) || 0,\n            weekly_active_users: parseInt(rawSignal['Weekly Active Users (WAU)'] || rawSignal.weekly_active_users) || 0,\n            monthly_active_users: parseInt(rawSignal['Monthly Active Users (MAU)'] || rawSignal.monthly_active_users) || 0,\n            total_lifetime_billings: parseFloat(rawSignal['Total Lifetime Billings'] || rawSignal.total_lifetime_billings) || 0,\n            bks_renewal_baseline_usd: parseFloat(rawSignal.bks_renewal_baseline_usd) || 0\n        };\n    }\n    \n    /**\n     * Extract RecommendedAction entity from raw signal data\n     */\n    static extractRecommendedActionFromSignal(rawSignal) {\n        const accountId = rawSignal.account_id || rawSignal['account id'];\n        const actionId = rawSignal.action_id;\n        \n        // 🎯 Get signal priority for intelligent play defaults\n        const signalPriority = this.normalizeSignalPriority(rawSignal.priority || 'medium');\n        \n        // Extract plays from signal\n        const plays = [];\n        if (rawSignal.plays && Array.isArray(rawSignal.plays)) {\n            // 🔧 Enhance existing plays with new task management fields\n            const enhancedPlays = rawSignal.plays.map(play => {\n                return this.enhancePlayWithTaskManagement(play, signalPriority);\n            });\n            plays.push(...enhancedPlays);\n        } else {\n            // Build plays from individual fields with enhanced task management\n            for (let i = 1; i <= 3; i++) {\n                const playId = rawSignal[`play_${i}`];\n                if (playId) {\n                    plays.push({\n                        id: playId,\n                        name: rawSignal[`Play ${i} Name`] || '',\n                        description: rawSignal[`Play ${i} Description`] || '',\n                        full_description: rawSignal[`play_${i}_description`] || '',\n                        play_type: rawSignal[`play_${i}_play_type`] || '',\n                        initiating_role: rawSignal[`play_${i}_initiating_role`] || '',\n                        executing_role: rawSignal[`play_${i}_executing_role`] || '',\n                        doc_location: rawSignal[`play_${i}_doc_location`] || '',\n                        \n                        // 🎯 Enhanced task management fields with intelligent defaults\n                        status: 'pending',           // Always start with pending\n                        priority: signalPriority,    // Inherit from signal priority\n                        dueDate: this.calculateDefaultDueDate(10), // Today + 10 days\n                        assignee: rawSignal[`play_${i}_executing_role`] || null, // Use executing role as assignee\n                        createdAt: new Date().toISOString(),\n                        updatedAt: new Date().toISOString()\n                    });\n                }\n            }\n        }\n        \n        return {\n            action_id: actionId,\n            account_id: accountId,\n            recommended_action: rawSignal.recommended_action || '',\n            signal_rationale: rawSignal.signal_rationale || '',\n            // Use Call Scheduled Date as primary source, fallback to call_date\n            call_date: rawSignal['Call Scheduled Date'] || rawSignal.call_date || '',\n            // Add created_at field - when the recommended action was created\n            // Due to CSV corruption, the timestamp ended up in the play_3 field\n            created_at: rawSignal.play_3 || rawSignal.created_at || '',\n            plays: plays\n        };\n    }\n    \n    /**\n     * Enhance play object with new task management fields\n     * Handles migration from old format to new enhanced format\n     */\n    static enhancePlayWithTaskManagement(play, signalPriority = 'medium') {\n        // Handle string plays (legacy format)\n        if (typeof play === 'string') {\n            return {\n                id: `PLAY-${Math.random().toString(36).substr(2, 3).toUpperCase()}`, // Generate ID if missing\n                name: play,\n                description: '',\n                status: 'pending',\n                priority: signalPriority, // 🎯 Use signal priority\n                dueDate: this.calculateDefaultDueDate(10), // 🎯 Today + 10 days\n                assignee: null,\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString()\n            };\n        }\n        \n        // Handle object plays - enhance with new fields if missing\n        const enhancedPlay = {\n            ...play,\n            // Migrate old completed boolean to status\n            status: play.status || (play.completed ? 'complete' : 'pending'),\n            priority: play.priority || signalPriority, // 🎯 Use signal priority as default\n            dueDate: play.dueDate || this.calculateDefaultDueDate(10), // 🎯 Today + 10 days\n            assignee: play.assignee || play.executing_role || null,\n            createdAt: play.createdAt || new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        \n        // Remove old completed field if it exists\n        if (enhancedPlay.completed !== undefined) {\n            delete enhancedPlay.completed;\n        }\n        \n        return enhancedPlay;\n    }\n    \n    /**\n     * Normalize signal priority to play priority format\n     */\n    static normalizeSignalPriority(signalPriority) {\n        const priorityMap = {\n            'High': 'high',\n            'high': 'high',\n            'HIGH': 'high',\n            'Medium': 'medium', \n            'medium': 'medium',\n            'MEDIUM': 'medium',\n            'Low': 'low',\n            'low': 'low',\n            'LOW': 'low'\n        };\n        return priorityMap[signalPriority] || 'medium';\n    }\n    \n    /**\n     * Calculate default due date (today + specified days)\n     */\n    static calculateDefaultDueDate(daysFromToday = 10) {\n        const today = new Date();\n        const dueDate = new Date(today);\n        dueDate.setDate(today.getDate() + daysFromToday);\n        return dueDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format\n    }\n    \n    /**\n     * Normalize signal polarity values to standard format\n     * Maps legacy \"Opportunity\" to \"Opportunities\"\n     */\n    static normalizeSignalPolarity(polarity) {\n        if (polarity === 'Opportunity') {\n            return 'Opportunities';\n        }\n        return polarity;\n    }\n\n    /**\n     * Extract normalized Signal entity (without embedded data)\n     */\n    static extractNormalizedSignal(rawSignal) {\n        return {\n            signal_id: rawSignal.id || rawSignal['Signal Id'] || `signal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            account_id: rawSignal.account_id || rawSignal['account id'],\n            action_id: rawSignal.action_id || '',\n            \n            // Signal-specific fields only\n            category: rawSignal.category || '',\n            code: rawSignal.code || '',\n            name: rawSignal.name || '',\n            summary: rawSignal.summary || '',\n            rationale: rawSignal.rationale || '',\n            priority: rawSignal.priority || 'Medium',\n            confidence: parseFloat(rawSignal.confidence) || 0,\n            signal_confidence: parseFloat(rawSignal.signal_confidence) || 0,\n            signal_polarity: this.normalizeSignalPolarity(rawSignal.signal_polarity || rawSignal['Signal Polarity'] || 'Enrichment'),\n            \n            // AI context (signal-specific)\n            ai_signal_context: rawSignal.ai_signal_context || rawSignal['AI Signal Context'] || '',\n            ai_account_signal_context: rawSignal.ai_account_signal_context || rawSignal['AI Account Signal Context'] || '',\n            ai_account_signal_context_rationale: rawSignal.ai_account_signal_context_rationale || rawSignal['AI Account Signal Context Rationale'] || '',\n            \n            // Call context (signal-specific)\n            call_context: rawSignal.call_context || {\n                call_id: rawSignal.call_id || '',\n                // Use Call Scheduled Date as primary source, fallback to call_date\n                call_date: rawSignal['Call Scheduled Date'] || rawSignal.call_date || '',\n                call_url: rawSignal['Call URL'] || '',\n                call_title: rawSignal['Call Title'] || '',\n                call_scheduled_date: rawSignal['Call Scheduled Date'] || '',\n                call_attendees: rawSignal['Call Attendees'] || '',\n                call_recap: rawSignal['Call Recap'] || ''\n            },\n            \n            created_at: rawSignal.created_at || rawSignal.created_date || new Date().toISOString(),\n            \n            // UI state (not from CSV)\n            isViewed: false,\n            feedback: null\n        };\n    }\n    \n    /**\n     * Process Promise.allSettled result\n     */\n    static processResult(result, name, defaultValue) {\n        if (result.status === 'fulfilled') {\n            return result.value;\n        } else {\n            console.warn(`⚠️ Failed to load ${name}:`, result.reason);\n            return defaultValue;\n        }\n    }\n    \n    /**\n     * Load raw signals from API or CSV\n     */\n    static async loadRawSignals() {\n        try {\n            console.log('📡 Loading signals...');\n            const response = await domo.get('/data/v1/signals');\n            \n            if (response && response.length > 0) {\n                console.log(`✅ Loaded ${response.length} signals from Domo API`);\n                return response;\n            } else {\n                console.warn('⚠️ No signals from API, using CSV fallback');\n                return await this.loadMasterCSV();\n            }\n        } catch (error) {\n            console.error('❌ Failed to load signals from API:', error);\n            console.warn('Falling back to master CSV data');\n            return await this.loadMasterCSV();\n        }\n    }\n    \n    /**\n     * Load master CSV fallback data\n     */\n    static async loadMasterCSV() {\n        try {\n            console.log('Loading master CSV data...');\n            \n            const cacheBuster = `?v=${Date.now()}`;\n            const response = await fetch(`./data.csv${cacheBuster}`);\n            \n            if (!response.ok) {\n                throw new Error(`Failed to load CSV: ${response.status}`);\n            }\n            \n            const csvText = await response.text();\n            console.log('Master CSV loaded successfully, length:', csvText.length);\n            \n            const parsedData = this.parseCSV(csvText);\n            console.log(`Parsed ${parsedData.length} records from master CSV`);\n            \n            return parsedData;\n        } catch (error) {\n            console.error('Error loading master CSV:', error);\n            return [];\n        }\n    }\n    \n    /**\n     * Parse CSV text into raw data\n     */\n    static parseCSV(csvText) {\n        console.log('🔍 Parsing CSV with stateful tokenizer...');\n        const startTime = performance.now();\n        \n        const rows = this.tokenizeCSV(csvText);\n        \n        if (rows.length === 0) {\n            console.warn('⚠️ No rows found in CSV');\n            return [];\n        }\n        \n        const headers = rows[0];\n        console.log(`📋 Parsed ${headers.length} header columns from CSV`);\n        \n        const data = [];\n        \n        for (let i = 1; i < rows.length; i++) {\n            const values = rows[i];\n            const row = {};\n\n            // Build row object from headers and values\n            for (let j = 0; j < headers.length; j++) {\n                const header = headers[j];\n                const value = values[j] || '';\n                row[header] = value;\n            }\n\n            data.push(row);\n        }\n        \n        const parseTime = performance.now() - startTime;\n        console.log(`⚡ CSV parsing completed in ${parseTime.toFixed(2)}ms`);\n        \n        return data;\n    }\n    \n    /**\n     * Stateful CSV tokenizer\n     */\n    static tokenizeCSV(csvText) {\n        const rows = [];\n        let currentRow = [];\n        let currentField = '';\n        let inQuotes = false;\n        let i = 0;\n        \n        console.log('🔄 Tokenizing CSV...');\n        \n        while (i < csvText.length) {\n            const char = csvText[i];\n            const nextChar = csvText[i + 1];\n            \n            if (char === '\"') {\n                if (inQuotes && nextChar === '\"') {\n                    currentField += '\"';\n                    i += 2;\n                    continue;\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                currentRow.push(currentField);\n                currentField = '';\n            } else if ((char === '\\n' || char === '\\r') && !inQuotes) {\n                currentRow.push(currentField);\n                \n                if (currentRow.some(field => field.trim() !== '')) {\n                    rows.push(currentRow);\n                }\n                \n                currentRow = [];\n                currentField = '';\n                \n                if (char === '\\r' && nextChar === '\\n') {\n                    i++;\n                }\n            } else {\n                currentField += char;\n            }\n            \n            i++;\n        }\n        \n        if (currentField !== '' || currentRow.length > 0) {\n            currentRow.push(currentField);\n            if (currentRow.some(field => field.trim() !== '')) {\n                rows.push(currentRow);\n            }\n        }\n        \n        console.log(`✅ Tokenized ${rows.length} rows`);\n        return rows;\n    }\n    \n    /**\n     * Load interactions from API or fallback\n     */\n    static async loadInteractions() {\n        try {\n            console.log('👍 Loading interactions from Domo API...');\n            const response = await domo.get('/domo/datastores/v1/collections/SignalAI.Interactions/documents');\n            \n            if (response && response.length > 0) {\n                console.log(`✅ Loaded ${response.length} interactions from API`);\n                // Extract content from wrapper if needed\n                return response.map(item => item.content || item);\n            } else {\n                console.log('📦 Using default interactions (empty)');\n                return [];\n            }\n        } catch (error) {\n            console.error('❌ Failed to load interactions from API:', error);\n            console.log('📁 Loading fallback interactions...');\n            return this.loadFallbackInteractions();\n        }\n    }\n    \n    /**\n     * Load fallback interactions\n     */\n    static loadFallbackInteractions() {\n        console.log('📦 Using default interactions (empty)');\n        return [];\n    }\n    \n    /**\n     * Load comments from API or fallback\n     */\n    static async loadComments() {\n        try {\n            console.log('💬 Loading comments from Domo API...');\n            const response = await domo.get('/domo/datastores/v1/collections/SignalAI.Comments/documents');\n            \n            if (response && response.length > 0) {\n                console.log(`✅ Loaded ${response.length} comments from API`);\n                // Extract content from wrapper if needed\n                return response.map(item => item.content || item);\n            } else {\n                console.log('📦 Using default comments (empty)');\n                return [];\n            }\n        } catch (error) {\n            console.error('❌ Failed to load comments from API:', error);\n            console.log('📁 Loading fallback comments...');\n            return this.loadFallbackComments();\n        }\n    }\n    \n    /**\n     * Load fallback comments\n     */\n    static loadFallbackComments() {\n        console.log('📦 Using default comments (empty)');\n        return [];\n    }\n    \n    /**\n     * Load action plans from API or fallback\n     */\n    static async loadActionPlans() {\n        try {\n            console.log('📋 Loading action plans...');\n            const response = await domo.get('/domo/datastores/v1/collections/SignalAI.ActionPlans/documents');\n            \n            if (response && response.length > 0) {\n                console.log(`✅ Loaded ${response.length} action plans from API`);\n                // Extract content from wrapper if needed\n                return response.map(item => item.content || item);\n            } else {\n                throw new Error('No action plans from API');\n            }\n        } catch (error) {\n            console.log('Failed to load action plans from API:', error);\n            return await this.loadFallbackActionPlans();\n        }\n    }\n    \n    /**\n     * Load fallback action plans\n     */\n    static async loadFallbackActionPlans() {\n        try {\n            const cacheBuster = `?v=${Date.now()}`;\n            const response = await fetch(`./action-plans-fallback.json${cacheBuster}`);\n            \n            if (!response.ok) {\n                throw new Error(`Failed to load fallback action plans: ${response.status}`);\n            }\n            \n            const data = await response.json();\n            console.log(`✅ Loaded ${data.length} action plans from fallback (error recovery)`);\n            \n            // Transform the fallback data to match expected format\n            // Extract content from the wrapper document structure and preserve Domo document ID\n            return data.map(planWrapper => {\n                const plan = planWrapper.content || planWrapper; // Handle both wrapped and unwrapped formats\n                const domoDocumentId = planWrapper.id; // Preserve Domo document ID from wrapper\n                \n                // 🎯 Enhance plays with new task management fields\n                const enhancedPlays = (plan.plays || []).map(play => {\n                    return this.enhancePlayWithTaskManagement(play);\n                });\n                \n                return {\n                    id: plan.id,  // Use the actual plan ID from content, not wrapper document ID\n                    domoDocumentId: domoDocumentId, // 🔧 FIX: Store Domo document ID for API updates\n                    recordId: domoDocumentId, // Legacy compatibility\n                    accountId: plan.accountId,\n                    actionId: plan.actionId,\n                    title: plan.title,\n                    status: plan.status || 'pending',\n                    createdAt: plan.createdAt || new Date().toISOString(),\n                    updatedAt: plan.updatedAt || new Date().toISOString(),\n                    planTitle: plan.planTitle || `Action Plan - ${plan.accountId}`,\n                    description: plan.description || '',\n                    plays: enhancedPlays,  // Use enhanced plays with task management fields\n                    priority: plan.priority || 'medium',\n                    dueDate: plan.dueDate,\n                    actionItems: plan.actionItems || [],\n                    assignee: plan.assignee,\n                    createdBy: plan.createdBy,\n                    createdByUserId: plan.createdByUserId,\n                    lastUpdatedBy: plan.lastUpdatedBy,\n                    lastUpdatedByUserId: plan.lastUpdatedByUserId\n                };\n            });\n        } catch (error) {\n            console.error('Failed to load fallback action plans:', error);\n            return [];\n        }\n    }\n    \n    /**\n     * Load user info from API or fallback\n     */\n    static async loadUserInfo() {\n        try {\n            console.log('👤 Loading user info from Domo API...');\n            const response = await domo.env;\n            \n            if (response && response.userId) {\n                console.log('✅ Loaded user info from Domo environment');\n                return {\n                    userId: response.userId,\n                    userName: response.userName || 'Current User'\n                };\n            } else {\n                throw new Error('No user info from Domo environment');\n            }\n        } catch (error) {\n            console.error('❌ Failed to load user info from API:', error);\n            console.log('📁 Loading fallback user info...');\n            return this.loadFallbackUserInfo();\n        }\n    }\n    \n    /**\n     * Load fallback user info\n     */\n    static loadFallbackUserInfo() {\n        console.log('📦 Using default user info');\n        return {\n            userId: 'user-1',\n            userName: 'Current User'\n        };\n    }\n    \n    // ========== ACTION PLAN CRUD OPERATIONS ==========\n    \n    /**\n     * Save a new action plan\n     */\n    static async saveActionPlan(planData) {\n        try {\n            console.log('💾 Saving action plan:', planData);\n            \n            // Try to save to Domo API\n            try {\n                const response = await domo.post('/domo/datastores/v1/collections/SignalAI.ActionPlans/documents', {\n                    content: planData\n                });\n                \n                if (response && response.id) {\n                    console.log('✅ Action plan saved to Domo API');\n                    // Store both internal ID and Domo document ID for proper updates\n                    const planWithDomoId = { \n                        ...planData, \n                        domoDocumentId: response.id,  // Domo-generated document ID for API calls\n                        recordId: response.id         // Legacy compatibility\n                    };\n                    return { success: true, data: planWithDomoId };\n                }\n            } catch (apiError) {\n                console.warn('⚠️ Failed to save to Domo API, using local storage:', apiError);\n            }\n            \n            // Fallback: Store locally and return success for optimistic update\n            const storageKey = 'signalai_action_plans';\n            const existingPlans = JSON.parse(localStorage.getItem(storageKey) || '[]');\n            existingPlans.push(planData);\n            localStorage.setItem(storageKey, JSON.stringify(existingPlans));\n            \n            console.log('✅ Action plan saved to local storage (fallback)');\n            return { success: true, data: planData };\n            \n        } catch (error) {\n            console.error('❌ Failed to save action plan:', error);\n            return { success: false, error: error.message };\n        }\n    }\n    \n    /**\n     * Update an existing action plan\n     */\n    static async updateActionPlan(planId, updates) {\n        try {\n            console.log('📝 Updating action plan:', planId, updates);\n            \n            // 🔧 FIX: Use fresh lookup approach (proven working pattern)\n            // Step 1: Get existing plan data to merge with updates\n            let existingPlan = null;\n            if (window.signalsStore) {\n                const state = window.signalsStore.getState();\n                if (state.actionPlans && state.actionPlans.has(planId)) {\n                    existingPlan = state.actionPlans.get(planId);\n                }\n            }\n            \n            if (!existingPlan) {\n                throw new Error(`Plan ${planId} not found in store`);\n            }\n            \n            // Step 2: Create merged plan with updates\n            const mergedPlan = {\n                ...existingPlan,\n                ...updates,\n                updatedAt: new Date().toISOString()\n            };\n            \n            // Step 3: Fresh lookup to find correct Domo document ID\n            let documentId = null;\n            let retryCount = 0;\n            const maxRetries = 2;\n            \n            while (retryCount < maxRetries) {\n                try {\n                    console.log(`🔍 Fresh lookup attempt ${retryCount + 1} for plan: ${planId}`);\n                    \n                    // Get all documents from Domo API\n                    const response = await domo.get('/domo/datastores/v1/collections/SignalAI.ActionPlans/documents');\n                    const documents = response || [];\n                    \n                    // Find the document containing our action plan\n                    const docToUpdate = documents.find(doc => doc.content && doc.content.id === planId);\n                    \n                    if (!docToUpdate) {\n                        throw new Error(`Action plan document not found in AppDB for plan: ${planId}`);\n                    }\n                    \n                    documentId = docToUpdate.id;\n                    console.log(`🔧 Found Domo document ID: ${documentId} for plan: ${planId}`);\n                    \n                    // Step 4: Update with correct document ID and full plan\n                    const updateResponse = await domo.put(`/domo/datastores/v1/collections/SignalAI.ActionPlans/documents/${documentId}`, {\n                        content: mergedPlan\n                    });\n                    \n                    if (updateResponse) {\n                        console.log(`✅ Action plan updated in Domo API using document ID: ${documentId}`);\n                        return { success: true, data: updateResponse };\n                    }\n                    \n                    break; // Success, exit retry loop\n                    \n                } catch (apiError) {\n                    console.warn(`⚠️ Attempt ${retryCount + 1} failed:`, apiError);\n                    retryCount++;\n                    \n                    if (retryCount >= maxRetries) {\n                        console.error(`❌ All ${maxRetries} attempts failed for plan: ${planId}`);\n                        throw apiError;\n                    }\n                    \n                    // Wait before retry\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n                }\n            }\n            \n            // Fallback: Update in local storage\n            const storageKey = 'signalai_action_plans';\n            const existingPlans = JSON.parse(localStorage.getItem(storageKey) || '[]');\n            const planIndex = existingPlans.findIndex(p => p.id === planId);\n            \n            if (planIndex !== -1) {\n                existingPlans[planIndex] = { ...existingPlans[planIndex], ...updates };\n                localStorage.setItem(storageKey, JSON.stringify(existingPlans));\n                console.log('✅ Action plan updated in local storage (fallback)');\n                return { success: true, data: existingPlans[planIndex] };\n            }\n            \n            return { success: false, error: 'Plan not found' };\n            \n        } catch (error) {\n            console.error('❌ Failed to update action plan:', error);\n            return { success: false, error: error.message };\n        }\n    }\n    \n    /**\n     * Delete an action plan\n     */\n    static async deleteActionPlan(planId) {\n        try {\n            console.log('🗑️ Deleting action plan:', planId);\n            \n            // 🔧 FIX: Use fresh lookup approach to find correct Domo document ID\n            let retryCount = 0;\n            const maxRetries = 2;\n            \n            while (retryCount < maxRetries) {\n                try {\n                    console.log(`🔍 Fresh lookup attempt ${retryCount + 1} for deletion of plan: ${planId}`);\n                    \n                    // Get all documents from Domo API\n                    const response = await domo.get('/domo/datastores/v1/collections/SignalAI.ActionPlans/documents');\n                    const documents = response || [];\n                    \n                    // Find the document containing our action plan\n                    const docToDelete = documents.find(doc => doc.content && doc.content.id === planId);\n                    \n                    if (!docToDelete) {\n                        throw new Error(`Action plan document not found in AppDB for plan: ${planId}`);\n                    }\n                    \n                    const documentId = docToDelete.id;\n                    console.log(`🔧 Found Domo document ID for deletion: ${documentId} for plan: ${planId}`);\n                    \n                    // Delete using correct document ID\n                    await domo.delete(`/domo/datastores/v1/collections/SignalAI.ActionPlans/documents/${documentId}`);\n                    console.log(`✅ Action plan deleted from Domo API using document ID: ${documentId}`);\n                    return { success: true };\n                    \n                } catch (apiError) {\n                    console.warn(`⚠️ Delete attempt ${retryCount + 1} failed:`, apiError);\n                    retryCount++;\n                    \n                    if (retryCount >= maxRetries) {\n                        console.error(`❌ All ${maxRetries} delete attempts failed for plan: ${planId}`);\n                        break; // Fall through to local storage fallback\n                    }\n                    \n                    // Wait before retry\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n                }\n            }\n            \n            // Fallback: Delete from local storage\n            const storageKey = 'signalai_action_plans';\n            const existingPlans = JSON.parse(localStorage.getItem(storageKey) || '[]');\n            const filteredPlans = existingPlans.filter(p => p.id !== planId);\n            \n            if (filteredPlans.length < existingPlans.length) {\n                localStorage.setItem(storageKey, JSON.stringify(filteredPlans));\n                console.log('✅ Action plan deleted from local storage (fallback)');\n                return { success: true };\n            }\n            \n            return { success: false, error: 'Plan not found' };\n            \n        } catch (error) {\n            console.error('❌ Failed to delete action plan:', error);\n            return { success: false, error: error.message };\n        }\n    }\n    \n    // ========== PLAY-LEVEL CRUD OPERATIONS ==========\n    \n    /**\n     * Update a specific property of a play within an action plan\n     */\n    static async updatePlayProperty(planId, playId, property, value) {\n        try {\n            console.log(`🎯 Updating play ${playId} property ${property}:`, value);\n            \n            // Get the current action plan\n            let existingPlan = null;\n            if (window.signalsStore) {\n                const state = window.signalsStore.getState();\n                if (state.actionPlans && state.actionPlans.has(planId)) {\n                    existingPlan = state.actionPlans.get(planId);\n                }\n            }\n            \n            if (!existingPlan) {\n                throw new Error(`Plan ${planId} not found in store`);\n            }\n            \n            // Find and update the specific play\n            const updatedPlays = existingPlan.plays.map(play => {\n                if (play.id === playId) {\n                    return {\n                        ...play,\n                        [property]: value,\n                        updatedAt: new Date().toISOString()\n                    };\n                }\n                return play;\n            });\n            \n            // Update the entire action plan with the modified plays\n            const updates = {\n                plays: updatedPlays,\n                updatedAt: new Date().toISOString()\n            };\n            \n            return await this.updateActionPlan(planId, updates);\n            \n        } catch (error) {\n            console.error('❌ Failed to update play property:', error);\n            return { success: false, error: error.message };\n        }\n    }\n    \n    /**\n     * Update the status of a specific play\n     */\n    static async updatePlayStatus(planId, playId, status) {\n        return await this.updatePlayProperty(planId, playId, 'status', status);\n    }\n    \n    /**\n     * Update the priority of a specific play\n     */\n    static async updatePlayPriority(planId, playId, priority) {\n        return await this.updatePlayProperty(planId, playId, 'priority', priority);\n    }\n    \n    /**\n     * Update the due date of a specific play\n     */\n    static async updatePlayDueDate(planId, playId, dueDate) {\n        return await this.updatePlayProperty(planId, playId, 'dueDate', dueDate);\n    }\n    \n    /**\n     * Get enhanced play analytics for an action plan\n     */\n    static getPlayAnalytics(planId) {\n        try {\n            let existingPlan = null;\n            if (window.signalsStore) {\n                const state = window.signalsStore.getState();\n                if (state.actionPlans && state.actionPlans.has(planId)) {\n                    existingPlan = state.actionPlans.get(planId);\n                }\n            }\n            \n            if (!existingPlan || !existingPlan.plays) {\n                return { total: 0, completed: 0, inProgress: 0, pending: 0, cancelled: 0, onHold: 0 };\n            }\n            \n            const analytics = existingPlan.plays.reduce((acc, play) => {\n                acc.total++;\n                switch (play.status) {\n                    case 'complete':\n                        acc.completed++;\n                        break;\n                    case 'in-progress':\n                        acc.inProgress++;\n                        break;\n                    case 'pending':\n                        acc.pending++;\n                        break;\n                    case 'cancelled':\n                        acc.cancelled++;\n                        break;\n                    case 'on-hold':\n                        acc.onHold++;\n                        break;\n                }\n                return acc;\n            }, { total: 0, completed: 0, inProgress: 0, pending: 0, cancelled: 0, onHold: 0 });\n            \n            analytics.completionPercentage = analytics.total > 0 ? Math.round((analytics.completed / analytics.total) * 100) : 0;\n            \n            return analytics;\n            \n        } catch (error) {\n            console.error('❌ Failed to get play analytics:', error);\n            return { total: 0, completed: 0, inProgress: 0, pending: 0, cancelled: 0, onHold: 0, completionPercentage: 0 };\n        }\n    }\n    \n    /**\n     * Save interaction (like/not accurate feedback)\n     */\n    static async saveInteraction(interactionData) {\n        try {\n            console.log('💾 Saving interaction:', interactionData);\n            \n            // Try to save to Domo API\n            try {\n                const response = await domo.post('/domo/datastores/v1/collections/SignalAI.Interactions/documents', {\n                    content: interactionData\n                });\n                \n                if (response && response.id) {\n                    console.log('✅ Interaction saved to Domo API');\n                    return { success: true, data: { ...interactionData, recordId: response.id } };\n                }\n            } catch (apiError) {\n                console.warn('⚠️ Failed to save to Domo API, using local storage:', apiError);\n            }\n            \n            // Fallback: Store locally\n            const storageKey = 'signalai_interactions';\n            const existingInteractions = JSON.parse(localStorage.getItem(storageKey) || '[]');\n            existingInteractions.push(interactionData);\n            localStorage.setItem(storageKey, JSON.stringify(existingInteractions));\n            \n            console.log('✅ Interaction saved to local storage (fallback)');\n            return { success: true, data: interactionData };\n            \n        } catch (error) {\n            console.error('❌ Failed to save interaction:', error);\n            return { success: false, error: error.message };\n        }\n    }\n    \n    /**\n     * Save feedback interaction (alias for saveInteraction used by FeedbackService)\n     */\n    static async saveFeedbackInteraction(signalId, interactionType, userId) {\n        const interactionData = {\n            id: `interaction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: signalId,\n            interactionType: interactionType,\n            userId: userId || 'user-1',\n            timestamp: new Date().toISOString(),\n            createdAt: new Date().toISOString()\n        };\n        \n        return this.saveInteraction(interactionData);\n    }\n    \n    /**\n     * Save comment\n     */\n    static async saveComment(commentData) {\n        try {\n            console.log('💾 Saving comment:', commentData);\n            \n            // Try to save to Domo API\n            try {\n                const response = await domo.post('/domo/datastores/v1/collections/SignalAI.Comments/documents', {\n                    content: commentData\n                });\n                \n                if (response && response.id) {\n                    console.log('✅ Comment saved to Domo API');\n                    return { success: true, data: { ...commentData, recordId: response.id } };\n                }\n            } catch (apiError) {\n                console.warn('⚠️ Failed to save to Domo API, using local storage:', apiError);\n            }\n            \n            // Fallback: Store locally\n            const storageKey = 'signalai_comments';\n            const existingComments = JSON.parse(localStorage.getItem(storageKey) || '[]');\n            existingComments.push(commentData);\n            localStorage.setItem(storageKey, JSON.stringify(existingComments));\n            \n            console.log('✅ Comment saved to local storage (fallback)');\n            return { success: true, data: commentData };\n            \n        } catch (error) {\n            console.error('❌ Failed to save comment:', error);\n            return { success: false, error: error.message };\n        }\n    }\n}\n\n// Make it globally available\nwindow.SignalsRepository = SignalsRepository;","size_bytes":57444},"js/flux/services/ActionPlansService.js":{"content":"// ActionPlansService - Handles action plans through Flux actions\nclass ActionPlansService {\n    \n    /**\n     * Get global dispatcher safely with robust error handling\n     */\n    static getDispatcher() {\n        if (typeof window.dispatcher !== 'undefined' && window.dispatcher) {\n            return window.dispatcher;\n        }\n        console.warn('⚠️ Dispatcher not available - Flux architecture may not be initialized');\n        return null;\n    }\n    \n    /**\n     * Get global signals store safely with robust error handling\n     */\n    static getSignalsStore() {\n        if (typeof window.signalsStore !== 'undefined' && window.signalsStore) {\n            return window.signalsStore;\n        }\n        console.warn('⚠️ SignalsStore not available - Flux architecture may not be initialized');\n        return null;\n    }\n    \n    /**\n     * Store action plan locally as fallback\n     */\n    static storeActionPlanLocally(plan) {\n        try {\n            const existingPlans = this.getLocalActionPlans();\n            existingPlans[plan.id] = plan;\n            localStorage.setItem('signalsai_action_plans', JSON.stringify(existingPlans));\n            console.log('✅ Action plan stored locally:', plan.id);\n        } catch (error) {\n            console.warn('Could not store action plan locally:', error);\n        }\n    }\n    \n    /**\n     * Get locally stored action plans\n     */\n    static getLocalActionPlans() {\n        try {\n            const stored = localStorage.getItem('signalsai_action_plans');\n            return stored ? JSON.parse(stored) : {};\n        } catch (error) {\n            console.warn('Could not load local action plans:', error);\n            return {};\n        }\n    }\n    \n    /**\n     * Clear timestamp for failed action plan creation with robust accountId handling\n     */\n    static clearPlanCreationTimestamp(accountId) {\n        if (!accountId) {\n            console.warn('⚠️ Cannot clear plan timestamp: accountId is null or undefined');\n            return;\n        }\n        \n        try {\n            const planTimestamps = JSON.parse(localStorage.getItem('signalsai_plan_timestamps') || '{}');\n            if (planTimestamps[accountId]) {\n                delete planTimestamps[accountId];\n                localStorage.setItem('signalsai_plan_timestamps', JSON.stringify(planTimestamps));\n                console.log(`🧹 Cleared plan timestamp for account ${accountId}`);\n            } else {\n                console.log(`ℹ️ No timestamp to clear for account ${accountId}`);\n            }\n        } catch (error) {\n            console.warn('Could not clear plan timestamp:', error);\n        }\n    }\n    \n    /**\n     * Create a new action plan with optimistic updates\n     * @param {string} actionId - Action ID (recommended action ID)\n     * @param {string} accountId - Account ID (required for direct association)\n     * @param {string} title - Plan title\n     * @param {string} description - Plan description\n     * @param {Array} plays - Array of plays (strings or objects)\n     * @param {number} userId - User ID (numeric)\n     * @param {string} userName - User name\n     * @param {string} planTitle - Plan title with date\n     * @param {string} dueDate - Due date in YYYY-MM-DD format\n     * @param {string} priority - Priority (High, Medium, Low)\n     * @param {string} signalPolarity - Signal polarity (Enrichment, Risk, Opportunities)\n     */\n    static async createActionPlan(actionId, accountId, title, description, plays = [], userId = null, userName = null, planTitle = null, dueDate = null, priority = 'Medium', signalPolarity = 'Enrichment') {\n        const dispatcher = this.getDispatcher();\n        const signalsStore = this.getSignalsStore();\n        \n        // Guard against missing dependencies\n        if (!dispatcher) {\n            console.error('❌ Cannot create action plan: Dispatcher not available');\n            return null;\n        }\n        \n        if (!signalsStore) {\n            console.error('❌ Cannot create action plan: SignalsStore not available');\n            return null;\n        }\n        \n        // Validate required parameters\n        if (!accountId) {\n            console.error('❌ Cannot create action plan: accountId is required');\n            dispatcher.dispatch(Actions.showMessage('Account ID is required for action plan creation', 'error'));\n            return null;\n        }\n        \n        // Get current user if not provided\n        if (!userId) {\n            const userInfo = signalsStore.getState().userInfo;\n            userId = parseInt(userInfo?.userId) || 621623466; // Ensure numeric ID\n            userName = userName || userInfo?.userName || 'Current User';\n        }\n    \n        if (!title || title.trim().length === 0) {\n            dispatcher.dispatch(Actions.showMessage('Action plan title cannot be empty', 'error'));\n            return null;\n        }\n    \n        console.log(`🎯 ActionPlansService: Creating action plan for action ${actionId}`);\n        \n        // Dispatch optimistic request action\n        const requestAction = Actions.requestActionPlan(actionId, title.trim(), description?.trim() || '', plays, userId);\n        dispatcher.dispatch(requestAction);\n        \n        const operationId = requestAction.payload.operationId; // Store in broader scope for catch block\n        \n        try {\n            // Create plan object matching exact database model\n            const now = new Date();\n            const planData = {\n                id: `plan-${Date.now()}`, // Format: plan-timestamp\n                actionId,  // Recommended action ID\n                accountId, // Account ID\n                title: title.trim(),\n                description: description?.trim() || '',\n                plays: plays || [], // Changed from tasks to plays\n                status: 'pending', // Initial status\n                priority: priority || 'Medium', // Capitalized priority\n                dueDate: dueDate || now.toISOString().split('T')[0], // YYYY-MM-DD format\n                assignee: userId, // Numeric user ID\n                createdDate: now.toISOString(),\n                createdAt: now.toISOString(),\n                updatedAt: now.toISOString(),\n                planTitle: planTitle || `Action Plan - ${now.toLocaleDateString('en-US')}`,\n                createdBy: userName || 'Current User',\n                createdByUserId: userId,\n                signalPolarity: signalPolarity || 'Enrichment' // NEW FIELD\n            };\n            \n            // Make API call in background\n            const result = await SignalsRepository.saveActionPlan(planData);\n            \n            // SignalsRepository always returns success:true for optimistic updates\n            // but we still implement local persistence as fallback\n            if (result && result.success) {\n                // Store locally as fallback persistence\n                this.storeActionPlanLocally(result.data || planData);\n                \n                // Dispatch success action with real plan data\n                dispatcher.dispatch(Actions.actionPlanSucceeded(result.data || planData, operationId));\n                \n                // Show success message\n                dispatcher.dispatch(Actions.showMessage('Action plan created successfully', 'success'));\n                \n                console.log('✅ Action plan created successfully:', result.data || planData);\n                return result.data || planData;\n                \n            } else {\n                // Clear any optimistic timestamps from UI with robust handling\n                this.clearPlanCreationTimestamp(accountId); // Now handles undefined accountId gracefully\n                \n                // Dispatch failure action\n                dispatcher.dispatch(Actions.actionPlanFailed(operationId, result?.error || 'Unknown error'));\n                \n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to save action plan - changes reverted', 'error'));\n                \n                console.error('❌ Action plan creation failed:', result?.error);\n                return null;\n            }\n            \n        } catch (error) {\n            console.error('❌ ActionPlansService: Critical error in action plan creation:', error);\n            \n            try {\n                const dispatcher = this.getDispatcher();\n                \n                // Clear any optimistic timestamps from UI using directly passed accountId\n                this.clearPlanCreationTimestamp(accountId); // Use directly passed accountId instead of fragile inference\n                \n                // Use the preserved operationId from the original request action for proper rollback correlation\n                dispatcher.dispatch(Actions.actionPlanFailed(operationId, error.message));\n                \n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to save action plan - changes reverted', 'error'));\n                \n            } catch (cleanupError) {\n                console.error('❌ Additional error during cleanup:', cleanupError);\n            }\n            \n            return null;\n        }\n    }\n    \n    /**\n     * Update an existing action plan with optimistic updates\n     * @param {string} planId - Plan ID\n     * @param {Object} updates - Plan updates\n     */\n    static async updateActionPlan(planId, updates) {\n        console.log(`🎯 ActionPlansService: Updating action plan ${planId}`);\n        \n        try {\n            const dispatcher = this.getDispatcher();\n            \n            // OPTIMISTIC UPDATE: Immediately update local data and UI\n            const existingPlans = this.getLocalActionPlans();\n            const updatedPlan = existingPlans[planId] ? \n                { ...existingPlans[planId], ...updates, updatedAt: new Date().toISOString() } : \n                { id: planId, ...updates, updatedAt: new Date().toISOString() };\n            \n            // Store optimistic update locally\n            this.storeActionPlanLocally(updatedPlan);\n            \n            // Dispatch optimistic update action immediately\n            dispatcher.dispatch(Actions.updateActionPlan(planId, updates));\n            \n            console.log(`✅ Optimistic update applied for plan ${planId}`);\n            \n            // Make API call in background\n            const result = await SignalsRepository.updateActionPlan(planId, updates);\n            \n            if (result && result.success) {\n                console.log(`✅ Server update successful for plan ${planId}`);\n                // Server update successful - show success message\n                dispatcher.dispatch(Actions.showMessage('Action plan updated successfully', 'success'));\n                \n                return { success: true, data: updatedPlan, plan: updatedPlan };\n                \n            } else {\n                console.warn(`⚠️ Server update failed for plan ${planId}, but optimistic update remains`);\n                // Server failed but optimistic update already applied - show warning but don't revert\n                dispatcher.dispatch(Actions.showMessage('Changes saved locally (server sync failed)', 'warning'));\n                \n                return { success: true, data: updatedPlan, plan: updatedPlan };\n            }\n            \n        } catch (error) {\n            console.error('❌ ActionPlansService: Failed to update action plan:', error);\n            \n            // Even if there's an error, the optimistic update was already applied\n            // Don't revert unless it's a critical validation error\n            try {\n                const dispatcher = this.getDispatcher();\n                dispatcher.dispatch(Actions.showMessage('Changes saved locally (sync error)', 'warning'));\n                \n                // Return success since optimistic update worked\n                const existingPlans = this.getLocalActionPlans();\n                const updatedPlan = existingPlans[planId];\n                \n                return { success: true, data: updatedPlan, plan: updatedPlan };\n                \n            } catch (dispatchError) {\n                console.error('❌ Failed to dispatch error message:', dispatchError);\n                return { success: false, error: error.message };\n            }\n        }\n    }\n    \n    /**\n     * Delete an action plan\n     * @param {string} planId - Plan ID\n     */\n    static async deleteActionPlan(planId) {\n        console.log(`🎯 ActionPlansService: Deleting action plan ${planId}`);\n        \n        try {\n            const dispatcher = this.getDispatcher();\n            \n            // Make API call\n            const result = await SignalsRepository.deleteActionPlan(planId);\n            \n            if (result && result.success) {\n                // Remove from local storage\n                const existingPlans = this.getLocalActionPlans();\n                delete existingPlans[planId];\n                localStorage.setItem('signalsai_action_plans', JSON.stringify(existingPlans));\n                \n                // Dispatch delete action\n                dispatcher.dispatch(Actions.deleteActionPlan(planId));\n                \n                // Show success message\n                dispatcher.dispatch(Actions.showMessage('Action plan deleted successfully', 'success'));\n                \n                return true;\n                \n            } else {\n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to delete action plan', 'error'));\n                \n                return false;\n            }\n            \n        } catch (error) {\n            console.error('❌ ActionPlansService: Failed to delete action plan:', error);\n            try {\n                const dispatcher = this.getDispatcher();\n                dispatcher.dispatch(Actions.showMessage('Failed to delete action plan', 'error'));\n            } catch (dispatchError) {\n                console.error('❌ Failed to dispatch error message:', dispatchError);\n            }\n            return false;\n        }\n    }\n    \n    /**\n     * Get action plans for an account\n     * @param {string} accountId - Account ID\n     * @returns {Array} - Array of action plans\n     */\n    static getActionPlansForAccount(accountId) {\n        try {\n            const signalsStore = this.getSignalsStore();\n            const state = signalsStore.getState();\n            return state.actionPlansByAccount.get(accountId) || [];\n        } catch (error) {\n            console.warn('Could not get action plans from store, checking local storage:', error);\n            // Fallback to local storage\n            const localPlans = this.getLocalActionPlans();\n            return Object.values(localPlans).filter(plan => plan.accountId === accountId);\n        }\n    }\n    \n    /**\n     * Get an action plan by ID\n     * @param {string} planId - Plan ID\n     * @returns {Object|null} - Action plan or null\n     */\n    static getActionPlanById(planId) {\n        try {\n            const signalsStore = this.getSignalsStore();\n            const state = signalsStore.getState();\n            return state.actionPlans.get(planId) || null;\n        } catch (error) {\n            console.warn('Could not get action plan from store, checking local storage:', error);\n            // Fallback to local storage\n            const localPlans = this.getLocalActionPlans();\n            return localPlans[planId] || null;\n        }\n    }\n    \n    /**\n     * Add a task to an action plan\n     * @param {string} planId - Plan ID\n     * @param {Object} task - Task object\n     */\n    static async addTaskToPlan(planId, task) {\n        const plan = this.getActionPlanById(planId);\n        if (!plan) {\n            try {\n                const dispatcher = this.getDispatcher();\n                dispatcher.dispatch(Actions.showMessage('Action plan not found', 'error'));\n            } catch (error) {\n                console.error('Could not show error message:', error);\n            }\n            return;\n        }\n        \n        const updatedTasks = [...(plan.tasks || []), task];\n        await this.updateActionPlan(planId, { tasks: updatedTasks });\n    }\n    \n    /**\n     * Remove a task from an action plan\n     * @param {string} planId - Plan ID\n     * @param {number} taskIndex - Task index to remove\n     */\n    static async removeTaskFromPlan(planId, taskIndex) {\n        const plan = this.getActionPlanById(planId);\n        if (!plan) {\n            try {\n                const dispatcher = this.getDispatcher();\n                dispatcher.dispatch(Actions.showMessage('Action plan not found', 'error'));\n            } catch (error) {\n                console.error('Could not show error message:', error);\n            }\n            return;\n        }\n        \n        const updatedTasks = [...(plan.tasks || [])];\n        if (taskIndex >= 0 && taskIndex < updatedTasks.length) {\n            updatedTasks.splice(taskIndex, 1);\n            await this.updateActionPlan(planId, { tasks: updatedTasks });\n        }\n    }\n}\n\n// Make globally available\nwindow.ActionPlansService = ActionPlansService;","size_bytes":17194},"js/flux/services/CommentsService.js":{"content":"// CommentsService - Handles comments through Flux actions\nclass CommentsService {\n    \n    /**\n     * Add a new comment with optimistic updates\n     * @param {string} signalId - Signal ID (optional if accountId provided)\n     * @param {string} accountId - Account ID (optional if signalId provided)\n     * @param {string} text - Comment text\n     * @param {string} userId - User ID (optional)\n     */\n    static async addComment(signalId = null, accountId = null, text, userId = null) {\n        // Get current user if not provided\n        userId = userId || signalsStore.getState().userInfo.userId || 'user-1';\n        \n        if (!text || text.trim().length === 0) {\n            dispatcher.dispatch(Actions.showMessage('Comment cannot be empty', 'error'));\n            return;\n        }\n        \n        console.log(`🎯 CommentsService: Adding comment for ${signalId ? 'signal' : 'account'} ${signalId || accountId}`);\n        \n        // Dispatch optimistic request action\n        const requestAction = Actions.requestComment(signalId, accountId, text.trim(), userId);\n        dispatcher.dispatch(requestAction);\n        \n        const operationId = requestAction.payload.operationId;\n        \n        try {\n            // Create comment object for API\n            const commentData = {\n                signalId,\n                accountId,\n                text: text.trim(),\n                userId,\n                timestamp: new Date().toISOString()\n            };\n            \n            // Make API call in background\n            const result = await SignalsRepository.saveComment(commentData);\n            \n            if (result.success) {\n                // Dispatch success action with real comment data\n                dispatcher.dispatch(Actions.commentSucceeded(result.data, operationId));\n                \n                // Show success message\n                dispatcher.dispatch(Actions.showMessage('Comment added successfully', 'success'));\n                \n            } else {\n                // Dispatch failure action\n                dispatcher.dispatch(Actions.commentFailed(operationId, result.error));\n                \n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to save comment - changes reverted', 'error'));\n            }\n            \n        } catch (error) {\n            console.error('❌ CommentsService: Critical error in comment handling:', error);\n            \n            // Dispatch failure action\n            dispatcher.dispatch(Actions.commentFailed(operationId, error.message));\n            \n            // Show error message\n            dispatcher.dispatch(Actions.showMessage('Failed to save comment - changes reverted', 'error'));\n        }\n    }\n    \n    /**\n     * Update an existing comment\n     * @param {string} commentId - Comment ID\n     * @param {string} newText - New comment text\n     */\n    static async updateComment(commentId, newText) {\n        if (!newText || newText.trim().length === 0) {\n            dispatcher.dispatch(Actions.showMessage('Comment cannot be empty', 'error'));\n            return;\n        }\n        \n        console.log(`🎯 CommentsService: Updating comment ${commentId}`);\n        \n        try {\n            // Make API call\n            const result = await SignalsRepository.updateComment(commentId, { text: newText.trim() });\n            \n            if (result.success) {\n                // Dispatch update action\n                dispatcher.dispatch(Actions.updateComment(commentId, newText.trim()));\n                \n                // Show success message\n                dispatcher.dispatch(Actions.showMessage('Comment updated successfully', 'success'));\n                \n            } else {\n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to update comment', 'error'));\n            }\n            \n        } catch (error) {\n            console.error('❌ CommentsService: Failed to update comment:', error);\n            dispatcher.dispatch(Actions.showMessage('Failed to update comment', 'error'));\n        }\n    }\n    \n    /**\n     * Delete a comment\n     * @param {string} commentId - Comment ID\n     */\n    static async deleteComment(commentId) {\n        console.log(`🎯 CommentsService: Deleting comment ${commentId}`);\n        \n        try {\n            // Make API call\n            const result = await SignalsRepository.deleteComment(commentId);\n            \n            if (result.success) {\n                // Dispatch delete action\n                dispatcher.dispatch(Actions.deleteComment(commentId));\n                \n                // Show success message\n                dispatcher.dispatch(Actions.showMessage('Comment deleted successfully', 'success'));\n                \n            } else {\n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to delete comment', 'error'));\n            }\n            \n        } catch (error) {\n            console.error('❌ CommentsService: Failed to delete comment:', error);\n            dispatcher.dispatch(Actions.showMessage('Failed to delete comment', 'error'));\n        }\n    }\n    \n    /**\n     * Get comments for a signal\n     * @param {string} signalId - Signal ID\n     * @returns {Array} - Array of comments\n     */\n    static getCommentsForSignal(signalId) {\n        const state = signalsStore.getState();\n        return state.comments.get(signalId) || [];\n    }\n    \n    /**\n     * Get comments for an account\n     * @param {string} accountId - Account ID\n     * @returns {Array} - Array of comments\n     */\n    static getCommentsForAccount(accountId) {\n        const state = signalsStore.getState();\n        return state.comments.get(accountId) || [];\n    }\n    \n    /**\n     * Legacy wrapper for adding comment\n     * @param {string} signalId - Signal ID\n     * @param {Object} app - Legacy app reference (ignored)\n     */\n    static async addCommentLegacy(signalId, app) {\n        // Get comment text from either inline or modal input\n        const commentText = document.getElementById(`inlineCommentText-${signalId}`)?.value ||\n                          document.getElementById('newCommentText')?.value;\n        \n        if (!commentText || !commentText.trim()) {\n            dispatcher.dispatch(Actions.showMessage('Please enter a comment', 'error'));\n            return;\n        }\n        \n        // Add the comment using the new method\n        await this.addComment(signalId, null, commentText.trim());\n        \n        // Clear input fields\n        if (document.getElementById(`inlineCommentText-${signalId}`)) {\n            document.getElementById(`inlineCommentText-${signalId}`).value = '';\n        }\n        if (document.getElementById('newCommentText')) {\n            document.getElementById('newCommentText').value = '';\n        }\n    }\n    \n    /**\n     * Save comment to API (for backward compatibility)\n     * @param {Object} comment - Comment object\n     */\n    static async saveComment(comment) {\n        return SignalsRepository.saveComment(comment);\n    }\n    \n    /**\n     * Edit comment wrapper\n     * @param {string} commentId - Comment ID\n     * @param {string} signalId - Signal ID\n     */\n    static editComment(commentId, signalId) {\n        const comment = this.getCommentsForSignal(signalId).find(c => c.id === commentId);\n        if (comment) {\n            // Set up edit mode in UI\n            const commentEl = document.getElementById(`comment-${commentId}`);\n            if (commentEl) {\n                const currentText = comment.text;\n                commentEl.innerHTML = `\n                    <textarea id=\"edit-comment-${commentId}\" class=\"edit-comment-textarea\">${currentText}</textarea>\n                    <div class=\"edit-comment-actions\">\n                        <button onclick=\"CommentsService.saveEditedComment('${commentId}', '${signalId}')\" class=\"btn btn-sm btn-primary\">Save</button>\n                        <button onclick=\"CommentsService.cancelEditComment('${commentId}', '${signalId}', '${currentText.replace(/'/g, \"\\\\'\").replace(/\"/g, '&quot;')}')\" class=\"btn btn-sm btn-secondary\">Cancel</button>\n                    </div>\n                `;\n            }\n        }\n    }\n    \n    /**\n     * Save edited comment\n     * @param {string} commentId - Comment ID\n     * @param {string} signalId - Signal ID\n     */\n    static async saveEditedComment(commentId, signalId) {\n        const textarea = document.getElementById(`edit-comment-${commentId}`);\n        if (textarea) {\n            const newText = textarea.value;\n            await this.updateComment(commentId, newText);\n        }\n    }\n    \n    /**\n     * Cancel comment edit\n     * @param {string} commentId - Comment ID\n     * @param {string} signalId - Signal ID\n     * @param {string} originalText - Original comment text\n     */\n    static cancelEditComment(commentId, signalId, originalText) {\n        const commentEl = document.getElementById(`comment-${commentId}`);\n        if (commentEl) {\n            commentEl.innerHTML = originalText;\n        }\n    }\n    \n    /**\n     * Render comments for signal (HTML generation)\n     * @param {string} signalId - Signal ID\n     * @param {Object} app - Legacy app reference (ignored)\n     */\n    static renderCommentsForSignal(signalId, app) {\n        const comments = this.getCommentsForSignal(signalId);\n        if (comments.length === 0) {\n            return '<p class=\"no-comments\">No comments yet</p>';\n        }\n        \n        return comments.map(comment => `\n            <div class=\"comment\" id=\"comment-container-${comment.id}\">\n                <div class=\"comment-header\">\n                    <span class=\"comment-author\">${comment.author || comment.authorId || 'User'}</span>\n                    <span class=\"comment-time\">${this.formatCommentTime(comment.timestamp)}</span>\n                </div>\n                <div class=\"comment-body\" id=\"comment-${comment.id}\">\n                    ${comment.text}\n                </div>\n                <div class=\"comment-actions\">\n                    <button onclick=\"CommentsService.editComment('${comment.id}', '${signalId}')\" class=\"btn btn-link btn-sm\">Edit</button>\n                    <button onclick=\"CommentsService.deleteComment('${comment.id}')\" class=\"btn btn-link btn-sm text-danger\">Delete</button>\n                </div>\n            </div>\n        `).join('');\n    }\n    \n    /**\n     * Format comment timestamp\n     * @param {string} timestamp - ISO timestamp\n     */\n    static formatCommentTime(timestamp) {\n        const now = new Date();\n        const commentTime = new Date(timestamp);\n        const diffSeconds = Math.floor((now - commentTime) / 1000);\n\n        if (diffSeconds < 60) {\n            return 'Just now';\n        } else if (diffSeconds < 3600) {\n            const diffMinutes = Math.floor(diffSeconds / 60);\n            return `${diffMinutes}m ago`;\n        } else if (diffSeconds < 86400) {\n            const diffHours = Math.floor(diffSeconds / 3600);\n            return `${diffHours}h ago`;\n        } else {\n            return commentTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n        }\n    }\n}\n\n// Make globally available\nwindow.CommentsService = CommentsService;\n\n// Create alias for backward compatibility\nwindow.CommentService = CommentsService;","size_bytes":11350},"js/flux/services/FeedbackService.js":{"content":"// FeedbackService - Handles user feedback through Flux actions\nclass FeedbackService {\n    \n    /**\n     * Handle user feedback (like/not-accurate) with optimistic updates\n     * @param {string} signalId - Signal ID\n     * @param {string} feedbackType - Type of feedback ('like', 'not-accurate')\n     * @param {string} userId - User ID (optional, defaults to current user)\n     */\n    static async handleFeedback(signalId, feedbackType, userId = null) {\n        // Get current user if not provided\n        userId = userId || signalsStore.getState().userInfo.userId || 'user-1';\n        \n        console.log(`🎯 FeedbackService: Handling ${feedbackType} for signal ${signalId}`);\n        \n        // Dispatch optimistic request action\n        const requestAction = Actions.requestFeedback(signalId, feedbackType, userId);\n        dispatcher.dispatch(requestAction);\n        \n        const operationId = requestAction.payload.operationId;\n        \n        try {\n            // Make API call in background\n            const result = await SignalsRepository.saveFeedbackInteraction(signalId, feedbackType, userId);\n            \n            if (result.success) {\n                // Dispatch success action\n                dispatcher.dispatch(Actions.feedbackSucceeded(signalId, feedbackType, operationId));\n                \n                // Show success message\n                dispatcher.dispatch(Actions.showMessage(`Signal marked as ${feedbackType}`, 'success'));\n                \n            } else {\n                // Dispatch failure action\n                dispatcher.dispatch(Actions.feedbackFailed(signalId, feedbackType, operationId, result.error));\n                \n                // Show error message\n                dispatcher.dispatch(Actions.showMessage('Failed to save feedback - changes reverted', 'error'));\n            }\n            \n        } catch (error) {\n            console.error('❌ FeedbackService: Critical error in feedback handling:', error);\n            \n            // Dispatch failure action\n            dispatcher.dispatch(Actions.feedbackFailed(signalId, feedbackType, operationId, error.message));\n            \n            // Show error message\n            dispatcher.dispatch(Actions.showMessage('Failed to save feedback - changes reverted', 'error'));\n        }\n    }\n    \n    /**\n     * Remove user feedback for a signal\n     * @param {string} signalId - Signal ID\n     * @param {string} userId - User ID (optional)\n     */\n    static async removeFeedback(signalId, userId = null) {\n        userId = userId || signalsStore.getState().userInfo.userId || 'user-1';\n        \n        console.log(`🎯 FeedbackService: Removing feedback for signal ${signalId}`);\n        \n        // Dispatch remove feedback action\n        dispatcher.dispatch(Actions.removeFeedback(signalId, userId));\n        \n        // Show success message\n        dispatcher.dispatch(Actions.showMessage('Feedback removed', 'info'));\n    }\n    \n    /**\n     * Get current user feedback for a signal\n     * @param {string} signalId - Signal ID\n     * @param {string} userId - User ID (optional)\n     * @returns {string|null} - Feedback type or null\n     */\n    static getUserFeedback(signalId, userId = null) {\n        const state = signalsStore.getState();\n        userId = userId || state.userInfo.userId || 'user-1';\n        \n        const interactions = state.interactions.get(signalId) || [];\n        const userInteraction = interactions.find(i => \n            i.userId === userId && (i.interactionType === 'like' || i.interactionType === 'not-accurate')\n        );\n        \n        return userInteraction ? userInteraction.interactionType : null;\n    }\n    \n    /**\n     * Get signal feedback counts\n     * @param {string} signalId - Signal ID\n     * @returns {Object} - Object with likes and notAccurate counts\n     */\n    static getSignalCounts(signalId) {\n        const state = signalsStore.getState();\n        const interactions = state.interactions.get(signalId) || [];\n        \n        const likes = interactions.filter(i => i.interactionType === 'like' || i.type === 'like').length;\n        const notAccurate = interactions.filter(i => i.interactionType === 'not-accurate' || i.type === 'not-accurate').length;\n        \n        return { likes, notAccurate };\n    }\n    \n    /**\n     * Mark signal as viewed (for tracking)\n     * @param {string} signalId - Signal ID\n     * @param {Object} app - Legacy app reference (ignored in Flux)\n     */\n    static async markSignalAsViewed(signalId, app) {\n        const userId = signalsStore.getState().userInfo.userId || 'user-1';\n        \n        console.log(`👁️ FeedbackService: Marking signal ${signalId} as viewed`);\n        \n        // Dispatch viewed action\n        dispatcher.dispatch(Actions.viewSignal(signalId));\n        \n        try {\n            // Save to API in background\n            await SignalsRepository.saveFeedbackInteraction(signalId, 'viewed', userId);\n        } catch (error) {\n            console.error('Failed to save viewed status:', error);\n            // Don't revert for view tracking - it's not critical\n        }\n    }\n    \n    /**\n     * Acknowledge signal (wrapper for compatibility with old code)\n     * @param {string} signalId - Signal ID\n     * @param {string} feedbackType - Type of feedback\n     * @param {Object} app - Legacy app reference (ignored)\n     */\n    static async acknowledgeSignal(signalId, feedbackType, app) {\n        return this.handleFeedback(signalId, feedbackType);\n    }\n    \n    /**\n     * Save interaction to API\n     * @param {string} signalId - Signal ID\n     * @param {string} interactionType - Type of interaction\n     */\n    static async saveInteraction(signalId, interactionType) {\n        const userId = signalsStore.getState().userInfo.userId || 'user-1';\n        return SignalsRepository.saveFeedbackInteraction(signalId, interactionType, userId);\n    }\n    \n    /**\n     * Update signal display counts in UI\n     * @param {string} signalId - Signal ID\n     * @param {Object} app - Legacy app reference (ignored)\n     */\n    static updateSignalDisplayCounts(signalId, app) {\n        // This is now handled automatically through store change events\n        // Trigger a UI update through the store\n        signalsStore.emitChange('feedback:counts_updated', signalId);\n    }\n}\n\n// Make globally available\nwindow.FeedbackService = FeedbackService;\n\n// Create aliases for backward compatibility with old code\nwindow.SignalFeedbackService = FeedbackService;","size_bytes":6489},"js/utils/FormatUtils.js":{"content":"// Shared formatting utilities for views\nclass FormatUtils {\n    \n    static formatDate(dateString) {\n        if (!dateString) return 'No date';\n        \n        const date = new Date(dateString);\n        if (isNaN(date.getTime())) return 'Invalid date';\n        \n        const now = new Date();\n        const diffMs = now - date;\n        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n        \n        if (diffDays === 0) {\n            return 'Today';\n        } else if (diffDays === 1) {\n            return 'Yesterday';\n        } else if (diffDays < 7) {\n            return `${diffDays} days ago`;\n        } else {\n            return date.toLocaleDateString('en-US', { \n                year: 'numeric', \n                month: 'short', \n                day: 'numeric' \n            });\n        }\n    }\n    \n    static formatDateSimple(dateString) {\n        if (!dateString) return 'No date';\n        \n        const date = new Date(dateString);\n        if (isNaN(date.getTime())) return 'Invalid date';\n        \n        return date.toLocaleDateString('en-US', { \n            month: 'short', \n            day: 'numeric',\n            year: '2-digit'\n        });\n    }\n    \n    static formatCommentTime(timestamp) {\n        if (!timestamp) return 'Unknown time';\n        \n        const date = new Date(timestamp);\n        if (isNaN(date.getTime())) return 'Invalid time';\n        \n        const now = new Date();\n        const diffMs = now - date;\n        const diffMinutes = Math.floor(diffMs / (1000 * 60));\n        const diffHours = Math.floor(diffMinutes / 60);\n        const diffDays = Math.floor(diffHours / 24);\n        \n        if (diffMinutes < 1) {\n            return 'Just now';\n        } else if (diffMinutes < 60) {\n            return `${diffMinutes}m ago`;\n        } else if (diffHours < 24) {\n            return `${diffHours}h ago`;\n        } else if (diffDays < 7) {\n            return `${diffDays}d ago`;\n        } else {\n            return date.toLocaleDateString('en-US', { \n                month: 'short', \n                day: 'numeric' \n            });\n        }\n    }\n    \n    static formatCurrency(amount) {\n        if (typeof amount !== 'number') return '$0';\n        \n        if (amount >= 1000000) {\n            return `$${(amount / 1000000).toFixed(1)}M`;\n        } else if (amount >= 1000) {\n            return `$${(amount / 1000).toFixed(1)}K`;\n        } else {\n            return `$${amount.toLocaleString('en-US')}`;\n        }\n    }\n    \n    static formatCurrencyDetailed(amount) {\n        if (typeof amount !== 'number') return '$0';\n        \n        if (amount >= 1000000) {\n            return `$${(amount / 1000000).toFixed(1)}M`;\n        } else if (amount >= 1000) {\n            return `$${(amount / 1000).toFixed(1)}K`;\n        } else {\n            return `$${amount.toFixed(0)}`;\n        }\n    }\n    \n    static getInitials(name) {\n        if (!name || typeof name !== 'string') return 'U';\n        \n        return name\n            .split(' ')\n            .map(part => part.charAt(0).toUpperCase())\n            .slice(0, 2)\n            .join('');\n    }\n    \n    static truncateText(text, maxLength) {\n        if (!text || text.length <= maxLength) return text;\n        return text.substring(0, maxLength).trim() + '...';\n    }\n    \n    static formatTenure(years) {\n        if (years < 1) {\n            const months = Math.round(years * 12);\n            return `${months}m`;\n        } else {\n            return `${years.toFixed(1)}y`;\n        }\n    }\n    \n    static formatForecastWithDelta(delta) {\n        const deltaFormatted = this.formatCurrencyDetailed(Math.abs(delta));\n        const sign = delta >= 0 ? '+' : '-';\n        const color = delta >= 0 ? 'positive' : 'negative';\n        \n        return `<span class=\"delta ${color}\">${sign}${deltaFormatted}</span>`;\n    }\n    \n    static formatRationaleText(text) {\n        if (!text) return '';\n        \n        // Check if text contains comma-separated items that would benefit from bullet formatting\n        if (text.includes(',') && text.length > 200) {\n            // Split on periods to identify sentences\n            const sentences = text.split(/\\.\\s+/).map(s => s.trim()).filter(s => s.length > 0);\n\n            // If we have multiple sentences, format as bullet points\n            if (sentences.length > 2) {\n                const formattedSentences = sentences.map(sentence => {\n                    // Add period back if not already there\n                    const finalSentence = sentence.endsWith('.') ? sentence : sentence + '.';\n                    return `• ${finalSentence}`;\n                }).join('<br>');\n\n                return formattedSentences;\n            }\n        }\n\n        // For shorter text or single sentences, return as-is\n        return text;\n    }\n\n    /**\n     * Normalize polarity text to canonical keys for logic and CSS\n     * @param {string} polarity - The polarity value (can be ANY case)\n     * @returns {string} - Canonical key ('risk', 'opportunities', 'enrichment')\n     */\n    static normalizePolarityKey(polarity) {\n        if (!polarity || typeof polarity !== 'string') {\n            return 'enrichment';\n        }\n        \n        const normalized = polarity.toLowerCase().trim();\n        \n        // Map to canonical keys for consistent logic and CSS\n        const polarityMap = {\n            'risk': 'risk',\n            'risks': 'risk',\n            'opportunity': 'opportunities', \n            'opportunities': 'opportunities',\n            'enrichment': 'enrichment'\n        };\n        \n        return polarityMap[normalized] || 'enrichment';\n    }\n\n    /**\n     * Normalize polarity text to proper Title Case\n     * @param {string} polarity - The polarity value (can be ANY case)\n     * @returns {string} - Normalized Title Case polarity\n     */\n    static normalizePolarityLabel(polarity) {\n        if (!polarity || typeof polarity !== 'string') {\n            return 'Enrichment';\n        }\n        \n        const normalized = polarity.toLowerCase().trim();\n        \n        // Map to proper Title Case labels\n        const polarityMap = {\n            'risk': 'Risk',\n            'risks': 'Risk',\n            'opportunity': 'Opportunities', \n            'opportunities': 'Opportunities',\n            'enrichment': 'Enrichment'\n        };\n        \n        return polarityMap[normalized] || 'Enrichment';\n    }\n}\n\n// Make globally available\nwindow.FormatUtils = FormatUtils;","size_bytes":6430},"js/controllers/AppController.js":{"content":"// AppController - Main application controller for Flux architecture\nclass AppController {\n    constructor() {\n        this.currentTab = 'signal-feed';\n        this.isInitialized = false;\n        this.controllers = new Map();\n        \n        console.log('🚀 Initializing AppController with Flux architecture...');\n    }\n\n    async init() {\n        try {\n            // Subscribe to store changes FIRST so we can respond to loading events\n            this.subscribeToStore();\n            \n            // Initialize Flux store with data\n            console.log('📡 Loading initial data through Flux actions...');\n            dispatcher.dispatch(Actions.dataLoadRequested());\n            \n            // Load all data through SignalsRepository (which uses Flux actions)\n            await SignalsRepository.loadAllData();\n            \n            // Initialize focused controllers\n            this.initializeControllers();\n            \n            // Set up tab navigation and event listeners\n            this.setupTabNavigation();\n            this.setupEventListeners();\n            \n            // Render initial tab\n            this.renderCurrentTab();\n            \n            console.log('✅ AppController initialization complete!');\n            this.isInitialized = true;\n            \n        } catch (error) {\n            console.error('❌ Failed to initialize AppController:', error);\n            this.hideLoading();\n            this.showErrorMessage('Failed to load application. Please refresh the page.');\n        }\n    }\n    \n    initializeControllers() {\n        // Create focused controllers for different app areas\n        this.controllers.set('signals', new SignalsController());\n        this.controllers.set('portfolio', new PortfolioController());\n        this.controllers.set('feedback', new FeedbackController());\n        this.controllers.set('comments', new CommentsController());\n        \n        console.log('🎯 Focused controllers initialized');\n    }\n    \n    setupTabNavigation() {\n        const navTabs = document.querySelectorAll('.nav-tab');\n        navTabs.forEach(tab => {\n            const handleTabSwitch = (e) => {\n                e.preventDefault();\n                // Use closest to ensure we get the tab element even if clicking on child elements\n                const tabElement = e.target.closest('.nav-tab');\n                const tabName = tabElement?.getAttribute('data-tab');\n                if (tabName) {\n                    // Use action dispatch instead of direct method call\n                    dispatcher.dispatch(Actions.switchTab(tabName));\n                }\n            };\n\n            tab.addEventListener('click', handleTabSwitch);\n            tab.addEventListener('touchend', handleTabSwitch, { passive: false });\n        });\n    }\n    \n    handleTabChanged(tabName) {\n        if (this.currentTab === tabName) return;\n        \n        console.log(`🔄 Handling tab change from ${this.currentTab} to ${tabName}`);\n        \n        // Update active tab in UI\n        document.querySelectorAll('.nav-tab').forEach(tab => {\n            tab.classList.remove('active');\n            if (tab.getAttribute('data-tab') === tabName) {\n                tab.classList.add('active');\n            }\n        });\n        \n        // Update content containers\n        document.querySelectorAll('.tab-content').forEach(content => {\n            content.classList.remove('active');\n        });\n        document.getElementById(tabName)?.classList.add('active');\n        \n        this.currentTab = tabName;\n        this.renderCurrentTab();\n    }\n    \n    setupEventListeners() {\n        // Drawer close events\n        const closePlanDrawer = document.getElementById('closePlanDrawer');\n        if (closePlanDrawer) {\n            closePlanDrawer.addEventListener('click', () => {\n                dispatcher.dispatch(Actions.closePlanDrawer());\n            });\n        }\n        \n        const closeSignalDrawer = document.getElementById('closeSignalDrawer');\n        if (closeSignalDrawer) {\n            closeSignalDrawer.addEventListener('click', () => {\n                dispatcher.dispatch(Actions.closeSignalDrawer());\n            });\n        }\n        \n        const createPlan = document.getElementById('createPlan');\n        if (createPlan) {\n            createPlan.addEventListener('click', () => {\n                dispatcher.dispatch(Actions.createActionPlan());\n            });\n        }\n        \n        const cancelPlan = document.getElementById('cancelPlan');\n        if (cancelPlan) {\n            cancelPlan.addEventListener('click', () => {\n                dispatcher.dispatch(Actions.closePlanDrawer());\n            });\n        }\n        \n        // Drawer backdrop and close button handlers\n        document.addEventListener('click', (e) => {\n            if (e.target.classList.contains('drawer-close') || e.target.id === 'closePlanDrawer') {\n                dispatcher.dispatch(Actions.closePlanDrawer());\n            }\n            if (e.target.classList.contains('drawer-close') || e.target.id === 'closeSignalDrawer') {\n                dispatcher.dispatch(Actions.closeSignalDrawer());\n            }\n            if (e.target.id === 'createPlanDrawerBackdrop') {\n                dispatcher.dispatch(Actions.closePlanDrawer());\n            }\n        });\n        \n        // Confidence slider - optional element\n        const confidenceSlider = document.getElementById('signalConfidence');\n        if (confidenceSlider) {\n            confidenceSlider.addEventListener('input', (e) => {\n                const confidenceDisplay = document.querySelector('.confidence-display');\n                if (confidenceDisplay) {\n                    confidenceDisplay.textContent = e.target.value + '%';\n                }\n            });\n        }\n    }\n    \n    subscribeToStore() {\n        console.log('🔌 AppController: Setting up store subscriptions');\n        \n        // Subscribe to store changes for app-level updates\n        signalsStore.subscribe('app-controller', () => {\n            this.updateSummaryStats();\n        });\n        \n        // Subscribe to data loading states\n        signalsStore.subscribe('data:loaded', () => {\n            console.log('📊 AppController received data:loaded event, hiding loading spinner');\n            this.hideLoading();\n            this.updateSummaryStats();\n            this.renderCurrentTab();\n        });\n        \n        signalsStore.subscribe('data:load_failed', () => {\n            console.log('❌ AppController received data:load_failed event, hiding loading spinner');\n            this.hideLoading();\n            this.showErrorMessage('Failed to load data. Please refresh the page.');\n        });\n        \n        signalsStore.subscribe('loading:started', () => {\n            console.log('⏳ AppController received loading:started event, showing spinner');\n            this.showLoading();\n        });\n        \n        // Subscribe to tab changes to update DOM\n        signalsStore.subscribe('tab:changed', (state, tabName) => {\n            this.handleTabChanged(tabName);\n        });\n        \n        // Check if data is already loaded (in case we missed the event)\n        const state = signalsStore.getState();\n        if (!state.loading && state.signals && state.signals.length > 0) {\n            console.log('📊 Data already loaded, hiding spinner immediately');\n            this.hideLoading();\n            this.updateSummaryStats();\n            this.renderCurrentTab();\n        }\n    }\n    \n    // switchTab method removed - now using handleTabChanged via store subscription\n    \n    renderCurrentTab() {\n        const state = signalsStore.getState();\n        \n        // Hide all tab contents first\n        document.querySelectorAll('.tab-content').forEach(tab => {\n            tab.classList.remove('active');\n        });\n        \n        switch (this.currentTab) {\n            case 'signal-feed':\n                const signalFeedTab = document.getElementById('signal-feed');\n                if (signalFeedTab) signalFeedTab.classList.add('active');\n                this.controllers.get('signals')?.render(state);\n                break;\n            case 'my-portfolio':\n                const portfolioTab = document.getElementById('my-portfolio');\n                if (portfolioTab) portfolioTab.classList.add('active');\n                this.controllers.get('portfolio')?.render(state);\n                break;\n            case 'actions':\n                // Handle actions tab if ActionsRenderer exists\n                if (typeof ActionsRenderer !== 'undefined') {\n                    console.log('📋 Rendering Actions tab');\n                    const state = signalsStore.getState();\n                    ActionsRenderer.renderActions(state).catch(error => {\n                        console.error('🚨 ERROR rendering actions:', error);\n                    });\n                    // Show the actions tab\n                    const actionsTab = document.getElementById('actions');\n                    if (actionsTab) actionsTab.classList.add('active');\n                } else {\n                    console.error('🚨 CRITICAL: ActionsRenderer not available');\n                }\n                break;\n            case 'whitespace':\n                // Handle whitespace tab if WhitespaceRenderer exists\n                if (typeof WhitespaceRenderer !== 'undefined') {\n                    console.log('📊 Rendering Whitespace tab');\n                    const state = signalsStore.getState();\n                    WhitespaceRenderer.renderWhitespace(state).catch(error => {\n                        console.error('🚨 ERROR rendering whitespace:', error);\n                    });\n                    // Show the whitespace tab after rendering\n                    setTimeout(() => {\n                        const whitespaceTab = document.getElementById('whitespace');\n                        if (whitespaceTab) whitespaceTab.classList.add('active');\n                    }, 100);\n                } else {\n                    console.error('🚨 CRITICAL: WhitespaceRenderer not available');\n                }\n                break;\n            default:\n                console.warn(`Unknown tab: ${this.currentTab}`);\n        }\n    }\n    \n    updateSummaryStats() {\n        try {\n            const state = signalsStore.getState();\n            \n            // Update dashboard stats from store state\n            // signals is an array, not a Map\n            const allSignals = state.signals || [];\n            const highPrioritySignals = allSignals.filter(s => s.priority === 'High');\n            \n            // Get unique accounts from signals\n            const uniqueAccountIds = new Set(allSignals.map(s => s.account_id).filter(id => id));\n            const accountsWithSignals = uniqueAccountIds.size;\n            \n            // Update Requires Attention count (accounts without action plans)\n            const planAccountIds = new Set(\n                Array.from(state.actionPlans.values())\n                    .map(plan => plan.accountId)\n                    .filter(accountId => accountId)\n            );\n            \n            // Count accounts that have signals but no action plans\n            const accountsWithoutPlans = Array.from(uniqueAccountIds).filter(accountId => \n                !planAccountIds.has(accountId)\n            ).length;\n            \n            // Update DOM elements\n            const updateElement = (id, value) => {\n                const element = document.getElementById(id);\n                if (element) element.textContent = value;\n            };\n            \n            updateElement('requiresAttentionCount', accountsWithoutPlans);\n            updateElement('highPriorityDashboard', highPrioritySignals.length);\n            updateElement('activeAccountsCount', accountsWithSignals);\n        } catch (error) {\n            console.error('Error updating summary stats:', error);\n        }\n    }\n    \n    showLoading() {\n        const loader = document.getElementById('loadingOverlay');\n        if (loader) loader.style.display = 'flex';\n    }\n    \n    hideLoading() {\n        const loader = document.getElementById('loadingOverlay');\n        if (loader) loader.style.display = 'none';\n    }\n    \n    showErrorMessage(message) {\n        // Use the notification service for consistent error display\n        if (window.NotificationService) {\n            window.NotificationService.showNotification(message, 'error');\n        } else {\n            console.error(message);\n            alert(message); // Fallback\n        }\n    }\n    \n    showSuccessMessage(message) {\n        if (window.NotificationService) {\n            window.NotificationService.showNotification(message, 'success');\n        } else {\n            console.log(message);\n        }\n    }\n}\n\n// AppController is now initialized from HTML bootstrap code\n// Make class globally available for debugging\nwindow.AppController = AppController;","size_bytes":12941},"js/controllers/CommentsController.js":{"content":"// CommentsController - Handles comment management across the application\nclass CommentsController {\n    constructor() {\n        this.setupEventListeners();\n        console.log('🎯 CommentsController initialized');\n    }\n    \n    setupEventListeners() {\n        // Set up delegated event handling for comment interactions\n        document.addEventListener('click', (e) => {\n            const target = e.target.closest('[data-action]');\n            if (!target) return;\n            \n            const action = target.getAttribute('data-action');\n            const signalId = target.getAttribute('data-signal-id');\n            const commentId = target.getAttribute('data-comment-id');\n            const accountId = target.getAttribute('data-account-id');\n            \n            // Only handle comment-related actions\n            if (this.isCommentAction(action)) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.handleCommentAction(action, { signalId, commentId, accountId }, target);\n            }\n        });\n        \n        // Handle comment input submissions via Enter key\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter' && !e.shiftKey) {\n                if (e.target.classList.contains('comment-input-linkedin')) {\n                    e.preventDefault();\n                    const signalId = e.target.closest('.signal-card')?.getAttribute('data-signal-id');\n                    if (signalId && e.target.value.trim()) {\n                        this.addSignalComment(signalId, e.target.value.trim());\n                        e.target.value = '';\n                    }\n                } else if (e.target.classList.contains('account-comment-input')) {\n                    e.preventDefault();\n                    const accountId = e.target.getAttribute('data-account-id') || \n                                    e.target.id.replace('accountCommentInput-', '');\n                    if (accountId && e.target.value.trim()) {\n                        this.addAccountComment(accountId, e.target.value.trim());\n                        e.target.value = '';\n                    }\n                }\n            }\n        });\n    }\n    \n    isCommentAction(action) {\n        const commentActions = [\n            'add-comment', 'edit-comment', 'delete-comment',\n            'add-account-comment', 'edit-account-comment', 'delete-account-comment'\n        ];\n        return commentActions.includes(action);\n    }\n    \n    handleCommentAction(action, params, target) {\n        const { signalId, commentId, accountId } = params;\n        \n        switch (action) {\n            case 'add-comment':\n                const inputElement = document.getElementById(`inlineCommentText-${signalId}`);\n                if (inputElement && inputElement.value.trim()) {\n                    this.addSignalComment(signalId, inputElement.value.trim());\n                    inputElement.value = '';\n                }\n                break;\n                \n            case 'edit-comment':\n                this.editSignalComment(commentId, signalId);\n                break;\n                \n            case 'delete-comment':\n                this.deleteSignalComment(commentId, signalId);\n                break;\n                \n            case 'add-account-comment':\n                const accountInputElement = document.getElementById(`accountCommentInput-${accountId}`);\n                if (accountInputElement && accountInputElement.value.trim()) {\n                    this.addAccountComment(accountId, accountInputElement.value.trim());\n                    accountInputElement.value = '';\n                }\n                break;\n                \n            case 'edit-account-comment':\n                this.editAccountComment(commentId, accountId);\n                break;\n                \n            case 'delete-account-comment':\n                this.deleteAccountComment(commentId, accountId);\n                break;\n                \n            default:\n                console.warn(`Unknown comment action: ${action}`);\n        }\n    }\n    \n    // Signal comment methods\n    addSignalComment(signalId, commentText) {\n        if (!signalId || !commentText.trim()) {\n            console.error('Signal ID and comment text are required');\n            return;\n        }\n        \n        dispatcher.dispatch(Actions.addComment(signalId, commentText.trim()));\n        this.showCommentMessage('Comment added successfully', 'success');\n    }\n    \n    editSignalComment(commentId, signalId) {\n        const state = signalsStore.getState();\n        const comments = state.comments.get(signalId) || [];\n        const comment = comments.find(c => c.id === commentId);\n        \n        if (!comment) {\n            console.error(`Comment ${commentId} not found`);\n            return;\n        }\n        \n        const newText = prompt('Edit comment:', comment.text);\n        \n        if (newText !== null && newText.trim() !== comment.text) {\n            dispatcher.dispatch(Actions.updateComment(commentId, signalId, newText.trim()));\n            this.showCommentMessage('Comment updated successfully', 'success');\n        }\n    }\n    \n    deleteSignalComment(commentId, signalId) {\n        if (confirm('Are you sure you want to delete this comment?')) {\n            dispatcher.dispatch(Actions.deleteComment(commentId, signalId));\n            this.showCommentMessage('Comment deleted successfully', 'info');\n        }\n    }\n    \n    // Account comment methods\n    addAccountComment(accountId, commentText) {\n        if (!accountId || !commentText.trim()) {\n            console.error('Account ID and comment text are required');\n            return;\n        }\n        \n        dispatcher.dispatch(Actions.addAccountComment(accountId, commentText.trim()));\n        this.showCommentMessage('Account comment added successfully', 'success');\n    }\n    \n    editAccountComment(commentId, accountId) {\n        const state = signalsStore.getState();\n        const comments = state.accountComments.get(accountId) || [];\n        const comment = comments.find(c => c.id === commentId);\n        \n        if (!comment) {\n            console.error(`Account comment ${commentId} not found`);\n            return;\n        }\n        \n        const newText = prompt('Edit comment:', comment.text);\n        \n        if (newText !== null && newText.trim() !== comment.text) {\n            dispatcher.dispatch(Actions.updateAccountComment(commentId, accountId, newText.trim()));\n            this.showCommentMessage('Account comment updated successfully', 'success');\n        }\n    }\n    \n    deleteAccountComment(commentId, accountId) {\n        if (confirm('Are you sure you want to delete this account comment?')) {\n            dispatcher.dispatch(Actions.deleteAccountComment(commentId, accountId));\n            this.showCommentMessage('Account comment deleted successfully', 'info');\n        }\n    }\n    \n    showCommentMessage(message, type = 'info') {\n        // Use notification service if available\n        if (window.NotificationService) {\n            window.NotificationService.showNotification(message, type);\n        } else {\n            console.log(`${type.toUpperCase()}: ${message}`);\n        }\n    }\n    \n    // Utility methods\n    getCommentsForSignal(signalId) {\n        const state = signalsStore.getState();\n        return state.comments.get(signalId) || [];\n    }\n    \n    getCommentsForAccount(accountId) {\n        const state = signalsStore.getState();\n        return state.accountComments.get(accountId) || [];\n    }\n    \n    getCommentStats() {\n        const state = signalsStore.getState();\n        \n        const signalCommentCount = Array.from(state.comments.values())\n            .reduce((total, comments) => total + comments.length, 0);\n            \n        const accountCommentCount = Array.from(state.accountComments.values())\n            .reduce((total, comments) => total + comments.length, 0);\n        \n        return {\n            totalSignalComments: signalCommentCount,\n            totalAccountComments: accountCommentCount,\n            totalComments: signalCommentCount + accountCommentCount\n        };\n    }\n    \n    searchComments(searchText) {\n        const state = signalsStore.getState();\n        const results = [];\n        \n        // Search signal comments\n        state.comments.forEach((comments, signalId) => {\n            comments.forEach(comment => {\n                if (comment.text.toLowerCase().includes(searchText.toLowerCase())) {\n                    results.push({\n                        type: 'signal',\n                        signalId,\n                        comment\n                    });\n                }\n            });\n        });\n        \n        // Search account comments\n        state.accountComments.forEach((comments, accountId) => {\n            comments.forEach(comment => {\n                if (comment.text.toLowerCase().includes(searchText.toLowerCase())) {\n                    results.push({\n                        type: 'account',\n                        accountId,\n                        comment\n                    });\n                }\n            });\n        });\n        \n        return results;\n    }\n}\n\n// Make globally available\nwindow.CommentsController = CommentsController;","size_bytes":9295},"js/controllers/FeedbackController.js":{"content":"// FeedbackController - Handles feedback interactions (like/unlike, etc.)\nclass FeedbackController {\n    constructor() {\n        this.setupEventListeners();\n        console.log('🎯 FeedbackController initialized');\n    }\n    \n    setupEventListeners() {\n        // Set up delegated event handling for feedback interactions\n        document.addEventListener('click', (e) => {\n            const target = e.target.closest('[data-action]');\n            if (!target) return;\n            \n            const action = target.getAttribute('data-action');\n            const signalId = target.getAttribute('data-signal-id');\n            \n            // Only handle feedback-related actions\n            if (this.isFeedbackAction(action)) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.handleFeedbackAction(action, signalId, target);\n            }\n        });\n    }\n    \n    isFeedbackAction(action) {\n        const feedbackActions = ['like', 'not-accurate', 'helpful', 'not-helpful'];\n        return feedbackActions.includes(action);\n    }\n    \n    handleFeedbackAction(action, signalId, target) {\n        switch (action) {\n            case 'like':\n                this.submitFeedback(signalId, 'like');\n                break;\n                \n            case 'not-accurate':\n                this.submitFeedback(signalId, 'not-accurate');\n                break;\n                \n            case 'helpful':\n                this.submitFeedback(signalId, 'helpful');\n                break;\n                \n            case 'not-helpful':\n                this.submitFeedback(signalId, 'not-helpful');\n                break;\n                \n            default:\n                console.warn(`Unknown feedback action: ${action}`);\n        }\n    }\n    \n    submitFeedback(signalId, feedbackType) {\n        // Get current signal state\n        const state = signalsStore.getState();\n        const signal = state.signalsById.get(signalId);\n        \n        if (!signal) {\n            console.error(`Signal ${signalId} not found`);\n            return;\n        }\n        \n        // Check if user already has feedback for this signal\n        const currentFeedback = signal.currentUserFeedback;\n        \n        if (currentFeedback === feedbackType) {\n            // User is removing their feedback\n            dispatcher.dispatch(Actions.removeFeedback(signalId, feedbackType));\n            this.showFeedbackMessage(`Removed ${feedbackType} feedback`, 'info');\n        } else {\n            // User is submitting new feedback\n            dispatcher.dispatch(Actions.submitFeedback(signalId, feedbackType));\n            this.showFeedbackMessage(`Signal marked as ${feedbackType}`, 'success');\n        }\n    }\n    \n    showFeedbackMessage(message, type = 'info') {\n        // Use notification service if available\n        if (window.NotificationService) {\n            window.NotificationService.showNotification(message, type);\n        } else {\n            console.log(`${type.toUpperCase()}: ${message}`);\n        }\n    }\n    \n    // Bulk feedback operations\n    submitBulkFeedback(signalIds, feedbackType) {\n        signalIds.forEach(signalId => {\n            this.submitFeedback(signalId, feedbackType);\n        });\n        \n        this.showFeedbackMessage(\n            `Applied ${feedbackType} feedback to ${signalIds.length} signals`, \n            'success'\n        );\n    }\n    \n    clearAllFeedback(signalId) {\n        const state = signalsStore.getState();\n        const signal = state.signalsById.get(signalId);\n        \n        if (!signal || !signal.currentUserFeedback) {\n            return;\n        }\n        \n        dispatcher.dispatch(Actions.removeFeedback(signalId, signal.currentUserFeedback));\n        this.showFeedbackMessage('Feedback cleared', 'info');\n    }\n    \n    // Get feedback statistics\n    getFeedbackStats() {\n        const state = signalsStore.getState();\n        const signals = Array.from(state.signalsById.values());\n        \n        const stats = {\n            total: signals.length,\n            liked: signals.filter(s => s.currentUserFeedback === 'like').length,\n            notAccurate: signals.filter(s => s.currentUserFeedback === 'not-accurate').length,\n            helpful: signals.filter(s => s.currentUserFeedback === 'helpful').length,\n            notHelpful: signals.filter(s => s.currentUserFeedback === 'not-helpful').length,\n            noFeedback: signals.filter(s => !s.currentUserFeedback).length\n        };\n        \n        return stats;\n    }\n}\n\n// Make globally available\nwindow.FeedbackController = FeedbackController;","size_bytes":4606},"js/controllers/PortfolioController.js":{"content":"// PortfolioController - Handles portfolio tab and account management\nclass PortfolioController {\n    constructor() {\n        this.subscribeToStore();\n        this.setupEventListeners();\n        console.log('🎯 PortfolioController initialized');\n    }\n    \n    subscribeToStore() {\n        // Subscribe to store changes relevant to portfolio\n        signalsStore.subscribe('portfolio-controller', (eventType) => {\n            if (eventType === 'accounts-updated' || \n                eventType === 'action-plans-updated' || \n                eventType === 'comments-updated') {\n                this.render();\n            }\n        });\n    }\n    \n    setupEventListeners() {\n        // Set up delegated event handling for portfolio interactions - scoped to portfolio only\n        const portfolioContainer = document.getElementById('my-portfolio');\n        if (portfolioContainer) {\n            portfolioContainer.addEventListener('click', (e) => {\n                const target = e.target.closest('[data-action]');\n                if (!target) return;\n                \n                const action = target.getAttribute('data-action');\n                const accountId = target.getAttribute('data-account-id');\n                const signalId = target.getAttribute('data-signal-id');\n                \n                // Only handle portfolio-related actions (excluding comments and view-signal)\n                if (this.isPortfolioAction(action)) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.handlePortfolioAction(action, accountId, signalId, target);\n                }\n            });\n        }\n        \n        // Portfolio filter buttons\n        const filterBtns = document.querySelectorAll('.filter-btn');\n        filterBtns.forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                // Update active state\n                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));\n                e.target.classList.add('active');\n                \n                // Dispatch filter action\n                const filterType = e.target.getAttribute('data-filter');\n                dispatcher.dispatch(Actions.applyPortfolioFilter(filterType));\n            });\n        });\n    }\n    \n    isPortfolioAction(action) {\n        const portfolioActions = [\n            'toggle-account-signals', 'show-more-signals', 'show-less-signals', 'view-signal', 'add-account-comment'\n        ];\n        return portfolioActions.includes(action);\n    }\n    \n    handlePortfolioAction(action, accountId, signalId, target) {\n        switch (action) {\n            case 'toggle-account-signals':\n                this.toggleAccountSignals(accountId);\n                break;\n                \n            case 'show-more-signals':\n                this.showMoreSignalsForAccount(accountId);\n                break;\n                \n            case 'show-less-signals':\n                this.showLessSignalsForAccount(accountId);\n                break;\n                \n            case 'view-signal':\n                // Handle view-signal from portfolio context only\n                if (signalId) {\n                    dispatcher.dispatch(Actions.markSignalAsViewed(signalId));\n                    dispatcher.dispatch(Actions.openSignalDetails(signalId));\n                }\n                break;\n                \n            case 'add-account-comment':\n                this.handleAddAccountComment(accountId, target);\n                break;\n                \n            default:\n                console.warn(`Unknown portfolio action: ${action}`);\n        }\n    }\n    \n    toggleAccountSignals(accountId) {\n        const signalsContainer = document.getElementById(`signals-${accountId}`);\n        const chevron = document.getElementById(`chevron-${accountId}`);\n        \n        if (signalsContainer && chevron) {\n            const isExpanded = signalsContainer.classList.contains('expanded');\n            \n            if (isExpanded) {\n                signalsContainer.classList.remove('expanded');\n                chevron.classList.remove('rotated');\n                dispatcher.dispatch(Actions.collapseAccount(accountId));\n            } else {\n                signalsContainer.classList.add('expanded');\n                chevron.classList.add('rotated');\n                dispatcher.dispatch(Actions.expandAccount(accountId));\n            }\n        }\n    }\n    \n    showMoreSignalsForAccount(accountId) {\n        dispatcher.dispatch(Actions.showMoreSignalsForAccount(accountId));\n        // Re-render just this account card\n        this.updateSingleAccount(accountId);\n    }\n    \n    showLessSignalsForAccount(accountId) {\n        dispatcher.dispatch(Actions.showLessSignalsForAccount(accountId));\n        // Re-render just this account card\n        this.updateSingleAccount(accountId);\n    }\n    \n    handleAddAccountComment(accountId, target) {\n        const inputElement = document.getElementById(`accountCommentInput-${accountId}`);\n        if (inputElement && inputElement.value.trim()) {\n            dispatcher.dispatch(Actions.addAccountComment(accountId, inputElement.value.trim()));\n            inputElement.value = '';\n        }\n    }\n    \n    render(state = null) {\n        if (!state) {\n            state = signalsStore.getState();\n        }\n        \n        // Check if we're on the portfolio tab\n        if (document.getElementById('my-portfolio')?.classList.contains('active')) {\n            \n            // Call the pure PortfolioRenderer with store data\n            PortfolioRenderer.renderMyPortfolio(\n                state.accounts,\n                state.actionPlans,\n                state.comments\n            );\n            \n            // Initialize call tooltips after rendering\n            PortfolioRenderer.initializeCallTooltips();\n            \n            // 🎯 Initialize button states for optimistic UI\n            setTimeout(() => {\n                PortfolioRenderer.initializePlanButtonStates(state);\n            }, 50); // Small delay to ensure DOM is updated\n            \n            console.log(`🎨 Rendered ${state.accounts.size} accounts in portfolio`);\n        }\n    }\n    \n    updateSingleAccount(accountId) {\n        const state = signalsStore.getState();\n        \n        // Use the pure PortfolioRenderer method with store data\n        PortfolioRenderer.updateSingleAccount(\n            accountId,\n            state.accounts,\n            state.actionPlans,\n            state.comments\n        );\n    }\n    \n    // Helper methods for external usage\n    createActionPlanForAccount(accountId) {\n        const state = signalsStore.getState();\n        const account = state.accounts.get(accountId);\n        \n        if (account && account.signals.length > 0) {\n            // Use the highest priority signal from this account, or the most recent one\n            const highPrioritySignals = account.signals.filter(s => s.priority === 'High');\n            const selectedSignal = highPrioritySignals.length > 0\n                ? highPrioritySignals.sort((a, b) => new Date(b.created_date || Date.now()) - new Date(a.created_date || Date.now()))[0]\n                : account.signals.sort((a, b) => new Date(b.created_date || Date.now()) - new Date(a.created_date || Date.now()))[0];\n\n            dispatcher.dispatch(Actions.createActionPlanForAccount(accountId, selectedSignal.id));\n        } else {\n            dispatcher.dispatch(Actions.createActionPlanForAccount(accountId, null));\n        }\n    }\n    \n    selectActionPlanToEdit(accountId) {\n        const state = signalsStore.getState();\n        \n        // Get all plans for this account\n        const accountPlans = Array.from(state.actionPlans.values())\n            .filter(plan => plan.accountId === accountId);\n        \n        if (accountPlans.length === 1) {\n            // Only one plan, edit it directly\n            dispatcher.dispatch(Actions.editActionPlan(accountPlans[0].id));\n        } else if (accountPlans.length > 1) {\n            // Multiple plans, show selection modal\n            dispatcher.dispatch(Actions.showPlanSelectionModal(accountId, accountPlans));\n        } else {\n            // No plans found, create new one\n            this.createActionPlanForAccount(accountId);\n        }\n    }\n    \n    refreshPortfolio() {\n        this.render();\n    }\n}\n\n// Make globally available\nwindow.PortfolioController = PortfolioController;","size_bytes":8429},"js/controllers/SignalsController.js":{"content":"// SignalsController - Handles signal feed tab and signal interactions\nclass SignalsController {\n    constructor() {\n        this.subscribeToStore();\n        this.setupEventListeners();\n        console.log('🎯 SignalsController initialized');\n    }\n    \n    subscribeToStore() {\n        // Subscribe to store changes relevant to signals\n        signalsStore.subscribe('signals-controller', (eventType) => {\n            if (eventType === 'signals-updated' || \n                eventType === 'comments-updated' || \n                eventType === 'feedback-updated' ||\n                eventType === 'signal-viewed' ||\n                eventType === 'signals:filtered' ||\n                eventType === 'signal-removed' ||\n                eventType === 'accounts-updated') {\n                this.render();\n            }\n        });\n    }\n    \n    setupEventListeners() {\n        // Set up delegated event handling for signal interactions - scoped to signal feed only\n        const signalFeedContainer = document.getElementById('signal-feed');\n        if (signalFeedContainer) {\n            signalFeedContainer.addEventListener('click', (e) => {\n                const target = e.target.closest('[data-action]');\n                if (!target) return;\n                \n                const action = target.getAttribute('data-action');\n                const signalId = target.getAttribute('data-signal-id');\n                \n                // Only handle signal-related actions (excluding comments)\n                if (this.isSignalAction(action)) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.handleSignalAction(action, signalId, target);\n                }\n            });\n        }\n        \n        // Filter events for signal feed\n        const categoryFilter = document.getElementById('categoryFilter');\n        if (categoryFilter) {\n            categoryFilter.addEventListener('change', () => {\n                const signalType = document.getElementById('signalTypeFilter')?.value || 'all';\n                const category = categoryFilter.value;\n                dispatcher.dispatch(Actions.applyFilters({ signalType, category }));\n            });\n        }\n        \n        const signalTypeFilter = document.getElementById('signalTypeFilter');\n        if (signalTypeFilter) {\n            signalTypeFilter.addEventListener('change', () => {\n                const category = document.getElementById('categoryFilter')?.value || 'all';\n                const signalType = signalTypeFilter.value;\n                dispatcher.dispatch(Actions.applyFilters({ signalType, category }));\n            });\n        }\n    }\n    \n    isSignalAction(action) {\n        const signalActions = [\n            'remove-signal', 'view-signal'\n        ];\n        return signalActions.includes(action);\n    }\n    \n    handleSignalAction(action, signalId, target) {\n        const commentId = target.getAttribute('data-comment-id');\n        \n        switch (action) {\n            case 'remove-signal':\n                if (confirm('Are you sure you want to remove this signal from your feed?')) {\n                    dispatcher.dispatch(Actions.removeSignalFromFeed(signalId));\n                }\n                break;\n                \n            case 'view-signal':\n                dispatcher.dispatch(Actions.markSignalAsViewed(signalId));\n                dispatcher.dispatch(Actions.openSignalDetails(signalId));\n                break;\n                \n            default:\n                console.warn(`Unknown signal action: ${action}`);\n        }\n    }\n    \n    handleEditComment(commentId, signalId) {\n        const commentElement = document.getElementById(`comment-text-${commentId}`);\n        if (!commentElement) return;\n        \n        const currentText = commentElement.textContent;\n        const newText = prompt('Edit comment:', currentText);\n        \n        if (newText !== null && newText.trim() !== currentText) {\n            dispatcher.dispatch(Actions.updateComment(commentId, signalId, newText.trim()));\n        }\n    }\n    \n    render(state = null) {\n        if (!state) {\n            state = signalsStore.getState();\n        }\n        \n        // Check if we're on the signal feed tab\n        if (document.getElementById('signal-feed')?.classList.contains('active')) {\n            \n            // Use the centralized filteredSignals from the store\n            // The store already manages filtering based on viewState.filters\n            const filteredSignals = state.filteredSignals || [];\n            \n            // Call the pure SignalRenderer with store data\n            SignalRenderer.renderSignalFeed(\n                filteredSignals,\n                state.viewState,\n                state.comments,\n                state.interactions,\n                state.actionPlans\n            );\n            \n            console.log(`🎨 Rendered ${filteredSignals.length} signals in feed`);\n        }\n    }\n    \n    // DEPRECATED: Filtering is now centralized in SignalsStore\n    // Use state.filteredSignals directly instead of calling this method\n    getFilteredSignals(state) {\n        console.warn('getFilteredSignals is deprecated. Use state.filteredSignals directly.');\n        return state.filteredSignals || [];\n    }\n    \n    applyFilters(priority = 'all', category = 'all', searchText = '') {\n        dispatcher.dispatch(Actions.applyFilters({\n            priority,\n            category,\n            searchText\n        }));\n    }\n    \n    markSignalAsViewed(signalId) {\n        dispatcher.dispatch(Actions.markSignalAsViewed(signalId));\n    }\n    \n    // Helper method for external usage\n    refreshSignalFeed() {\n        this.render();\n    }\n}\n\n// Make globally available\nwindow.SignalsController = SignalsController;","size_bytes":5778},"js/utils/SecurityUtils.js":{"content":"// SecurityUtils - Utilities for preventing XSS attacks and sanitizing user input\nclass SecurityUtils {\n    \n    /**\n     * Sanitize HTML to prevent XSS attacks\n     * Escapes dangerous characters in user-generated content\n     * @param {string} str - The string to sanitize\n     * @return {string} - The sanitized string safe for innerHTML\n     */\n    static sanitizeHTML(str) {\n        if (!str) return '';\n        \n        // Convert to string if not already\n        const text = String(str);\n        \n        // Define the characters to escape\n        const escapeMap = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;',\n            '/': '&#x2F;',\n            '`': '&#x60;',\n            '=': '&#x3D;'\n        };\n        \n        // Replace dangerous characters with their HTML entities\n        return text.replace(/[&<>\"'`=\\/]/g, (char) => escapeMap[char]);\n    }\n    \n    /**\n     * Sanitize text for use in HTML attributes\n     * @param {string} str - The string to sanitize\n     * @return {string} - The sanitized string safe for HTML attributes\n     */\n    static sanitizeAttribute(str) {\n        if (!str) return '';\n        \n        // Convert to string and escape quotes and other dangerous characters\n        return String(str)\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#x27;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r');\n    }\n    \n    /**\n     * Sanitize text for use in JavaScript strings\n     * @param {string} str - The string to sanitize\n     * @return {string} - The sanitized string safe for JavaScript\n     */\n    static sanitizeJS(str) {\n        if (!str) return '';\n        \n        // Convert to string and escape characters that could break out of JS strings\n        return String(str)\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/'/g, \"\\\\'\")\n            .replace(/\"/g, '\\\\\"')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\t/g, '\\\\t')\n            .replace(/<\\//g, '<\\\\/')\n            .replace(/<!--/g, '<\\\\!--');\n    }\n    \n    /**\n     * Sanitize URL to prevent javascript: and data: URLs\n     * @param {string} url - The URL to sanitize\n     * @return {string} - The sanitized URL or empty string if dangerous\n     */\n    static sanitizeURL(url) {\n        if (!url) return '';\n        \n        const urlStr = String(url).trim().toLowerCase();\n        \n        // Block dangerous protocols\n        const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];\n        for (const protocol of dangerousProtocols) {\n            if (urlStr.startsWith(protocol)) {\n                console.warn(`Blocked dangerous URL: ${url}`);\n                return '';\n            }\n        }\n        \n        // Allow safe protocols or relative URLs\n        return String(url);\n    }\n    \n    /**\n     * Create a safe DOM element with text content\n     * This is the safest way to add user content when HTML formatting is not needed\n     * @param {string} tagName - The HTML tag name\n     * @param {string} textContent - The text content\n     * @param {Object} attributes - Optional attributes\n     * @return {string} - The HTML string\n     */\n    static createSafeElement(tagName, textContent, attributes = {}) {\n        const safeTag = this.sanitizeHTML(tagName);\n        const safeText = this.sanitizeHTML(textContent);\n        \n        let attributeStr = '';\n        for (const [key, value] of Object.entries(attributes)) {\n            const safeKey = this.sanitizeAttribute(key);\n            const safeValue = this.sanitizeAttribute(value);\n            attributeStr += ` ${safeKey}=\"${safeValue}\"`;\n        }\n        \n        return `<${safeTag}${attributeStr}>${safeText}</${safeTag}>`;\n    }\n    \n    /**\n     * Strip all HTML tags from a string\n     * Useful when you want plain text only\n     * @param {string} html - The HTML string\n     * @return {string} - Plain text without HTML tags\n     */\n    static stripHTML(html) {\n        if (!html) return '';\n        \n        // Create a temporary element to parse HTML\n        const temp = document.createElement('div');\n        temp.textContent = html;\n        return temp.innerHTML;\n    }\n    \n    /**\n     * Validate and sanitize user input based on expected type\n     * @param {*} input - The input to validate\n     * @param {string} type - The expected type ('string', 'number', 'email', etc.)\n     * @return {*} - The validated and sanitized input\n     */\n    static validateInput(input, type) {\n        switch (type) {\n            case 'string':\n                return this.sanitizeHTML(String(input || ''));\n            \n            case 'number':\n                const num = Number(input);\n                return isNaN(num) ? 0 : num;\n            \n            case 'email':\n                const email = String(input || '').toLowerCase().trim();\n                const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                return emailRegex.test(email) ? email : '';\n            \n            case 'id':\n                // IDs should be alphanumeric with dashes/underscores\n                return String(input || '').replace(/[^a-zA-Z0-9_-]/g, '');\n            \n            case 'boolean':\n                return Boolean(input);\n            \n            default:\n                return this.sanitizeHTML(String(input || ''));\n        }\n    }\n}\n\n// Make available globally\nwindow.SecurityUtils = SecurityUtils;","size_bytes":5597},"js/WhitespaceRenderer.js":{"content":"// WhitespaceRenderer - Signal Heat Map Analysis\nclass WhitespaceRenderer {\n    \n    /**\n     * Main render method for Whitespace view\n     */\n    static async renderWhitespace(state) {\n        try {\n            console.log('🎯 Rendering Whitespace heatmap view');\n            \n            // Get data from Flux store state - handle both array and Map formats\n            const signals = Array.isArray(state.signals) ? state.signals : \n                           (state.signals && typeof state.signals[Symbol.iterator] === 'function' ? \n                            Array.from(state.signals.values()) : []);\n            \n            const accounts = state.accounts || new Map();\n            \n            console.log(`🔍 Processing ${signals.length} signals`);\n            \n            // Process signals into matrix format\n            const { matrix, signalTypes, accountNames, stats, signalPolarities } = this.processSignalsMatrix(signals, accounts);\n            \n            console.log(`📊 Processed ${stats.totalAccounts} accounts, ${stats.totalSignalTypes} signal types, ${stats.totalOccurrences} total occurrences`);\n            \n            // Get the main content container\n            const contentContainer = document.querySelector('.main-content');\n            if (!contentContainer) {\n                console.error('❌ Main content container not found');\n                return;\n            }\n            \n            // Create whitespace tab content\n            let whitespaceTab = document.getElementById('whitespace');\n            if (!whitespaceTab) {\n                whitespaceTab = document.createElement('div');\n                whitespaceTab.id = 'whitespace';\n                whitespaceTab.className = 'tab-content';\n                contentContainer.appendChild(whitespaceTab);\n            }\n            \n            // Render the heatmap content\n            whitespaceTab.innerHTML = this.generateWhitespaceHTML(matrix, signalTypes, accountNames, stats, signalPolarities);\n            \n            // Setup event listeners\n            this.setupEventListeners();\n            \n            console.log('✅ Whitespace view rendered successfully');\n            \n        } catch (error) {\n            console.error('❌ Error rendering Whitespace view:', error);\n        }\n    }\n    \n    /**\n     * Process signals data into heatmap matrix format\n     */\n    static processSignalsMatrix(signals, accounts) {\n        console.log('🔄 Processing signals into heatmap matrix...');\n        \n        const matrix = {};\n        const signalTypesMap = new Map(); // Use Map to preserve order and store metadata\n        const accountMap = new Map();\n        const signalPolarities = {};\n        \n        let totalOccurrences = 0;\n        \n        // Process each signal from the signals array\n        for (let signal of signals) {\n            if (!signal || !signal.account_id) {\n                continue;\n            }\n            \n            const accountId = signal.account_id;\n            \n            // Get account name - handle different account data structures\n            let accountName = signal.account_name || signal.accountName || `Account ${accountId}`;\n            if (accounts) {\n                if (accounts.get && typeof accounts.get === 'function') {\n                    const account = accounts.get(accountId);\n                    if (account) accountName = account.name || accountName;\n                } else if (accounts[accountId]) {\n                    accountName = accounts[accountId].name || accountName;\n                }\n            }\n            \n            // Store account info\n            if (!accountMap.has(accountId)) {\n                accountMap.set(accountId, accountName);\n            }\n            \n            // Create signal type key - use code if available, otherwise truncate name\n            const signalCode = signal.code || signal.signal_code || '';\n            const signalName = signal.name || signal.signal_name || 'Unknown';\n            const signalKey = signalCode || signalName.substring(0, 20);\n            \n            // Store full signal info for tooltips\n            if (!signalTypesMap.has(signalKey)) {\n                signalTypesMap.set(signalKey, {\n                    code: signalCode,\n                    name: signalName,\n                    category: signal.category || 'General'\n                });\n            }\n            \n            // Store polarity for this signal type\n            const polarity = signal.signal_polarity || signal['Signal Polarity'] || 'Enrichment';\n            signalPolarities[signalKey] = polarity;\n            \n            // Initialize matrix structure\n            if (!matrix[accountName]) {\n                matrix[accountName] = {};\n            }\n            \n            if (!matrix[accountName][signalKey]) {\n                matrix[accountName][signalKey] = {\n                    count: 0,\n                    polarity: polarity,\n                    accountId: accountId,\n                    fullSignalName: signalName\n                };\n            }\n            \n            // Increment count\n            matrix[accountName][signalKey].count++;\n            totalOccurrences++;\n        }\n        \n        // Sort accounts and signal types\n        const sortedAccounts = Array.from(accountMap.values()).sort();\n        const sortedSignalTypes = Array.from(signalTypesMap.keys()).sort();\n        \n        // Calculate statistics\n        const stats = {\n            totalAccounts: sortedAccounts.length,\n            totalSignalTypes: sortedSignalTypes.length,\n            totalOccurrences,\n            avgSignalsPerAccount: sortedAccounts.length > 0 ? (totalOccurrences / sortedAccounts.length).toFixed(1) : 0\n        };\n        \n        console.log(`✅ Matrix processing complete:`, stats);\n        \n        return {\n            matrix,\n            signalTypes: sortedSignalTypes,\n            accountNames: sortedAccounts,\n            stats,\n            signalPolarities,\n            signalTypesMap\n        };\n    }\n    \n    /**\n     * Generate the HTML structure for the Whitespace view\n     */\n    static generateWhitespaceHTML(matrix, signalTypes, accountNames, stats, signalPolarities) {\n        return `\n            <div class=\"whitespace-container\">\n                <div class=\"whitespace-header\">\n                    <div class=\"whitespace-header-content\">\n                        <i class=\"fas fa-th whitespace-header-icon\"></i>\n                        <h1 class=\"whitespace-title\">Whitespace Analysis</h1>\n                        <p class=\"whitespace-subtitle\">Signal distribution patterns across your portfolio</p>\n                    </div>\n                </div>\n                \n                <div class=\"whitespace-stats\">\n                    <div class=\"whitespace-stat-card\">\n                        <div class=\"stat-value\">${stats.totalAccounts}</div>\n                        <div class=\"stat-label\">TOTAL ACCOUNTS</div>\n                    </div>\n                    <div class=\"whitespace-stat-card\">\n                        <div class=\"stat-value\">${stats.totalSignalTypes}</div>\n                        <div class=\"stat-label\">SIGNAL TYPES</div>\n                    </div>\n                    <div class=\"whitespace-stat-card\">\n                        <div class=\"stat-value\">${stats.totalOccurrences}</div>\n                        <div class=\"stat-label\">TOTAL SIGNALS</div>\n                    </div>\n                    <div class=\"whitespace-stat-card\">\n                        <div class=\"stat-value\">${stats.avgSignalsPerAccount}</div>\n                        <div class=\"stat-label\">AVG PER ACCOUNT</div>\n                    </div>\n                </div>\n                \n                <div class=\"whitespace-table-container\">\n                    <div class=\"heatmap-scroll-wrapper\">\n                        ${this.generateHeatmapTable(matrix, signalTypes, accountNames, signalPolarities)}\n                    </div>\n                </div>\n                \n                <div class=\"whitespace-legend\">\n                    <div class=\"legend-group\">\n                        <span class=\"legend-label\">Opportunity:</span>\n                        <div class=\"legend-items\">\n                            <span class=\"legend-item opportunity-1\">1</span>\n                            <span class=\"legend-item opportunity-2\">2</span>\n                            <span class=\"legend-item opportunity-3\">3</span>\n                            <span class=\"legend-item opportunity-4\">4</span>\n                            <span class=\"legend-item opportunity-5\">5+</span>\n                        </div>\n                    </div>\n                    <div class=\"legend-group\">\n                        <span class=\"legend-label\">Risk:</span>\n                        <div class=\"legend-items\">\n                            <span class=\"legend-item risk-1\">1</span>\n                            <span class=\"legend-item risk-2\">2</span>\n                            <span class=\"legend-item risk-3\">3</span>\n                            <span class=\"legend-item risk-4\">4</span>\n                            <span class=\"legend-item risk-5\">5+</span>\n                        </div>\n                    </div>\n                    <div class=\"legend-group\">\n                        <span class=\"legend-label\">Enrichment:</span>\n                        <div class=\"legend-items\">\n                            <span class=\"legend-item enrichment-1\">1</span>\n                            <span class=\"legend-item enrichment-2\">2</span>\n                            <span class=\"legend-item enrichment-3\">3</span>\n                            <span class=\"legend-item enrichment-4\">4</span>\n                            <span class=\"legend-item enrichment-5\">5+</span>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"whitespace-tooltip\" id=\"whitespaceTooltip\"></div>\n            </div>\n        `;\n    }\n    \n    /**\n     * Generate the heatmap table HTML\n     */\n    static generateHeatmapTable(matrix, signalTypes, accountNames, signalPolarities) {\n        let tableHTML = `\n            <table class=\"whitespace-heatmap-table\">\n                <thead>\n                    <tr class=\"heatmap-header-row\">\n                        <th class=\"heatmap-corner-cell\">Account Name</th>\n                        ${signalTypes.map(signalType => {\n                            const sanitizedSignal = SecurityUtils.sanitizeHTML(signalType);\n                            return `\n                                <th class=\"heatmap-header-cell\">\n                                    <div class=\"rotated-header\" title=\"${sanitizedSignal}\">\n                                        <span>${sanitizedSignal}</span>\n                                    </div>\n                                </th>\n                            `;\n                        }).join('')}\n                    </tr>\n                </thead>\n                <tbody>\n        `;\n        \n        // Generate rows for each account\n        accountNames.forEach(accountName => {\n            const sanitizedAccountName = SecurityUtils.sanitizeHTML(accountName);\n            tableHTML += `\n                <tr class=\"heatmap-row\">\n                    <td class=\"heatmap-account-cell\">${sanitizedAccountName}</td>\n            `;\n            \n            signalTypes.forEach(signalType => {\n                const cellData = matrix[accountName]?.[signalType];\n                const count = cellData?.count || 0;\n                const polarity = cellData?.polarity || signalPolarities[signalType] || 'Enrichment';\n                \n                const colorClass = this.getColorClass(count, polarity);\n                const sanitizedSignalType = SecurityUtils.sanitizeHTML(signalType);\n                const fullSignalName = cellData?.fullSignalName || signalType;\n                \n                tableHTML += `\n                    <td class=\"heatmap-data-cell ${colorClass}\" \n                        data-account=\"${sanitizedAccountName}\"\n                        data-signal=\"${sanitizedSignalType}\"\n                        data-signal-full=\"${SecurityUtils.sanitizeHTML(fullSignalName)}\"\n                        data-count=\"${count}\"\n                        data-polarity=\"${polarity}\">\n                        ${count > 0 ? count : ''}\n                    </td>\n                `;\n            });\n            \n            tableHTML += `</tr>`;\n        });\n        \n        tableHTML += `\n                </tbody>\n            </table>\n        `;\n        \n        return tableHTML;\n    }\n    \n    /**\n     * Get CSS color class based on count and polarity\n     */\n    static getColorClass(count, polarity) {\n        if (count === 0) return 'empty-cell';\n        \n        const intensity = Math.min(count, 5);\n        const polarityClass = (polarity || 'enrichment').toLowerCase();\n        \n        // Normalize polarity variations\n        let normalizedPolarity = polarityClass;\n        if (polarityClass === 'opportunities' || polarityClass === 'opportunity') {\n            normalizedPolarity = 'opportunity';\n        } else if (polarityClass === 'risks' || polarityClass === 'risk') {\n            normalizedPolarity = 'risk';\n        } else {\n            normalizedPolarity = 'enrichment';\n        }\n        \n        return `${normalizedPolarity}-${intensity}`;\n    }\n    \n    /**\n     * Normalize polarity to a safe whitelist value for CSS classes\n     * This prevents XSS attacks through class attribute injection\n     */\n    static normalizePolarity(polarity) {\n        if (!polarity) return 'enrichment';\n        \n        const polarityLower = String(polarity).toLowerCase();\n        \n        // Strict whitelist - only return one of these three values\n        if (polarityLower === 'opportunity' || polarityLower === 'opportunities') {\n            return 'opportunity';\n        } else if (polarityLower === 'risk' || polarityLower === 'risks') {\n            return 'risk';\n        } else {\n            return 'enrichment';\n        }\n    }\n    \n    /**\n     * Setup event listeners for interactivity\n     */\n    static setupEventListeners() {\n        // Add hover effects for data cells\n        const dataCells = document.querySelectorAll('.heatmap-data-cell');\n        dataCells.forEach(cell => {\n            cell.addEventListener('mouseenter', (e) => this.showTooltip(e));\n            cell.addEventListener('mouseleave', () => this.hideTooltip());\n            cell.addEventListener('click', (e) => this.handleCellClick(e));\n        });\n    }\n    \n    /**\n     * Show enhanced tooltip on cell hover\n     */\n    static showTooltip(event) {\n        const tooltip = document.getElementById('whitespaceTooltip');\n        const cell = event.target;\n        \n        const account = cell.dataset.account;\n        const signal = cell.dataset.signal;\n        const signalFull = cell.dataset.signalFull;\n        const count = cell.dataset.count;\n        const polarity = cell.dataset.polarity;\n        \n        if (count && count !== '0') {\n            // Sanitize and normalize polarity for safe class usage\n            const normalizedPolarity = this.normalizePolarity(polarity);\n            \n            tooltip.innerHTML = `\n                <div class=\"tooltip-content\">\n                    <div class=\"tooltip-header\">${SecurityUtils.sanitizeHTML(account)}</div>\n                    <div class=\"tooltip-signal\">${SecurityUtils.sanitizeHTML(signalFull || signal)}</div>\n                    <div class=\"tooltip-stats\">\n                        <span class=\"tooltip-count\">Count: ${count}</span>\n                        <span class=\"tooltip-polarity ${normalizedPolarity}\">${SecurityUtils.sanitizeHTML(polarity)}</span>\n                    </div>\n                </div>\n            `;\n            \n            // Improved positioning with viewport awareness\n            const rect = cell.getBoundingClientRect();\n            const scrollX = window.scrollX || window.pageXOffset;\n            const scrollY = window.scrollY || window.pageYOffset;\n            \n            tooltip.style.display = 'block';\n            tooltip.style.left = (rect.left + rect.width / 2 + scrollX) + 'px';\n            tooltip.style.top = (rect.top + scrollY - 10) + 'px';\n        }\n    }\n    \n    /**\n     * Hide tooltip\n     */\n    static hideTooltip() {\n        const tooltip = document.getElementById('whitespaceTooltip');\n        if (tooltip) {\n            tooltip.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Handle cell click for drill-down functionality\n     */\n    static handleCellClick(event) {\n        const cell = event.target;\n        const count = cell.dataset.count;\n        \n        if (count && count !== '0') {\n            const account = cell.dataset.account;\n            const signal = cell.dataset.signalFull || cell.dataset.signal;\n            console.log(`Cell clicked: ${account} - ${signal} (${count} signals)`);\n            // Future: Navigate to filtered signal view\n        }\n    }\n}","size_bytes":17047},"js/flux/SignalsStore-normalized.js":{"content":"// SignalsStore - Normalized Relational Model with Backward Compatibility\nclass SignalsStore extends Store {\n    \n    constructor() {\n        super('SignalsStore');\n        \n        // Initialize normalized entity stores\n        this.normalizedData = {\n            accounts: new Map(),\n            signals: new Map(),\n            recommendedActions: new Map(),\n            interactions: new Map(),\n            comments: new Map(),\n            actionPlans: new Map()\n        };\n        \n        // Initialize relationship indexes\n        this.indexes = {\n            signalsByAccount: new Map(),\n            signalsByAction: new Map(),\n            actionsByAccount: new Map(),\n            interactionsBySignal: new Map(),\n            commentsBySignal: new Map(),\n            commentsByAccount: new Map(),\n            plansByAccount: new Map(),\n            plansByAction: new Map()\n        };\n        \n        // Initialize state structure (for backward compatibility)\n        this.setInitialState({\n            // Core data (denormalized for backward compatibility)\n            signals: [],\n            accounts: new Map(),\n            comments: new Map(),\n            interactions: new Map(),\n            actionPlans: new Map(),\n            userInfo: {},\n            \n            // Indexes for performance\n            signalsById: new Map(),\n            signalsByAccount: new Map(),\n            interactionsByUser: new Map(),\n            actionPlansByAccount: new Map(),\n            \n            // UI state\n            currentTab: 'signal-feed',\n            selectedSignal: null,\n            filteredSignals: [],\n            loading: false,\n            message: null,\n            \n            // View state with filters\n            viewState: {\n                filters: {\n                    signalType: 'all',\n                    category: 'all',\n                    searchText: '',\n                    priority: 'all',\n                    polarity: 'all',\n                    riskCategory: 'all'\n                },\n                pagination: {\n                    page: 1,\n                    pageSize: 20\n                }\n            },\n            \n            // Modal/Drawer state\n            modal: { isOpen: false, type: null, data: null },\n            drawer: { isOpen: false, type: null, data: null }\n        });\n    }\n    \n    /**\n     * Main dispatch handler - routes actions to reducers\n     */\n    dispatch(action) {\n        const { type, payload } = action;\n        \n        switch (type) {\n            // App Lifecycle\n            case Actions.Types.APP_INITIALIZED:\n                this.handleAppInitialized(payload);\n                break;\n            case Actions.Types.TAB_CHANGED:\n                this.handleTabChanged(payload);\n                break;\n                \n            // Data Loading\n            case Actions.Types.DATA_LOAD_REQUESTED:\n                this.handleDataLoadRequested();\n                break;\n            case Actions.Types.DATA_LOAD_STARTED:\n                this.handleDataLoadStarted();\n                break;\n            case Actions.Types.DATA_LOAD_SUCCESS:\n                this.handleDataLoadSuccess(payload);\n                break;\n            case Actions.Types.DATA_LOAD_FAILED:\n                this.handleDataLoadFailed(payload);\n                break;\n                \n            // Signal Management\n            case Actions.Types.SIGNALS_FILTERED:\n                this.handleSignalsFiltered(payload);\n                break;\n            case Actions.Types.SIGNAL_VIEWED:\n                this.handleSignalViewed(payload);\n                break;\n            case Actions.Types.SIGNAL_SELECTED:\n                this.handleSignalSelected(payload);\n                break;\n            case Actions.Types.SIGNAL_REMOVED:\n                this.handleSignalRemoved(payload);\n                break;\n            case Actions.Types.SIGNAL_DETAILS_OPENED:\n                this.handleSignalDetailsOpened(payload);\n                break;\n                \n            // Feedback (Optimistic Updates)\n            case Actions.Types.FEEDBACK_REQUESTED:\n                this.handleFeedbackRequested(payload);\n                break;\n            case Actions.Types.FEEDBACK_SUCCEEDED:\n                this.handleFeedbackSucceeded(payload);\n                break;\n            case Actions.Types.FEEDBACK_FAILED:\n                this.handleFeedbackFailed(payload);\n                break;\n                \n            // Comments\n            case Actions.Types.COMMENT_REQUESTED:\n                this.handleCommentRequested(payload);\n                break;\n            case Actions.Types.COMMENT_SUCCEEDED:\n                this.handleCommentSucceeded(payload);\n                break;\n            case Actions.Types.COMMENT_FAILED:\n                this.handleCommentFailed(payload);\n                break;\n                \n            // Action Plans\n            case Actions.Types.ACTION_PLAN_REQUESTED:\n                this.handleActionPlanRequested(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_SUCCEEDED:\n                this.handleActionPlanSucceeded(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_FAILED:\n                this.handleActionPlanFailed(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_UPDATED:\n                this.handleUpdateActionPlan(payload);\n                break;\n            case Actions.Types.ACTION_PLAN_DELETED:\n                this.handleDeleteActionPlan(payload);\n                break;\n                \n            // UI State\n            case Actions.Types.LOADING_SHOWN:\n                this.handleLoadingShown();\n                break;\n            case Actions.Types.LOADING_HIDDEN:\n                this.handleLoadingHidden();\n                break;\n            case Actions.Types.MESSAGE_SHOWN:\n                this.handleMessageShown(payload);\n                break;\n            case Actions.Types.MESSAGE_HIDDEN:\n                this.handleMessageHidden();\n                break;\n            case Actions.Types.PLAN_DRAWER_CLOSED:\n                this.handlePlanDrawerClosed();\n                break;\n            case Actions.Types.SIGNAL_DRAWER_CLOSED:\n                this.handleSignalDrawerClosed();\n                break;\n            case Actions.Types.PORTFOLIO_FILTERED:\n                this.handlePortfolioFiltered(payload);\n                break;\n                \n            // Account Management\n            case Actions.Types.ACCOUNT_EXPANDED:\n                this.handleAccountExpanded(payload);\n                break;\n            case Actions.Types.ACCOUNT_COLLAPSED:\n                this.handleAccountCollapsed(payload);\n                break;\n            case Actions.Types.SHOW_MORE_SIGNALS:\n                this.handleShowMoreSignals(payload);\n                break;\n            case Actions.Types.SHOW_LESS_SIGNALS:\n                this.handleShowLessSignals(payload);\n                break;\n                \n            // Modal/Drawer\n            case Actions.Types.MODAL_OPENED:\n                this.handleModalOpened(payload);\n                break;\n            case Actions.Types.MODAL_CLOSED:\n                this.handleModalClosed();\n                break;\n            case Actions.Types.DRAWER_OPENED:\n                this.handleDrawerOpened(payload);\n                break;\n            case Actions.Types.DRAWER_CLOSED:\n                this.handleDrawerClosed();\n                break;\n                \n            default:\n                console.log(`Unhandled action type: ${type}`);\n        }\n    }\n    \n    // ========== NORMALIZED DATA HANDLERS ==========\n    \n    handleDataLoadSuccess(payload) {\n        console.log('📦 SignalsStore: handleDataLoadSuccess with normalized data');\n        \n        const normalizedData = payload.data;\n        \n        // Store normalized entities\n        this.normalizedData = {\n            accounts: normalizedData.accounts || new Map(),\n            signals: normalizedData.signals || new Map(),\n            recommendedActions: normalizedData.recommendedActions || new Map(),\n            interactions: normalizedData.interactions || new Map(),\n            comments: normalizedData.comments || new Map(),\n            actionPlans: normalizedData.actionPlans || new Map()\n        };\n        \n        // Store relationship indexes\n        this.indexes = {\n            signalsByAccount: normalizedData.signalsByAccount || new Map(),\n            signalsByAction: normalizedData.signalsByAction || new Map(),\n            actionsByAccount: normalizedData.actionsByAccount || new Map(),\n            interactionsBySignal: normalizedData.interactionsBySignal || new Map(),\n            commentsBySignal: normalizedData.commentsBySignal || new Map(),\n            commentsByAccount: normalizedData.commentsByAccount || new Map(),\n            plansByAccount: normalizedData.plansByAccount || new Map(),\n            plansByAction: normalizedData.plansByAction || new Map()\n        };\n        \n        // Store user info\n        const userInfo = normalizedData.userInfo || { userId: 'user-1', userName: 'Current User' };\n        \n        // Create denormalized data for backward compatibility\n        const denormalizedSignals = this.getDenormalizedSignals();\n        const denormalizedAccounts = this.getDenormalizedAccounts();\n        \n        this.setState({\n            loading: false,\n            userInfo: userInfo,\n            signals: denormalizedSignals,\n            accounts: denormalizedAccounts,\n            filteredSignals: denormalizedSignals,\n            signalsById: this.createSignalsById(denormalizedSignals),\n            signalsByAccount: this.indexes.signalsByAccount,\n            interactionsByUser: new Map(),\n            actionPlansByAccount: this.indexes.plansByAccount,\n            comments: this.normalizedData.comments,\n            interactions: this.normalizedData.interactions,\n            actionPlans: this.normalizedData.actionPlans\n        });\n        \n        console.log('🔔 SignalsStore: Emitting data:loaded event');\n        this.emitChange('data:loaded');\n    }\n    \n    // ========== DENORMALIZATION HELPERS ==========\n    \n    getDenormalizedSignals() {\n        const signals = Array.from(this.normalizedData.signals.values());\n        return signals.map(signal => this.denormalizeSignal(signal));\n    }\n    \n    denormalizeSignal(signal) {\n        const account = this.normalizedData.accounts.get(signal.account_id);\n        const action = this.normalizedData.recommendedActions.get(signal.action_id);\n        const interactions = this.getSignalInteractions(signal.signal_id);\n        \n        // Check if user has interacted\n        const hasUserInteraction = interactions.some(i => \n            i.interactionType === 'like' || \n            i.interactionType === 'not-accurate' ||\n            i.interactionType === 'signal_viewed'\n        );\n        \n        const userFeedback = interactions.find(i => \n            i.interactionType === 'like' || i.interactionType === 'not-accurate'\n        );\n        \n        return {\n            ...signal,\n            id: signal.signal_id,\n            \n            // Merge account data (for backward compatibility)\n            account_name: account?.account_name || signal.account_name,\n            account_action_context: account?.account_action_context,\n            account_action_context_rationale: account?.account_action_context_rationale,\n            account_metrics: account?.account_metrics,\n            usage_metrics: account?.usage_metrics,\n            financial: account?.financial,\n            ownership: account?.ownership,\n            at_risk_cat: account?.at_risk_cat,\n            account_gpa: account?.account_gpa,\n            health_score: account?.health_score,\n            daily_active_users: account?.daily_active_users,\n            weekly_active_users: account?.weekly_active_users,\n            monthly_active_users: account?.monthly_active_users,\n            total_lifetime_billings: account?.total_lifetime_billings,\n            bks_renewal_baseline_usd: account?.bks_renewal_baseline_usd,\n            \n            // Merge action data\n            recommended_action: action?.recommended_action,\n            signal_rationale: action?.signal_rationale || signal.signal_rationale,\n            plays: action?.plays || [],\n            \n            // UI state\n            isViewed: hasUserInteraction || signal.isViewed,\n            currentUserFeedback: userFeedback?.interactionType,\n            feedback: userFeedback?.interactionType\n        };\n    }\n    \n    getDenormalizedAccounts() {\n        const accountsMap = new Map();\n        \n        this.normalizedData.accounts.forEach((account, accountId) => {\n            const signalIds = this.indexes.signalsByAccount.get(accountId) || new Set();\n            const signals = Array.from(signalIds)\n                .map(id => this.normalizedData.signals.get(id))\n                .filter(s => s)\n                .map(s => this.denormalizeSignal(s));\n            \n            accountsMap.set(accountId, {\n                ...account,\n                id: accountId,\n                name: account.account_name,\n                signals: signals\n            });\n        });\n        \n        return accountsMap;\n    }\n    \n    getSignalInteractions(signalId) {\n        const interactionIds = this.indexes.interactionsBySignal.get(signalId) || new Set();\n        return Array.from(interactionIds)\n            .map(id => this.normalizedData.interactions.get(id))\n            .filter(interaction => interaction !== null);\n    }\n    \n    createSignalsById(signals) {\n        const signalsById = new Map();\n        signals.forEach(signal => {\n            signalsById.set(signal.id, signal);\n        });\n        return signalsById;\n    }\n    \n    // ========== PUBLIC API METHODS ==========\n    \n    getSignals() {\n        // Return denormalized signals for backward compatibility\n        return this.getDenormalizedSignals();\n    }\n    \n    getAccounts() {\n        return this.getDenormalizedAccounts();\n    }\n    \n    getAccount(accountId) {\n        const account = this.normalizedData.accounts.get(accountId);\n        if (!account) return null;\n        \n        const signalIds = this.indexes.signalsByAccount.get(accountId) || new Set();\n        const signals = Array.from(signalIds)\n            .map(id => this.normalizedData.signals.get(id))\n            .filter(s => s)\n            .map(s => this.denormalizeSignal(s));\n        \n        return {\n            ...account,\n            id: accountId,\n            name: account.account_name,\n            signals: signals\n        };\n    }\n    \n    getSignal(signalId) {\n        const signal = this.normalizedData.signals.get(signalId);\n        return signal ? this.denormalizeSignal(signal) : null;\n    }\n    \n    getActionPlans() {\n        const plans = Array.from(this.normalizedData.actionPlans.values());\n        \n        // Enrich with account names\n        return plans.map(plan => {\n            const account = this.normalizedData.accounts.get(plan.accountId);\n            return {\n                ...plan,\n                accountName: account?.account_name || plan.accountId\n            };\n        });\n    }\n    \n    getComments(targetId) {\n        // Check both signal and account comments\n        const signalCommentIds = this.indexes.commentsBySignal.get(targetId) || new Set();\n        const accountCommentIds = this.indexes.commentsByAccount.get(targetId) || new Set();\n        \n        const allCommentIds = new Set([...signalCommentIds, ...accountCommentIds]);\n        \n        return Array.from(allCommentIds)\n            .map(id => this.normalizedData.comments.get(id))\n            .filter(comment => comment !== null);\n    }\n    \n    getInteractions(signalId) {\n        return this.getSignalInteractions(signalId);\n    }\n    \n    getUserInfo() {\n        return this.getState().userInfo;\n    }\n    \n    getFilteredSignals() {\n        let signals = this.getDenormalizedSignals();\n        const filters = this.getState().viewState.filters;\n        \n        // Apply filters\n        if (filters.priority !== 'all') {\n            signals = signals.filter(s => s.priority === filters.priority);\n        }\n        if (filters.category !== 'all') {\n            signals = signals.filter(s => s.category === filters.category);\n        }\n        if (filters.polarity !== 'all') {\n            signals = signals.filter(s => s.signal_polarity === filters.polarity);\n        }\n        if (filters.riskCategory !== 'all') {\n            signals = signals.filter(s => s.at_risk_cat === filters.riskCategory);\n        }\n        if (filters.searchText) {\n            const searchLower = filters.searchText.toLowerCase();\n            signals = signals.filter(s => \n                s.name?.toLowerCase().includes(searchLower) ||\n                s.summary?.toLowerCase().includes(searchLower) ||\n                s.account_name?.toLowerCase().includes(searchLower)\n            );\n        }\n        \n        return signals;\n    }\n    \n    // ========== CRUD OPERATIONS ==========\n    \n    createActionPlan(planData) {\n        const plan = {\n            id: planData.id || `plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            status: planData.status || 'pending',\n            assignee: this.getState().userInfo?.userId,\n            createdBy: this.getState().userInfo?.userName,\n            createdByUserId: this.getState().userInfo?.userId,\n            ...planData\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.actionPlans.set(plan.id, plan);\n        \n        // Update indexes\n        if (plan.accountId) {\n            if (!this.indexes.plansByAccount.has(plan.accountId)) {\n                this.indexes.plansByAccount.set(plan.accountId, new Set());\n            }\n            this.indexes.plansByAccount.get(plan.accountId).add(plan.id);\n        }\n        \n        if (plan.actionId) {\n            if (!this.indexes.plansByAction.has(plan.actionId)) {\n                this.indexes.plansByAction.set(plan.actionId, new Set());\n            }\n            this.indexes.plansByAction.get(plan.actionId).add(plan.id);\n        }\n        \n        // Update state for UI\n        const currentState = this.getState();\n        currentState.actionPlans.set(plan.id, plan);\n        this.setState({ \n            actionPlans: currentState.actionPlans,\n            actionPlansByAccount: this.indexes.plansByAccount\n        });\n        \n        this.emitChange('action_plan:created', plan);\n        return plan;\n    }\n    \n    updateActionPlan(planId, updates) {\n        const plan = this.normalizedData.actionPlans.get(planId);\n        if (!plan) return;\n        \n        const updatedPlan = {\n            ...plan,\n            ...updates,\n            updatedAt: new Date().toISOString(),\n            lastUpdatedBy: this.getState().userInfo?.userName,\n            lastUpdatedByUserId: this.getState().userInfo?.userId\n        };\n        \n        this.normalizedData.actionPlans.set(planId, updatedPlan);\n        \n        // Update state\n        const currentState = this.getState();\n        currentState.actionPlans.set(planId, updatedPlan);\n        this.setState({ actionPlans: currentState.actionPlans });\n        \n        this.emitChange('action_plan:updated', updatedPlan);\n        return updatedPlan;\n    }\n    \n    deleteActionPlan(planId) {\n        const plan = this.normalizedData.actionPlans.get(planId);\n        if (!plan) return;\n        \n        // Remove from indexes\n        if (plan.accountId && this.indexes.plansByAccount.has(plan.accountId)) {\n            this.indexes.plansByAccount.get(plan.accountId).delete(planId);\n        }\n        if (plan.actionId && this.indexes.plansByAction.has(plan.actionId)) {\n            this.indexes.plansByAction.get(plan.actionId).delete(planId);\n        }\n        \n        // Delete from normalized store\n        this.normalizedData.actionPlans.delete(planId);\n        \n        // Update state\n        const currentState = this.getState();\n        currentState.actionPlans.delete(planId);\n        this.setState({ actionPlans: currentState.actionPlans });\n        \n        this.emitChange('action_plan:deleted', planId);\n    }\n    \n    // ========== ACTION HANDLERS (keeping existing ones) ==========\n    \n    handleAppInitialized(payload) {\n        this.handleDataLoadSuccess(payload);\n        this.emitChange('app:initialized');\n    }\n    \n    handleTabChanged(payload) {\n        this.setState({\n            currentTab: payload.tabName\n        });\n        this.emitChange('tab:changed', payload.tabName);\n    }\n    \n    handleDataLoadRequested() {\n        this.setState({ loading: true });\n        this.emitChange('data:load-requested');\n    }\n    \n    handleDataLoadStarted() {\n        this.setState({ loading: true });\n        this.emitChange('loading:started');\n    }\n    \n    handleDataLoadFailed(payload) {\n        this.setState({ \n            loading: false,\n            message: { text: 'Failed to load data', type: 'error' }\n        });\n        this.emitChange('data:load_failed', payload.error);\n    }\n    \n    handleSignalRemoved(payload) {\n        const { signalId } = payload;\n        \n        // Remove from normalized store\n        const signal = this.normalizedData.signals.get(signalId);\n        if (signal) {\n            // Update indexes\n            if (signal.account_id && this.indexes.signalsByAccount.has(signal.account_id)) {\n                this.indexes.signalsByAccount.get(signal.account_id).delete(signalId);\n            }\n            if (signal.action_id && this.indexes.signalsByAction.has(signal.action_id)) {\n                this.indexes.signalsByAction.get(signal.action_id).delete(signalId);\n            }\n            \n            // Delete signal\n            this.normalizedData.signals.delete(signalId);\n            \n            // Update denormalized state\n            const denormalizedSignals = this.getDenormalizedSignals();\n            const denormalizedAccounts = this.getDenormalizedAccounts();\n            \n            this.setState({ \n                signals: denormalizedSignals,\n                accounts: denormalizedAccounts,\n                filteredSignals: this.applyFilters(this.getState().viewState.filters)\n            });\n        }\n        \n        this.emitChange('signal-removed', signalId);\n        this.emitChange('accounts-updated');\n    }\n    \n    handleSignalDetailsOpened(payload) {\n        const { signalId } = payload;\n        this.setState({ \n            selectedSignal: signalId,\n            drawer: { isOpen: true, type: 'signal-details', data: { signalId } }\n        });\n        this.emitChange('signal-details-opened', signalId);\n    }\n    \n    handlePlanDrawerClosed() {\n        this.setState({ \n            drawer: { isOpen: false, type: null, data: null }\n        });\n        this.emitChange('plan-drawer-closed');\n    }\n    \n    handleSignalDrawerClosed() {\n        this.setState({ \n            drawer: { isOpen: false, type: null, data: null },\n            selectedSignal: null\n        });\n        this.emitChange('signal-drawer-closed');\n    }\n    \n    handlePortfolioFiltered(payload) {\n        const { filterType } = payload;\n        this.emitChange('portfolio-filtered', filterType);\n    }\n    \n    handleAccountExpanded(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            account.isExpanded = true;\n            this.setState({ accounts });\n            this.emitChange('account-expanded', accountId);\n        }\n    }\n    \n    handleAccountCollapsed(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            account.isExpanded = false;\n            this.setState({ accounts });\n            this.emitChange('account-collapsed', accountId);\n        }\n    }\n    \n    handleShowMoreSignals(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            if (!account.signalsPagination) {\n                account.signalsPagination = { currentPage: 0, pageSize: 3 };\n            }\n            account.signalsPagination.currentPage++;\n            this.setState({ accounts });\n            this.emitChange('accounts-updated');\n        }\n    }\n    \n    handleShowLessSignals(payload) {\n        const { accountId } = payload;\n        const accounts = this.getState().accounts;\n        const account = accounts.get(accountId);\n        if (account) {\n            if (!account.signalsPagination) {\n                account.signalsPagination = { currentPage: 0, pageSize: 3 };\n            }\n            account.signalsPagination.currentPage = 0;\n            this.setState({ accounts });\n            this.emitChange('accounts-updated');\n        }\n    }\n    \n    handleSignalsFiltered(payload) {\n        const newViewState = {\n            ...this.state.viewState,\n            filters: payload.filters || this.state.viewState.filters\n        };\n        \n        const filteredSignals = this.applyFilters(payload.filters);\n        this.setState({ \n            filteredSignals,\n            viewState: newViewState\n        });\n        this.emitChange('signals:filtered', filteredSignals);\n    }\n    \n    handleSignalViewed(payload) {\n        const interaction = {\n            id: `interaction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: payload.signalId,\n            interactionType: 'signal_viewed',\n            timestamp: new Date().toISOString(),\n            userId: this.getState().userInfo?.userId,\n            userName: this.getState().userInfo?.userName,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.interactions.set(interaction.id, interaction);\n        \n        // Update index\n        if (!this.indexes.interactionsBySignal.has(interaction.signalId)) {\n            this.indexes.interactionsBySignal.set(interaction.signalId, new Set());\n        }\n        this.indexes.interactionsBySignal.get(interaction.signalId).add(interaction.id);\n        \n        // Mark signal as viewed\n        const signal = this.normalizedData.signals.get(payload.signalId);\n        if (signal) {\n            signal.isViewed = true;\n        }\n        \n        this.emitChange('signal:viewed', payload.signalId);\n    }\n    \n    handleSignalSelected(payload) {\n        this.setState({ selectedSignal: payload.signal });\n        this.emitChange('signal:selected', payload.signal);\n    }\n    \n    handleFeedbackRequested(payload) {\n        const { signalId, feedbackType, userId, operationId } = payload;\n        \n        // Create snapshot for rollback\n        this.createSnapshot(operationId);\n        \n        // Add interaction\n        const interaction = {\n            id: `interaction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: signalId,\n            interactionType: feedbackType,\n            timestamp: new Date().toISOString(),\n            userId: userId || this.getState().userInfo?.userId,\n            userName: this.getState().userInfo?.userName,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.interactions.set(interaction.id, interaction);\n        \n        // Update index\n        if (!this.indexes.interactionsBySignal.has(interaction.signalId)) {\n            this.indexes.interactionsBySignal.set(interaction.signalId, new Set());\n        }\n        this.indexes.interactionsBySignal.get(interaction.signalId).add(interaction.id);\n        \n        this.emitChange('feedback:requested', { signalId, feedbackType });\n    }\n    \n    handleFeedbackSucceeded(payload) {\n        const { operationId } = payload;\n        this.commitSnapshot(operationId);\n        this.emitChange('feedback:succeeded', payload);\n    }\n    \n    handleFeedbackFailed(payload) {\n        const { operationId, error } = payload;\n        this.rollback(operationId);\n        this.setState({\n            message: { text: 'Failed to save feedback', type: 'error' }\n        });\n        this.emitChange('feedback:failed', { error });\n    }\n    \n    handleCommentRequested(payload) {\n        const { signalId, accountId, text, userId, operationId } = payload;\n        \n        this.createSnapshot(operationId);\n        \n        const comment = {\n            id: `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            signalId: signalId || null,\n            accountId: accountId || null,\n            text: text,\n            author: this.getState().userInfo?.userName,\n            authorId: userId || this.getState().userInfo?.userId,\n            timestamp: new Date().toISOString(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            isOptimistic: true\n        };\n        \n        // Store in normalized structure\n        this.normalizedData.comments.set(comment.id, comment);\n        \n        // Update indexes\n        if (comment.signalId) {\n            if (!this.indexes.commentsBySignal.has(comment.signalId)) {\n                this.indexes.commentsBySignal.set(comment.signalId, new Set());\n            }\n            this.indexes.commentsBySignal.get(comment.signalId).add(comment.id);\n        } else if (comment.accountId) {\n            if (!this.indexes.commentsByAccount.has(comment.accountId)) {\n                this.indexes.commentsByAccount.set(comment.accountId, new Set());\n            }\n            this.indexes.commentsByAccount.get(comment.accountId).add(comment.id);\n        }\n        \n        this.emitChange('comment:requested', comment);\n    }\n    \n    handleCommentSucceeded(payload) {\n        const { comment, operationId } = payload;\n        \n        // Update the optimistic comment\n        const existingComment = this.normalizedData.comments.get(comment.id);\n        if (existingComment) {\n            this.normalizedData.comments.set(comment.id, { ...comment, isOptimistic: false });\n        }\n        \n        this.commitSnapshot(operationId);\n        this.emitChange('comment:succeeded', comment);\n    }\n    \n    handleCommentFailed(payload) {\n        const { operationId, error } = payload;\n        this.rollback(operationId);\n        this.setState({\n            message: { text: 'Failed to save comment', type: 'error' }\n        });\n        this.emitChange('comment:failed', { error });\n    }\n    \n    handleActionPlanRequested(payload) {\n        const { signalId, title, description, tasks, userId, operationId } = payload;\n        \n        this.createSnapshot(operationId);\n        \n        const plan = this.createActionPlan({\n            signalId,\n            title,\n            description,\n            tasks: tasks || [],\n            userId: userId || this.getState().userInfo?.userId,\n            isOptimistic: true\n        });\n        \n        this.emitChange('action_plan:requested', plan);\n    }\n    \n    handleActionPlanSucceeded(payload) {\n        const { plan, operationId } = payload;\n        \n        const existingPlan = this.normalizedData.actionPlans.get(plan.id);\n        if (existingPlan) {\n            this.normalizedData.actionPlans.set(plan.id, { ...plan, isOptimistic: false });\n        }\n        \n        this.commitSnapshot(operationId);\n        this.emitChange('action_plan:succeeded', plan);\n    }\n    \n    handleActionPlanFailed(payload) {\n        const { operationId, error } = payload;\n        this.rollback(operationId);\n        this.setState({\n            message: { text: 'Failed to save action plan', type: 'error' }\n        });\n        this.emitChange('action_plan:failed', { error });\n    }\n    \n    handleUpdateActionPlan(payload) {\n        const { planId, updates } = payload;\n        this.updateActionPlan(planId, updates);\n    }\n    \n    handleDeleteActionPlan(payload) {\n        const { planId } = payload;\n        this.deleteActionPlan(planId);\n    }\n    \n    handleLoadingShown() {\n        this.setState({ loading: true });\n        this.emitChange('loading:shown');\n    }\n    \n    handleLoadingHidden() {\n        this.setState({ loading: false });\n        this.emitChange('loading:hidden');\n    }\n    \n    handleMessageShown(payload) {\n        this.setState({\n            message: { text: payload.message, type: payload.type }\n        });\n        this.emitChange('message:shown', payload);\n    }\n    \n    handleMessageHidden() {\n        this.setState({ message: null });\n        this.emitChange('message:hidden');\n    }\n    \n    handleModalOpened(payload) {\n        this.setState({\n            modal: { \n                isOpen: true, \n                type: payload.modalType, \n                data: payload.data \n            }\n        });\n        this.emitChange('modal:opened', payload);\n    }\n    \n    handleModalClosed() {\n        this.setState({\n            modal: { isOpen: false, type: null, data: null }\n        });\n        this.emitChange('modal:closed');\n    }\n    \n    handleDrawerOpened(payload) {\n        this.setState({\n            drawer: { \n                isOpen: true, \n                type: payload.drawerType, \n                data: payload.data \n            }\n        });\n        this.emitChange('drawer:opened', payload);\n    }\n    \n    handleDrawerClosed() {\n        this.setState({\n            drawer: { isOpen: false, type: null, data: null }\n        });\n        this.emitChange('drawer:closed');\n    }\n    \n    // ========== HELPER METHODS ==========\n    \n    applyFilters(filters) {\n        let signals = this.getDenormalizedSignals();\n        \n        if (!filters) return signals;\n        \n        if (filters.priority && filters.priority !== 'all') {\n            signals = signals.filter(s => s.priority === filters.priority);\n        }\n        if (filters.category && filters.category !== 'all') {\n            signals = signals.filter(s => s.category === filters.category);\n        }\n        if (filters.signalType && filters.signalType !== 'all') {\n            signals = signals.filter(s => s.category === filters.signalType);\n        }\n        if (filters.polarity && filters.polarity !== 'all') {\n            signals = signals.filter(s => s.signal_polarity === filters.polarity);\n        }\n        if (filters.riskCategory && filters.riskCategory !== 'all') {\n            signals = signals.filter(s => s.at_risk_cat === filters.riskCategory);\n        }\n        if (filters.searchText) {\n            const searchLower = filters.searchText.toLowerCase();\n            signals = signals.filter(s => \n                s.name?.toLowerCase().includes(searchLower) ||\n                s.summary?.toLowerCase().includes(searchLower) ||\n                s.account_name?.toLowerCase().includes(searchLower)\n            );\n        }\n        \n        return signals;\n    }\n}\n\n// Create singleton instance\nconst signalsStore = new SignalsStore();\n\n// Make globally available\nwindow.SignalsStore = SignalsStore;\nwindow.signalsStore = signalsStore;","size_bytes":35372},"js/utils/VirtualScrollManager.js":{"content":"// VirtualScrollManager - Handles efficient rendering of large lists with virtual scrolling\nclass VirtualScrollManager {\n    constructor(options = {}) {\n        this.container = null;\n        this.viewport = null;\n        this.scrollContainer = null;\n        this.items = [];\n        this.visibleItems = [];\n        \n        // Configuration\n        this.itemHeight = options.itemHeight || 200; // Estimated height per signal card\n        this.bufferSize = options.bufferSize || 5; // Extra items to render outside viewport\n        this.pageSize = options.pageSize || 50; // Items per page for rendering\n        this.renderCallback = options.renderCallback || (() => {});\n        this.loadMoreCallback = options.loadMoreCallback || (() => {});\n        \n        // State\n        this.scrollTop = 0;\n        this.containerHeight = 0;\n        this.totalHeight = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        this.isLoading = false;\n        this.hasMore = true;\n        \n        // Performance optimization\n        this.scrollDebounceTimer = null;\n        this.renderFrame = null;\n        this.lastRenderTime = 0;\n    }\n    \n    /**\n     * Initialize virtual scrolling on a container\n     */\n    initialize(containerId, items = []) {\n        this.container = document.getElementById(containerId);\n        if (!this.container) {\n            console.error('VirtualScrollManager: Container not found:', containerId);\n            return;\n        }\n        \n        // Create structure for virtual scrolling\n        this.setupDOM();\n        \n        // Set initial items\n        this.setItems(items);\n        \n        // Attach scroll listener\n        this.attachScrollListener();\n        \n        // Initial render\n        this.updateVisibleItems();\n        \n        console.log(`📜 Virtual scrolling initialized with ${items.length} items`);\n    }\n    \n    /**\n     * Setup DOM structure for virtual scrolling\n     */\n    setupDOM() {\n        // Clear container\n        this.container.innerHTML = '';\n        \n        // Create viewport (visible area)\n        this.viewport = document.createElement('div');\n        this.viewport.className = 'virtual-viewport';\n        this.viewport.style.cssText = `\n            position: relative;\n            height: 100%;\n            overflow-y: auto;\n            overflow-x: hidden;\n        `;\n        \n        // Create scroll container (maintains scroll height)\n        this.scrollContainer = document.createElement('div');\n        this.scrollContainer.className = 'virtual-scroll-container';\n        this.scrollContainer.style.cssText = `\n            position: relative;\n            width: 100%;\n        `;\n        \n        // Create content container (holds visible items)\n        this.contentContainer = document.createElement('div');\n        this.contentContainer.className = 'virtual-content';\n        this.contentContainer.style.cssText = `\n            position: absolute;\n            top: 0;\n            left: 0;\n            right: 0;\n        `;\n        \n        // Loading indicator\n        this.loadingIndicator = document.createElement('div');\n        this.loadingIndicator.className = 'loading-indicator';\n        this.loadingIndicator.style.cssText = `\n            display: none;\n            text-align: center;\n            padding: 20px;\n            color: #666;\n        `;\n        this.loadingIndicator.innerHTML = `\n            <i class=\"fas fa-spinner fa-spin\"></i> Loading more signals...\n        `;\n        \n        // Assemble DOM\n        this.scrollContainer.appendChild(this.contentContainer);\n        this.scrollContainer.appendChild(this.loadingIndicator);\n        this.viewport.appendChild(this.scrollContainer);\n        this.container.appendChild(this.viewport);\n    }\n    \n    /**\n     * Update items list and re-render\n     */\n    setItems(items, append = false) {\n        if (append) {\n            this.items = [...this.items, ...items];\n        } else {\n            this.items = items;\n        }\n        \n        // Update total height based on all items\n        this.totalHeight = this.items.length * this.itemHeight;\n        this.scrollContainer.style.height = `${this.totalHeight}px`;\n        \n        // Update visible items\n        this.updateVisibleItems();\n    }\n    \n    /**\n     * Attach scroll event listener with debouncing\n     */\n    attachScrollListener() {\n        this.viewport.addEventListener('scroll', (e) => {\n            this.scrollTop = e.target.scrollTop;\n            \n            // Debounce scroll updates for performance\n            if (this.scrollDebounceTimer) {\n                clearTimeout(this.scrollDebounceTimer);\n            }\n            \n            this.scrollDebounceTimer = setTimeout(() => {\n                this.handleScroll();\n            }, 10);\n        });\n    }\n    \n    /**\n     * Handle scroll event\n     */\n    handleScroll() {\n        // Update visible items\n        this.updateVisibleItems();\n        \n        // Check if we need to load more data (infinite scroll)\n        this.checkLoadMore();\n    }\n    \n    /**\n     * Calculate and render visible items\n     */\n    updateVisibleItems() {\n        // Cancel previous render frame if pending\n        if (this.renderFrame) {\n            cancelAnimationFrame(this.renderFrame);\n        }\n        \n        this.renderFrame = requestAnimationFrame(() => {\n            const now = performance.now();\n            \n            // Skip if rendered recently (within 16ms)\n            if (now - this.lastRenderTime < 16) {\n                return;\n            }\n            \n            this.containerHeight = this.viewport.clientHeight;\n            \n            // Calculate visible range with buffer\n            this.startIndex = Math.max(0, \n                Math.floor(this.scrollTop / this.itemHeight) - this.bufferSize\n            );\n            \n            this.endIndex = Math.min(this.items.length - 1,\n                Math.ceil((this.scrollTop + this.containerHeight) / this.itemHeight) + this.bufferSize\n            );\n            \n            // Get visible items\n            this.visibleItems = this.items.slice(this.startIndex, this.endIndex + 1);\n            \n            // Render visible items\n            this.render();\n            \n            this.lastRenderTime = now;\n        });\n    }\n    \n    /**\n     * Render visible items to DOM\n     */\n    render() {\n        // Calculate offset for visible items\n        const offsetY = this.startIndex * this.itemHeight;\n        \n        // Position content container\n        this.contentContainer.style.transform = `translateY(${offsetY}px)`;\n        \n        // Clear and render visible items\n        this.contentContainer.innerHTML = '';\n        \n        // Use document fragment for better performance\n        const fragment = document.createDocumentFragment();\n        \n        this.visibleItems.forEach((item, index) => {\n            const element = this.renderCallback(item, this.startIndex + index);\n            if (element) {\n                // Create wrapper div for consistent height\n                const wrapper = document.createElement('div');\n                wrapper.className = 'virtual-item';\n                wrapper.style.minHeight = `${this.itemHeight}px`;\n                wrapper.innerHTML = element;\n                fragment.appendChild(wrapper);\n            }\n        });\n        \n        this.contentContainer.appendChild(fragment);\n        \n        // Log performance metrics\n        if (this.visibleItems.length > 0) {\n            console.log(`🎯 Rendering ${this.visibleItems.length} of ${this.items.length} items (indices ${this.startIndex}-${this.endIndex})`);\n        }\n    }\n    \n    /**\n     * Check if we need to load more data (infinite scroll)\n     */\n    checkLoadMore() {\n        // Skip if already loading or no more data\n        if (this.isLoading || !this.hasMore) {\n            return;\n        }\n        \n        // Check if scrolled near bottom (within 500px)\n        const scrollBottom = this.scrollTop + this.containerHeight;\n        const threshold = this.totalHeight - 500;\n        \n        if (scrollBottom >= threshold && this.endIndex >= this.items.length - 10) {\n            this.loadMore();\n        }\n    }\n    \n    /**\n     * Load more data\n     */\n    async loadMore() {\n        if (this.isLoading) return;\n        \n        this.isLoading = true;\n        this.loadingIndicator.style.display = 'block';\n        \n        console.log('📥 Loading more signals...');\n        \n        try {\n            // Call the load more callback\n            const hasMore = await this.loadMoreCallback();\n            this.hasMore = hasMore;\n            \n            if (!hasMore) {\n                console.log('✅ All signals loaded');\n            }\n        } catch (error) {\n            console.error('❌ Error loading more signals:', error);\n        } finally {\n            this.isLoading = false;\n            this.loadingIndicator.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Scroll to a specific item\n     */\n    scrollToItem(index) {\n        const targetScroll = index * this.itemHeight;\n        this.viewport.scrollTop = targetScroll;\n    }\n    \n    /**\n     * Get current scroll percentage\n     */\n    getScrollProgress() {\n        if (this.totalHeight === 0) return 0;\n        return (this.scrollTop / (this.totalHeight - this.containerHeight)) * 100;\n    }\n    \n    /**\n     * Destroy and cleanup\n     */\n    destroy() {\n        if (this.scrollDebounceTimer) {\n            clearTimeout(this.scrollDebounceTimer);\n        }\n        if (this.renderFrame) {\n            cancelAnimationFrame(this.renderFrame);\n        }\n        \n        this.container.innerHTML = '';\n        this.items = [];\n        this.visibleItems = [];\n        \n        console.log('🧹 Virtual scroll manager destroyed');\n    }\n    \n    /**\n     * Update estimated item height based on actual rendered items\n     * This improves scroll accuracy over time\n     */\n    updateItemHeight() {\n        const items = this.contentContainer.querySelectorAll('.virtual-item');\n        if (items.length > 0) {\n            let totalHeight = 0;\n            items.forEach(item => {\n                totalHeight += item.offsetHeight;\n            });\n            \n            const avgHeight = Math.round(totalHeight / items.length);\n            \n            // Only update if significantly different (>10% change)\n            if (Math.abs(avgHeight - this.itemHeight) > this.itemHeight * 0.1) {\n                console.log(`📏 Updating item height from ${this.itemHeight}px to ${avgHeight}px`);\n                this.itemHeight = avgHeight;\n                \n                // Recalculate total height\n                this.totalHeight = this.items.length * this.itemHeight;\n                this.scrollContainer.style.height = `${this.totalHeight}px`;\n            }\n        }\n    }\n}\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = VirtualScrollManager;\n}","size_bytes":10976}},"version":1}